--- ffmpeg-2.5/localinc/fdk-aac/FDK_audio.h.dl_headers~	2014-12-04 22:53:11.253165674 +0100
+++ ffmpeg-2.5/localinc/fdk-aac/FDK_audio.h	2014-12-04 22:53:11.253165674 +0100
@@ -0,0 +1,635 @@
+
+/* -----------------------------------------------------------------------------------------------------------
+Software License for The Fraunhofer FDK AAC Codec Library for Android
+
+© Copyright  1995 - 2013 Fraunhofer-Gesellschaft zur Förderung der angewandten Forschung e.V.
+  All rights reserved.
+
+ 1.    INTRODUCTION
+The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software that implements
+the MPEG Advanced Audio Coding ("AAC") encoding and decoding scheme for digital audio.
+This FDK AAC Codec software is intended to be used on a wide variety of Android devices.
+
+AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient general perceptual
+audio codecs. AAC-ELD is considered the best-performing full-bandwidth communications codec by
+independent studies and is widely deployed. AAC has been standardized by ISO and IEC as part
+of the MPEG specifications.
+
+Patent licenses for necessary patent claims for the FDK AAC Codec (including those of Fraunhofer)
+may be obtained through Via Licensing (www.vialicensing.com) or through the respective patent owners
+individually for the purpose of encoding or decoding bit streams in products that are compliant with
+the ISO/IEC MPEG audio standards. Please note that most manufacturers of Android devices already license
+these patent claims through Via Licensing or directly from the patent owners, and therefore FDK AAC Codec
+software may already be covered under those patent licenses when it is used for those licensed purposes only.
+
+Commercially-licensed AAC software libraries, including floating-point versions with enhanced sound quality,
+are also available from Fraunhofer. Users are encouraged to check the Fraunhofer website for additional
+applications information and documentation.
+
+2.    COPYRIGHT LICENSE
+
+Redistribution and use in source and binary forms, with or without modification, are permitted without
+payment of copyright license fees provided that you satisfy the following conditions:
+
+You must retain the complete text of this software license in redistributions of the FDK AAC Codec or
+your modifications thereto in source code form.
+
+You must retain the complete text of this software license in the documentation and/or other materials
+provided with redistributions of the FDK AAC Codec or your modifications thereto in binary form.
+You must make available free of charge copies of the complete source code of the FDK AAC Codec and your
+modifications thereto to recipients of copies in binary form.
+
+The name of Fraunhofer may not be used to endorse or promote products derived from this library without
+prior written permission.
+
+You may not charge copyright license fees for anyone to use, copy or distribute the FDK AAC Codec
+software or your modifications thereto.
+
+Your modified versions of the FDK AAC Codec must carry prominent notices stating that you changed the software
+and the date of any change. For modified versions of the FDK AAC Codec, the term
+"Fraunhofer FDK AAC Codec Library for Android" must be replaced by the term
+"Third-Party Modified Version of the Fraunhofer FDK AAC Codec Library for Android."
+
+3.    NO PATENT LICENSE
+
+NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without limitation the patents of Fraunhofer,
+ARE GRANTED BY THIS SOFTWARE LICENSE. Fraunhofer provides no warranty of patent non-infringement with
+respect to this software.
+
+You may use this FDK AAC Codec software or modifications thereto only for purposes that are authorized
+by appropriate patent licenses.
+
+4.    DISCLAIMER
+
+This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright holders and contributors
+"AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, including but not limited to the implied warranties
+of merchantability and fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary, or consequential damages,
+including but not limited to procurement of substitute goods or services; loss of use, data, or profits,
+or business interruption, however caused and on any theory of liability, whether in contract, strict
+liability, or tort (including negligence), arising in any way out of the use of this software, even if
+advised of the possibility of such damage.
+
+5.    CONTACT INFORMATION
+
+Fraunhofer Institute for Integrated Circuits IIS
+Attention: Audio and Multimedia Departments - FDK AAC LL
+Am Wolfsmantel 33
+91058 Erlangen, Germany
+
+www.iis.fraunhofer.de/amm
+amm-info@iis.fraunhofer.de
+----------------------------------------------------------------------------------------------------------- */
+
+/**************************  Fraunhofer IIS FDK SysLib  **********************
+
+   Author(s):   Manuel Jander
+
+******************************************************************************/
+
+/** \file   FDK_audio.h
+ *  \brief  Global audio struct and constant definitions.
+ */
+
+#ifndef FDK_AUDIO_H
+#define FDK_AUDIO_H
+
+#include "machine_type.h"
+#include "genericStds.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/**
+ * File format identifiers.
+ */
+typedef enum
+{
+  FF_UNKNOWN           = -1, /**< Unknown format.        */
+  FF_RAW               = 0,  /**< No container, bit stream data conveyed "as is". */
+
+  FF_MP4_3GPP          = 3,  /**< 3GPP file format.      */
+  FF_MP4_MP4F          = 4,  /**< MPEG-4 File format.     */
+
+  FF_RAWPACKETS        = 5,  /**< Proprietary raw packet file. */
+
+  FF_DRMCT             = 12  /**< Digital Radio Mondial (DRM30/DRM+) CT proprietary file format. */
+
+} FILE_FORMAT;
+
+/**
+ * Transport type identifiers.
+ */
+typedef enum
+{
+  TT_UNKNOWN           = -1, /**< Unknown format.            */
+  TT_MP4_RAW           = 0,  /**< "as is" access units (packet based since there is obviously no sync layer) */
+  TT_MP4_ADIF          = 1,  /**< ADIF bitstream format.     */
+  TT_MP4_ADTS          = 2,  /**< ADTS bitstream format.     */
+
+  TT_MP4_LATM_MCP1     = 6,  /**< Audio Mux Elements with muxConfigPresent = 1 */
+  TT_MP4_LATM_MCP0     = 7,  /**< Audio Mux Elements with muxConfigPresent = 0, out of band StreamMuxConfig */
+
+  TT_MP4_LOAS          = 10, /**< Audio Sync Stream.         */
+
+  TT_DRM               = 12, /**< Digital Radio Mondial (DRM30/DRM+) bitstream format. */
+
+  TT_MP1_L1            = 16, /**< MPEG 1 Audio Layer 1 audio bitstream. */
+  TT_MP1_L2            = 17, /**< MPEG 1 Audio Layer 2 audio bitstream. */
+  TT_MP1_L3            = 18, /**< MPEG 1 Audio Layer 3 audio bitstream. */
+
+  TT_RSVD50            = 50 /**< */
+
+} TRANSPORT_TYPE;
+
+#define TT_IS_PACKET(x) \
+       ( ((x) == TT_MP4_RAW) \
+      || ((x) == TT_DRM) \
+      || ((x) == TT_MP4_LATM_MCP0) \
+      || ((x) == TT_MP4_LATM_MCP1) )
+
+/**
+ * Audio Object Type definitions.
+ */
+typedef enum
+{
+  AOT_NONE             = -1,
+  AOT_NULL_OBJECT      = 0,
+  AOT_AAC_MAIN         = 1, /**< Main profile                              */
+  AOT_AAC_LC           = 2, /**< Low Complexity object                     */
+  AOT_AAC_SSR          = 3,
+  AOT_AAC_LTP          = 4,
+  AOT_SBR              = 5,
+  AOT_AAC_SCAL         = 6,
+  AOT_TWIN_VQ          = 7,
+  AOT_CELP             = 8,
+  AOT_HVXC             = 9,
+  AOT_RSVD_10          = 10, /**< (reserved)                                */
+  AOT_RSVD_11          = 11, /**< (reserved)                                */
+  AOT_TTSI             = 12, /**< TTSI Object                               */
+  AOT_MAIN_SYNTH       = 13, /**< Main Synthetic object                     */
+  AOT_WAV_TAB_SYNTH    = 14, /**< Wavetable Synthesis object                */
+  AOT_GEN_MIDI         = 15, /**< General MIDI object                       */
+  AOT_ALG_SYNTH_AUD_FX = 16, /**< Algorithmic Synthesis and Audio FX object */
+  AOT_ER_AAC_LC        = 17, /**< Error Resilient(ER) AAC Low Complexity    */
+  AOT_RSVD_18          = 18, /**< (reserved)                                */
+  AOT_ER_AAC_LTP       = 19, /**< Error Resilient(ER) AAC LTP object        */
+  AOT_ER_AAC_SCAL      = 20, /**< Error Resilient(ER) AAC Scalable object   */
+  AOT_ER_TWIN_VQ       = 21, /**< Error Resilient(ER) TwinVQ object         */
+  AOT_ER_BSAC          = 22, /**< Error Resilient(ER) BSAC object           */
+  AOT_ER_AAC_LD        = 23, /**< Error Resilient(ER) AAC LowDelay object   */
+  AOT_ER_CELP          = 24, /**< Error Resilient(ER) CELP object           */
+  AOT_ER_HVXC          = 25, /**< Error Resilient(ER) HVXC object           */
+  AOT_ER_HILN          = 26, /**< Error Resilient(ER) HILN object           */
+  AOT_ER_PARA          = 27, /**< Error Resilient(ER) Parametric object     */
+  AOT_RSVD_28          = 28, /**< might become SSC                          */
+  AOT_PS               = 29, /**< PS, Parametric Stereo (includes SBR)      */
+  AOT_MPEGS            = 30, /**< MPEG Surround                             */
+
+  AOT_ESCAPE           = 31, /**< Signal AOT uses more than 5 bits          */
+
+  AOT_MP3ONMP4_L1      = 32, /**< MPEG-Layer1 in mp4                        */
+  AOT_MP3ONMP4_L2      = 33, /**< MPEG-Layer2 in mp4                        */
+  AOT_MP3ONMP4_L3      = 34, /**< MPEG-Layer3 in mp4                        */
+  AOT_RSVD_35          = 35, /**< might become DST                          */
+  AOT_RSVD_36          = 36, /**< might become ALS                          */
+  AOT_AAC_SLS          = 37, /**< AAC + SLS                                 */
+  AOT_SLS              = 38, /**< SLS                                       */
+  AOT_ER_AAC_ELD       = 39, /**< AAC Enhanced Low Delay                    */
+
+  AOT_USAC             = 42, /**< USAC                                      */
+  AOT_SAOC             = 43, /**< SAOC                                      */
+  AOT_LD_MPEGS         = 44, /**< Low Delay MPEG Surround                   */
+
+  AOT_RSVD50           = 50,  /**< Interim AOT for Rsvd50                   */
+
+  /* Pseudo AOTs */
+  AOT_MP2_AAC_MAIN     = 128, /**< Virtual AOT MP2 Main profile                           */
+  AOT_MP2_AAC_LC       = 129, /**< Virtual AOT MP2 Low Complexity profile                 */
+  AOT_MP2_AAC_SSR      = 130, /**< Virtual AOT MP2 Scalable Sampling Rate profile         */
+
+  AOT_MP2_SBR          = 132, /**< Virtual AOT MP2 Low Complexity Profile with SBR        */
+
+  AOT_DAB              = 134, /**< Virtual AOT for DAB (Layer2 with scalefactor CRC)      */
+  AOT_DABPLUS_AAC_LC   = 135, /**< Virtual AOT for DAB plus AAC-LC                        */
+  AOT_DABPLUS_SBR      = 136, /**< Virtual AOT for DAB plus HE-AAC                        */
+  AOT_DABPLUS_PS       = 137, /**< Virtual AOT for DAB plus HE-AAC v2                     */
+
+  AOT_PLAIN_MP1        = 140, /**< Virtual AOT for plain mp1                              */
+  AOT_PLAIN_MP2        = 141, /**< Virtual AOT for plain mp2                              */
+  AOT_PLAIN_MP3        = 142, /**< Virtual AOT for plain mp3                              */
+
+  AOT_DRM_AAC          = 143, /**< Virtual AOT for DRM (ER-AAC-SCAL without SBR)          */
+  AOT_DRM_SBR          = 144, /**< Virtual AOT for DRM (ER-AAC-SCAL with SBR)             */
+  AOT_DRM_MPEG_PS      = 145, /**< Virtual AOT for DRM (ER-AAC-SCAL with SBR and MPEG-PS) */
+  AOT_DRM_SURROUND     = 146, /**< Virtual AOT for DRM Surround (ER-AAC-SCAL (+SBR) +MPS) */
+
+  AOT_MP2_PS           = 156, /**< Virtual AOT MP2 Low Complexity Profile with SBR and PS */
+
+  AOT_MPEGS_RESIDUALS  = 256  /**< Virtual AOT for MPEG Surround residuals                */
+
+} AUDIO_OBJECT_TYPE;
+
+/** Channel Mode ( 1-7 equals MPEG channel configurations, others are arbitrary). */
+typedef enum {
+  MODE_INVALID                  = -1,
+  MODE_UNKNOWN                  =  0,
+  MODE_1                        =  1,       /**< C */
+  MODE_2                        =  2,       /**< L+R */
+  MODE_1_2                      =  3,       /**< C, L+R */
+  MODE_1_2_1                    =  4,       /**< C, L+R, Rear */
+  MODE_1_2_2                    =  5,       /**< C, L+R, LS+RS */
+  MODE_1_2_2_1                  =  6,       /**< C, L+R, LS+RS, LFE */
+  MODE_1_2_2_2_1                =  7,       /**< C, LC+RC, L+R, LS+RS, LFE */
+
+
+  MODE_1_1                      = 16,       /**< 2 SCEs (dual mono) */
+  MODE_1_1_1_1                  = 17,       /**< 4 SCEs */
+  MODE_1_1_1_1_1_1              = 18,       /**< 6 SCEs */
+  MODE_1_1_1_1_1_1_1_1          = 19,       /**< 8 SCEs */
+  MODE_1_1_1_1_1_1_1_1_1_1_1_1  = 20,       /**< 12 SCEs */
+
+  MODE_2_2                      = 21,       /**< 2 CPEs */
+  MODE_2_2_2                    = 22,       /**< 3 CPEs */
+  MODE_2_2_2_2                  = 23,       /**< 4 CPEs */
+  MODE_2_2_2_2_2_2              = 24,       /**< 6 CPEs */
+
+  MODE_2_1                      = 30,       /**< CPE,SCE (ARIB standard B32) */
+
+  MODE_7_1_REAR_SURROUND        = 33,       /**< C, L+R, LS+RS, Lrear+Rrear, LFE */
+  MODE_7_1_FRONT_CENTER         = 34        /**< C, LC+RC, L+R, LS+RS, LFE */
+
+} CHANNEL_MODE;
+
+/** Speaker description tags */
+typedef enum {
+  ACT_NONE,
+  ACT_FRONT,
+  ACT_SIDE,
+  ACT_BACK,
+  ACT_LFE,
+  ACT_FRONT_TOP,
+  ACT_SIDE_TOP,
+  ACT_BACK_TOP,
+  ACT_TOP /* Ts */
+} AUDIO_CHANNEL_TYPE;
+
+typedef enum
+{
+  SIG_UNKNOWN                 = -1,
+  SIG_IMPLICIT                =  0,
+  SIG_EXPLICIT_BW_COMPATIBLE  =  1,
+  SIG_EXPLICIT_HIERARCHICAL   =  2
+
+} SBR_PS_SIGNALING;
+
+/**
+ * Audio Codec flags.
+ */
+#define AC_ER_VCB11     0x000001  /*!< aacSectionDataResilienceFlag     flag (from ASC): 1 means use virtual codebooks  */
+#define AC_ER_RVLC      0x000002  /*!< aacSpectralDataResilienceFlag     flag (from ASC): 1 means use huffman codeword reordering */
+#define AC_ER_HCR       0x000004  /*!< aacSectionDataResilienceFlag     flag (from ASC): 1 means use virtual codebooks  */
+#define AC_SCALABLE     0x000008  /*!< AAC Scalable*/
+#define AC_ELD          0x000010  /*!< AAC-ELD */
+#define AC_LD           0x000020  /*!< AAC-LD */
+#define AC_ER           0x000040  /*!< ER syntax */
+#define AC_BSAC         0x000080  /*!< BSAC */
+#define AC_USAC         0x000100  /*!< USAC */
+#define AC_USAC_TW      0x000200  /*!< USAC time warped filter bank is active */
+#define AC_USAC_NOISE   0x000400  /*!< USAC noise filling is active */
+#define AC_USAC_HBE     0x000800  /*!< USAC harmonic bandwidth extension is active */
+#define AC_RSVD50       0x001000  /*!< Rsvd50 */
+#define AC_SBR_PRESENT  0x002000  /*!< SBR present flag (from ASC)             */
+#define AC_SBRCRC       0x004000  /*!< SBR CRC present flag. Only relevant for AAC-ELD for now. */
+#define AC_PS_PRESENT   0x008000  /*!< PS present flag (from ASC or implicit)  */
+#define AC_MPS_PRESENT  0x010000  /*!< MPS present flag (from ASC or implicit) */
+#define AC_DRM          0x020000  /*!< DRM bit stream syntax */
+#define AC_INDEP        0x040000  /*!< Independency flag */
+#define AC_MPS_RES      0x080000  /*!< MPS residual individual channel data. */
+#define AC_DAB          0x800000  /*!< DAB bit stream syntax */
+#define AC_LD_MPS     0x01000000  /*!< Low Delay MPS. */
+
+
+/* CODER_CONFIG::flags */
+#define CC_MPEG_ID         0x00100000
+#define CC_IS_BASELAYER    0x00200000
+#define CC_PROTECTION      0x00400000
+#define CC_SBR             0x00800000
+#define CC_SBRCRC          0x00010000
+#define CC_RVLC            0x01000000
+#define CC_VCB11           0x02000000
+#define CC_HCR             0x04000000
+#define CC_PSEUDO_SURROUND 0x08000000
+#define CC_USAC_NOISE      0x10000000
+#define CC_USAC_TW         0x20000000
+#define CC_USAC_HBE        0x40000000
+
+/** Generic audio coder configuration structure. */
+typedef struct {
+  AUDIO_OBJECT_TYPE aot;         /**< Audio Object Type (AOT).           */
+  AUDIO_OBJECT_TYPE extAOT;      /**< Extension Audio Object Type (SBR). */
+  CHANNEL_MODE channelMode;      /**< Channel mode.                      */
+  INT        samplingRate;       /**< Sampling rate.                     */
+  INT        extSamplingRate;    /**< Extended samplerate (SBR).         */
+  INT        bitRate;            /**< Average bitrate.                   */
+  int        samplesPerFrame;    /**< Number of PCM samples per codec frame and audio channel. */
+  int        noChannels;         /**< Number of audio channels.          */
+  int        bitsFrame;
+  int        nSubFrames;         /**< Amount of encoder subframes. 1 means no subframing.                                     */
+  int        BSACnumOfSubFrame;  /**< The number of the sub-frames which are grouped and transmitted in a super-frame (BSAC). */
+  int        BSAClayerLength;    /**< The average length of the large-step layers in bytes (BSAC).                            */
+  UINT       flags;              /**< flags */
+  UCHAR      matrixMixdownA;     /**< Matrix mixdown index to put into PCE. Default value 0 means no mixdown coefficient,
+                                      valid values are 1-4 which correspond to matrix_mixdown_idx 0-3. */
+  UCHAR      headerPeriod;       /**< Frame period for sending in band configuration buffers in the transport layer. */
+
+  UCHAR      stereoConfigIndex; /**< USAC MPS stereo mode */
+  UCHAR      sbrMode;           /**< USAC SBR mode */
+  SBR_PS_SIGNALING sbrSignaling;/**< 0: implicit signaling, 1: backwards compatible explicit signaling, 2: hierarcical explicit signaling */
+
+  UCHAR      sbrPresent;
+  UCHAR      psPresent;
+} CODER_CONFIG;
+
+/** MP4 Element IDs. */
+typedef enum
+{
+  ID_NONE = -1,   /**< Invalid Element helper ID.             */
+  ID_SCE = 0,     /**< Single Channel Element.                */
+  ID_CPE = 1,     /**< Channel Pair Element.                  */
+  ID_CCE = 2,     /**< Coupling Channel Element.              */
+  ID_LFE = 3,     /**< LFE Channel Element.                   */
+  ID_DSE = 4,     /**< Currently one Data Stream Element for ancillary data is supported. */
+  ID_PCE = 5,     /**< Program Config Element.                */
+  ID_FIL = 6,     /**< Fill Element.                          */
+  ID_END = 7,     /**< Arnie (End Element = Terminator).      */
+  ID_EXT = 8,     /**< Extension Payload (ER only).           */
+  ID_SCAL = 9,    /**< AAC scalable element (ER only).        */
+  ID_LAST
+} MP4_ELEMENT_ID;
+
+#define IS_CHANNEL_ELEMENT(elementId) \
+  ((elementId) == ID_SCE \
+|| (elementId) == ID_CPE \
+|| (elementId) == ID_LFE)
+
+#define EXT_ID_BITS 4  /**< Size in bits of extension payload type tags. */
+
+/** Extension payload types. */
+typedef enum {
+  EXT_FIL           = 0x00,
+  EXT_FILL_DATA     = 0x01,
+  EXT_DATA_ELEMENT  = 0x02,
+  EXT_DATA_LENGTH   = 0x03,
+  EXT_LDSAC_DATA    = 0x09,
+  EXT_SAOC_DATA     = 0x0a,
+  EXT_DYNAMIC_RANGE = 0x0b,
+  EXT_SAC_DATA      = 0x0c,
+  EXT_SBR_DATA      = 0x0d,
+  EXT_SBR_DATA_CRC  = 0x0e
+} EXT_PAYLOAD_TYPE;
+
+
+/**
+ * Proprietary raw packet file configuration data type identifier.
+ */
+typedef enum
+{
+  TC_NOTHING = 0,     /* No configuration available -> in-band configuration.   */
+  TC_RAW_ASC,         /* Configuration data field is a raw AudioSpecificConfig. */
+  TC_RAW_SMC,         /* Configuration data field is a raw StreamMuxConfig.     */
+  TC_RAW_SDC          /* Configuration data field is a raw Drm SDC.             */
+
+} TP_CONFIG_TYPE;
+
+/*
+ * ##############################################################################################
+ * Library identification and error handling
+ * ##############################################################################################
+ */
+/* \cond */
+#define MODULE_ID_MASK  (0x000000ff)
+#define MODULE_ID_SHIFT (24)
+
+typedef enum {
+  FDK_NONE   = 0,
+  FDK_TOOLS  = 1,
+  FDK_SYSLIB = 2,
+  FDK_AACDEC = 3,
+  FDK_AACENC = 4,
+  FDK_SBRDEC = 5,
+  FDK_SBRENC = 6,
+  FDK_TPDEC  = 7,
+  FDK_TPENC  = 8,
+  FDK_MPSDEC = 9,
+  FDK_MPEGFILEREAD  = 10,
+  FDK_MPEGFILEWRITE = 11,
+  FDK_MP2DEC = 12,
+  FDK_DABDEC = 13,
+  FDK_DABPARSE = 14,
+  FDK_DRMDEC = 15,
+  FDK_DRMPARSE = 16,
+  FDK_AACLDENC = 17,
+  FDK_MP2ENC = 18,
+  FDK_MP3ENC = 19,
+  FDK_MP3DEC = 20,
+  FDK_MP3HEADPHONE = 21,
+  FDK_MP3SDEC = 22,
+  FDK_MP3SENC = 23,
+  FDK_EAEC    = 24,
+  FDK_DABENC  = 25,
+  FDK_DMBDEC  = 26,
+  FDK_FDREVERB = 27,
+  FDK_DRMENC  = 28,
+  FDK_METADATATRANSCODER = 29,
+  FDK_AC3DEC = 30,
+  FDK_PCMDMX = 31,
+
+  FDK_MODULE_LAST
+
+} FDK_MODULE_ID;
+
+/* AAC capability flags */
+#define CAPF_AAC_LC           0x00000001  /**< Support flag for AAC Low Complexity.                             */
+#define CAPF_ER_AAC_LD        0x00000002  /**< Support flag for AAC Low Delay with Error Resilience tools.      */
+#define CAPF_ER_AAC_SCAL      0x00000004  /**< Support flag for AAC Scalable.                                   */
+#define CAPF_ER_AAC_LC        0x00000008  /**< Support flag for AAC Low Complexity with Error Resilience tools. */
+#define CAPF_AAC_480          0x00000010  /**< Support flag for AAC with 480 framelength.  */
+#define CAPF_AAC_512          0x00000020  /**< Support flag for AAC with 512 framelength.  */
+#define CAPF_AAC_960          0x00000040  /**< Support flag for AAC with 960 framelength.  */
+#define CAPF_AAC_1024         0x00000080  /**< Support flag for AAC with 1024 framelength. */
+#define CAPF_AAC_HCR          0x00000100  /**< Support flag for AAC with Huffman Codeword Reordering.    */
+#define CAPF_AAC_VCB11        0x00000200  /**< Support flag for AAC Virtual Codebook 11.    */
+#define CAPF_AAC_RVLC         0x00000400  /**< Support flag for AAC Reversible Variable Length Coding.   */
+#define CAPF_AAC_MPEG4        0x00000800  /**< Support flag for MPEG file format.                           */
+#define CAPF_AAC_DRC          0x00001000  /**< Support flag for AAC Dynamic Range Control. */
+#define CAPF_AAC_CONCEALMENT  0x00002000  /**< Support flag for AAC concealment.           */
+#define CAPF_AAC_DRM_BSFORMAT 0x00004000  /**< Support flag for AAC DRM bistream format.                         */
+#define CAPF_ER_AAC_ELD       0x00008000  /**< Support flag for AAC Enhanced Low Delay with Error Resilience tools.  */
+#define CAPF_ER_AAC_BSAC      0x00010000  /**< Support flag for AAC BSAC.                           */
+#define CAPF_AAC_SUPERFRAMING 0x00020000  /**< Support flag for AAC Superframing.                           */
+
+/* Transport capability flags */
+#define CAPF_ADTS             0x00000001  /**< Support flag for ADTS transport format.        */
+#define CAPF_ADIF             0x00000002  /**< Support flag for ADIF transport format.        */
+#define CAPF_LATM             0x00000004  /**< Support flag for LATM transport format.        */
+#define CAPF_LOAS             0x00000008  /**< Support flag for LOAS transport format.        */
+#define CAPF_RAWPACKETS       0x00000010  /**< Support flag for RAW PACKETS transport format. */
+#define CAPF_DRM              0x00000020  /**< Support flag for DRM/DRM+ transport format.    */
+#define CAPF_RSVD50           0x00000040  /**< Support flag for RSVD50 transport format       */
+
+/* SBR capability flags */
+#define CAPF_SBR_LP           0x00000001  /**< Support flag for SBR Low Power mode.           */
+#define CAPF_SBR_HQ           0x00000002  /**< Support flag for SBR High Quality mode.        */
+#define CAPF_SBR_DRM_BS       0x00000004  /**< Support flag for                               */
+#define CAPF_SBR_CONCEALMENT  0x00000008  /**< Support flag for SBR concealment.              */
+#define CAPF_SBR_DRC          0x00000010  /**< Support flag for SBR Dynamic Range Control.    */
+#define CAPF_SBR_PS_MPEG      0x00000020  /**< Support flag for MPEG Parametric Stereo.       */
+#define CAPF_SBR_PS_DRM       0x00000040  /**< Support flag for DRM Parametric Stereo.        */
+
+/* MP2 encoder capability flags */
+#define CAPF_MP2ENC_SS        0x00000001  /**< Support flag for Seamless Switching.           */
+#define CAPF_MP2ENC_DAB       0x00000002  /**< Support flag for Layer2 DAB.                   */
+
+/* DAB capability flags */
+#define CAPF_DAB_MP2          0x00000001  /**< Support flag for Layer2 DAB.                   */
+#define CAPF_DAB_AAC          0x00000002  /**< Support flag for DAB+ (HE-AAC v2).             */
+#define CAPF_DAB_PAD          0x00000004  /**< Support flag for PAD extraction.               */
+#define CAPF_DAB_DRC          0x00000008  /**< Support flag for Dynamic Range Control.        */
+#define CAPF_DAB_SURROUND     0x00000010  /**< Support flag for DAB Surround (MPS).           */
+
+/* DMB capability flags */
+#define CAPF_DMB_BSAC         0x00000001  /**< Support flag for ER AAC BSAC.                  */
+#define CAPF_DMB_DRC          0x00000008  /**< Support flag for Dynamic Range Control.        */
+#define CAPF_DMB_SURROUND     0x00000010  /**< Support flag for DMB Surround (MPS).           */
+
+/* PCM up/downmmix capability flags */
+#define CAPF_DMX_BLIND        0x00000001  /**< Support flag for blind downmixing.             */
+#define CAPF_DMX_PCE          0x00000002  /**< Support flag for guided downmix with data from MPEG-2/4 Program Config Elements (PCE). */
+#define CAPF_DMX_ARIB         0x00000004  /**< Support flag for PCE guided downmix with slightly different equations and levels to fulfill ARIB standard. */
+#define CAPF_DMX_DVB          0x00000008  /**< Support flag for guided downmix with data from DVB ancillary data fields. */
+#define CAPF_DMX_CH_EXP       0x00000010  /**< Support flag for simple upmixing by dublicating channels or adding zero channels. */
+/* \endcond */
+
+
+/*
+ * ##############################################################################################
+ * Library versioning
+ * ##############################################################################################
+ */
+
+/**
+ * Convert each member of version numbers to one single numeric version representation.
+ * \param lev0  1st level of version number.
+ * \param lev1  2nd level of version number.
+ * \param lev2  3rd level of version number.
+  */
+#define LIB_VERSION(lev0, lev1, lev2) ((lev0<<24 & 0xff000000) | \
+                                       (lev1<<16 & 0x00ff0000) | \
+                                       (lev2<<8  & 0x0000ff00))
+
+/**
+ *  Build text string of version.
+ */
+#define LIB_VERSION_STRING(info) FDKsprintf((info)->versionStr, "%d.%d.%d", (((info)->version >> 24) & 0xff), (((info)->version >> 16) & 0xff), (((info)->version >> 8 ) & 0xff))
+
+/**
+ *  Library information.
+ */
+typedef struct LIB_INFO
+{
+  const char* title;
+  const char* build_date;
+  const char* build_time;
+  FDK_MODULE_ID module_id;
+  INT version;
+  UINT  flags;
+  char versionStr[32];
+} LIB_INFO;
+
+/** Initialize library info. */
+static inline void FDKinitLibInfo( LIB_INFO* info )
+{
+  int i;
+
+  for (i = 0; i < FDK_MODULE_LAST; i++) {
+    info[i].module_id = FDK_NONE;
+  }
+}
+
+/** Aquire supported features of library. */
+static inline UINT FDKlibInfo_getCapabilities( const LIB_INFO* info, FDK_MODULE_ID module_id )
+{
+  int i;
+
+  for (i=0; i<FDK_MODULE_LAST; i++) {
+    if (info[i].module_id == module_id) {
+      return info[i].flags;
+    }
+  }
+  return 0;
+}
+
+/** Search for next free tab. */
+static inline INT FDKlibInfo_lookup( const LIB_INFO* info, FDK_MODULE_ID module_id )
+{
+  int i = -1;
+
+  for (i = 0; i < FDK_MODULE_LAST; i++) {
+    if (info[i].module_id == module_id)
+      return -1;
+    if (info[i].module_id == FDK_NONE)
+      break;
+  }
+  if (i == FDK_MODULE_LAST)
+    return -1;
+
+  return i;
+}
+
+
+/*
+ * ##############################################################################################
+ * Buffer description
+ * ##############################################################################################
+ */
+
+/**
+ *  I/O buffer descriptor.
+ */
+typedef struct FDK_bufDescr
+{
+  void  **ppBase;     /*!< Pointer to an array containing buffer base addresses.
+                           Set to NULL for buffer requirement info. */
+  UINT   *pBufSize;   /*!< Pointer to an array containing the number of elements that can
+                           be placed in the specific buffer. */
+  UINT   *pEleSize;   /*!< Pointer to an array containing the element size for each buffer
+                           in bytes. That is mostly the number returned by the sizeof()
+                           operator for the data type used for the specific buffer. */
+  UINT   *pBufType;   /*!< Pointer to an array of bit fields containing a description
+                           for each buffer. See XXX below for more details.  */
+  UINT    numBufs;    /*!< Total number of buffers. */
+
+} FDK_bufDescr;
+
+/**
+ * Buffer type description field.
+ */
+#define FDK_BUF_TYPE_MASK_IO     ( 0x03 << 30 )
+#define FDK_BUF_TYPE_MASK_DESCR  ( 0x3F << 16 )
+#define FDK_BUF_TYPE_MASK_ID     ( 0xFF )
+
+#define FDK_BUF_TYPE_INPUT       ( 0x1 << 30 )
+#define FDK_BUF_TYPE_OUTPUT      ( 0x2 << 30 )
+
+#define FDK_BUF_TYPE_PCM_DATA    ( 0x1 << 16 )
+#define FDK_BUF_TYPE_ANC_DATA    ( 0x2 << 16 )
+#define FDK_BUF_TYPE_BS_DATA     ( 0x4 << 16 )
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FDK_AUDIO_H */
--- ffmpeg-2.5/localinc/fdk-aac/genericStds.h.dl_headers~	2014-12-04 22:53:11.253165674 +0100
+++ ffmpeg-2.5/localinc/fdk-aac/genericStds.h	2014-12-04 22:53:11.253165674 +0100
@@ -0,0 +1,480 @@
+
+/* -----------------------------------------------------------------------------------------------------------
+Software License for The Fraunhofer FDK AAC Codec Library for Android
+
+© Copyright  1995 - 2013 Fraunhofer-Gesellschaft zur Förderung der angewandten Forschung e.V.
+  All rights reserved.
+
+ 1.    INTRODUCTION
+The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software that implements
+the MPEG Advanced Audio Coding ("AAC") encoding and decoding scheme for digital audio.
+This FDK AAC Codec software is intended to be used on a wide variety of Android devices.
+
+AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient general perceptual
+audio codecs. AAC-ELD is considered the best-performing full-bandwidth communications codec by
+independent studies and is widely deployed. AAC has been standardized by ISO and IEC as part
+of the MPEG specifications.
+
+Patent licenses for necessary patent claims for the FDK AAC Codec (including those of Fraunhofer)
+may be obtained through Via Licensing (www.vialicensing.com) or through the respective patent owners
+individually for the purpose of encoding or decoding bit streams in products that are compliant with
+the ISO/IEC MPEG audio standards. Please note that most manufacturers of Android devices already license
+these patent claims through Via Licensing or directly from the patent owners, and therefore FDK AAC Codec
+software may already be covered under those patent licenses when it is used for those licensed purposes only.
+
+Commercially-licensed AAC software libraries, including floating-point versions with enhanced sound quality,
+are also available from Fraunhofer. Users are encouraged to check the Fraunhofer website for additional
+applications information and documentation.
+
+2.    COPYRIGHT LICENSE
+
+Redistribution and use in source and binary forms, with or without modification, are permitted without
+payment of copyright license fees provided that you satisfy the following conditions:
+
+You must retain the complete text of this software license in redistributions of the FDK AAC Codec or
+your modifications thereto in source code form.
+
+You must retain the complete text of this software license in the documentation and/or other materials
+provided with redistributions of the FDK AAC Codec or your modifications thereto in binary form.
+You must make available free of charge copies of the complete source code of the FDK AAC Codec and your
+modifications thereto to recipients of copies in binary form.
+
+The name of Fraunhofer may not be used to endorse or promote products derived from this library without
+prior written permission.
+
+You may not charge copyright license fees for anyone to use, copy or distribute the FDK AAC Codec
+software or your modifications thereto.
+
+Your modified versions of the FDK AAC Codec must carry prominent notices stating that you changed the software
+and the date of any change. For modified versions of the FDK AAC Codec, the term
+"Fraunhofer FDK AAC Codec Library for Android" must be replaced by the term
+"Third-Party Modified Version of the Fraunhofer FDK AAC Codec Library for Android."
+
+3.    NO PATENT LICENSE
+
+NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without limitation the patents of Fraunhofer,
+ARE GRANTED BY THIS SOFTWARE LICENSE. Fraunhofer provides no warranty of patent non-infringement with
+respect to this software.
+
+You may use this FDK AAC Codec software or modifications thereto only for purposes that are authorized
+by appropriate patent licenses.
+
+4.    DISCLAIMER
+
+This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright holders and contributors
+"AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, including but not limited to the implied warranties
+of merchantability and fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary, or consequential damages,
+including but not limited to procurement of substitute goods or services; loss of use, data, or profits,
+or business interruption, however caused and on any theory of liability, whether in contract, strict
+liability, or tort (including negligence), arising in any way out of the use of this software, even if
+advised of the possibility of such damage.
+
+5.    CONTACT INFORMATION
+
+Fraunhofer Institute for Integrated Circuits IIS
+Attention: Audio and Multimedia Departments - FDK AAC LL
+Am Wolfsmantel 33
+91058 Erlangen, Germany
+
+www.iis.fraunhofer.de/amm
+amm-info@iis.fraunhofer.de
+----------------------------------------------------------------------------------------------------------- */
+
+/**************************  Fraunhofer IIS FDK SysLib  **********************
+
+   Author(s):
+
+******************************************************************************/
+
+/** \file   genericStds.h
+    \brief  Generic Run-Time Support function wrappers and heap allocation monitoring.
+ */
+
+#if !defined(__GENERICSTDS_H__)
+#define __GENERICSTDS_H__
+
+#include "machine_type.h"
+
+
+/* Always increase verbosity of memory allocation in case of a debug built. DEBUG is defined globally in that case. */
+#if defined(DEBUG) || defined(FDK_DEBUG)
+//#define MEMORY_MEASUREMENT
+#endif
+
+#ifndef M_PI
+  #define M_PI   3.14159265358979323846  /*! Pi. Only used in example projects. */
+#endif
+
+
+/* #define _CRT_SECURE_NO_DEPRECATE */
+
+
+/**
+ * Identifiers for various memory locations. They are used along with memory allocation
+ * functions like FDKcalloc_L() to specify the requested memory's location.
+ */
+typedef enum {
+  /* Internal */
+  SECT_DATA_L1 = 0x2000,
+  SECT_DATA_L2,
+  SECT_DATA_L1_A,
+  SECT_DATA_L1_B,
+  SECT_CONSTDATA_L1,
+
+  /* External */
+  SECT_DATA_EXTERN = 0x4000,
+  SECT_CONSTDATA_EXTERN
+
+} MEMORY_SECTION;
+
+
+/**
+ * The H_ prefix indicates header file version, the C_* prefix indicates the corresponding
+ * object version.
+ *
+ * Declaring memory areas requires to specify a unique name and a data type. Use the H_ macro
+ * for this purpose inside a header file.
+ *
+ * For defining a memory area your require additionally one or two sizes, depending if the
+ * memory should be organized into one or two dimensions.
+ *
+ * The macros containing the keyword AALLOC instead of ALLOC also do take care of returning
+ * aligned memory addresses (beyond the natural alignment of its type). The preprocesor macro
+ * ::ALIGNMENT_DEFAULT indicates the aligment to be used (this is hardware specific).
+ *
+ * The _L suffix indicates that the memory will be located in a specific section. This is
+ * useful to allocate critical memory section into fast internal SRAM for example.
+ *
+ */
+
+#define H_ALLOC_MEM(name,type)          type * Get ## name(int n=0); void Free ## name(type** p); \
+                                        UINT GetRequiredMem ## name(void);
+
+/** See #H_ALLOC_MEM for description. */
+#define H_ALLOC_MEM_OVERLAY(name,type)  type * Get ## name(int n=0); void Free ## name(type** p); \
+                                        UINT GetRequiredMem ## name(void);
+
+
+  /** See #H_ALLOC_MEM for description. */
+  #define C_ALLOC_MEM(name,type,num) \
+    type * Get ## name(int n) { FDK_ASSERT((n) == 0); return ((type*)FDKcalloc(num, sizeof(type))); } \
+    void Free ## name(type** p) { if (p != NULL) { FDKfree(*p); *p=NULL; } } \
+    UINT GetRequiredMem ## name(void) { return ALGN_SIZE_EXTRES((num) * sizeof(type)); }
+
+  /** See #H_ALLOC_MEM for description. */
+  #define C_ALLOC_MEM_STATIC(name,type,num) \
+    static type * Get ## name(int n) { FDK_ASSERT((n) == 0); return ((type*)FDKcalloc(num, sizeof(type))); } \
+    static void Free ## name(type** p) { if (p != NULL) { FDKfree(*p); *p=NULL; } } \
+    static UINT GetRequiredMem ## name(void) { return ALGN_SIZE_EXTRES((num) * sizeof(type)); }
+
+  /** See #H_ALLOC_MEM for description. */
+  #define C_ALLOC_MEM2(name,type,n1,n2) \
+    type * Get ## name (int n) { FDK_ASSERT((n) < (n2)); return ((type*)FDKcalloc(n1, sizeof(type))); } \
+    void Free ## name(type** p) { if (p != NULL) { FDKfree(*p); *p=NULL; } } \
+    UINT GetRequiredMem ## name(void) { return ALGN_SIZE_EXTRES((n1) * sizeof(type)) * (n2); }
+
+  /** See #H_ALLOC_MEM for description. */
+  #define C_AALLOC_MEM(name,type,num) \
+    type * Get ## name(int n) { FDK_ASSERT((n) == 0); return ((type*)FDKaalloc((num)*sizeof(type), ALIGNMENT_DEFAULT)); } \
+    void Free ## name(type** p) { if (p != NULL) { FDKafree(*p); *p=NULL; } } \
+    UINT GetRequiredMem ## name(void) { return ALGN_SIZE_EXTRES((num) * sizeof(type) + ALIGNMENT_DEFAULT + sizeof(void *)); }
+
+  /** See #H_ALLOC_MEM for description. */
+  #define C_AALLOC_MEM2(name,type,n1,n2) \
+    type * Get ## name (int n) { FDK_ASSERT((n) < (n2)); return ((type*)FDKaalloc((n1)*sizeof(type), ALIGNMENT_DEFAULT)); } \
+    void Free ## name(type** p) { if (p != NULL) { FDKafree(*p); *p=NULL; } } \
+    UINT GetRequiredMem ## name(void) { return ALGN_SIZE_EXTRES((n1) * sizeof(type) + ALIGNMENT_DEFAULT + sizeof(void *)) * (n2); }
+
+  /** See #H_ALLOC_MEM for description. */
+  #define C_ALLOC_MEM_L(name,type,num,s) \
+    type * Get ## name(int n) { FDK_ASSERT((n) == 0); return ((type*)FDKcalloc_L(num, sizeof(type), s)); } \
+    void Free ## name(type** p) { if (p != NULL) { FDKfree_L(*p); *p=NULL; } } \
+    UINT GetRequiredMem ## name(void) { return ALGN_SIZE_EXTRES((num) * sizeof(type)); }
+
+  /** See #H_ALLOC_MEM for description. */
+  #define C_ALLOC_MEM2_L(name,type,n1,n2,s) \
+    type * Get ## name (int n) { FDK_ASSERT((n) < (n2)); return (type*)FDKcalloc_L(n1, sizeof(type), s); } \
+    void Free ## name(type** p) { if (p != NULL) { FDKfree_L(*p); *p=NULL; } } \
+    UINT GetRequiredMem ## name(void) { return ALGN_SIZE_EXTRES((n1) * sizeof(type)) * (n2); }
+
+  /** See #H_ALLOC_MEM for description. */
+  #define C_AALLOC_MEM_L(name,type,num,s) \
+    type * Get ## name(int n) { FDK_ASSERT((n) == 0); return ((type*)FDKaalloc_L((num)*sizeof(type), ALIGNMENT_DEFAULT, s)); } \
+    void Free ## name(type** p) { if (p != NULL) { FDKafree_L(*p); *p=NULL; } } \
+    UINT GetRequiredMem ## name(void) { return ALGN_SIZE_EXTRES((num) * sizeof(type) + ALIGNMENT_DEFAULT + sizeof(void *)); }
+
+  /** See #H_ALLOC_MEM for description. */
+  #define C_AALLOC_MEM2_L(name,type,n1,n2,s) \
+    type * Get ## name (int n) { FDK_ASSERT((n) < (n2)); return ((type*)FDKaalloc_L((n1)*sizeof(type), ALIGNMENT_DEFAULT, s)); } \
+    void Free ## name(type** p) { if (p != NULL) { FDKafree_L(*p); *p=NULL; } } \
+    UINT GetRequiredMem ## name(void) { return ALGN_SIZE_EXTRES((n1) * sizeof(type) + ALIGNMENT_DEFAULT + sizeof(void *)) * (n2); }
+
+/** See #H_ALLOC_MEM_OVERLAY for description. */
+
+
+  #define C_ALLOC_MEM_OVERLAY(name,type,num,sect,tag) C_AALLOC_MEM_L(name,type,num,sect)
+
+
+   #define C_AALLOC_SCRATCH_START(name,type,n) \
+     type _ ## name[(n)+(ALIGNMENT_DEFAULT+sizeof(type)-1)]; \
+     type * name = (type*)ALIGN_PTR(_ ## name); \
+
+   #define C_ALLOC_SCRATCH_START(name,type,n) \
+     type name[n];
+
+   #define C_AALLOC_SCRATCH_END(name,type,n)
+   #define C_ALLOC_SCRATCH_END(name,type,n)
+
+
+/*--------------------------------------------
+ * Runtime support declarations
+ *---------------------------------------------*/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** printf() using stdout. If ::ARCH_WA_FLUSH_CONSOLE defined, a flush is  done additionally after printf(). */
+void FDKprintf    ( const char* szFmt, ...);
+
+/** printf() using stderr. If ::ARCH_WA_FLUSH_CONSOLE defined, a flush is done additionally after printf(). */
+void FDKprintfErr ( const char* szFmt, ...);
+
+/** Wrapper for <stdio.h>'s getchar(). */
+int FDKgetchar(void);
+
+INT  FDKfprintf(void  *stream,  const  char *format, ...);
+INT  FDKsprintf(char *str, const char *format, ...);
+
+
+
+const char *FDKstrchr(const char *s, INT c);
+const char *FDKstrstr(const char *haystack, const char *needle);
+char *FDKstrcpy(char *dest, const char *src);
+char *FDKstrncpy(char *dest, const char *src, const UINT n);
+
+#define FDK_MAX_OVERLAYS 8   /**< Maximum number of memory overlays. */
+
+
+void *FDKcalloc (const UINT n, const UINT size);
+void *FDKmalloc (const UINT size);
+void  FDKfree   (void *ptr);
+
+/**
+ *  Allocate and clear an aligned memory area. Use FDKafree() instead of FDKfree() for these memory areas.
+ *
+ * \param size       Size of requested memory in bytes.
+ * \param alignment  Alignment of requested memory in bytes.
+ * \return           Pointer to allocated memory.
+ */
+void *FDKaalloc (const UINT size, const UINT alignment);
+
+/**
+ *  Free an aligned memory area.
+ *
+ * \param ptr  Pointer to be freed.
+ * \return     void
+ */
+void FDKafree (void *ptr);
+
+
+/**
+ *  Allocate memory in a specific memory section.
+ *  Requests can be made for internal or external memory. If internal memory is
+ *  requested, FDKcalloc_L() first tries to use L1 memory, which sizes are defined
+ *  by ::DATA_L1_A_SIZE and ::DATA_L1_B_SIZE. If no L1 memory is available, then
+ *  FDKcalloc_L() tries to use L2 memory. If that fails as well, the requested
+ *  memory is allocated at an extern location using the fallback FDKcalloc().
+ *
+ * \param n     See MSDN documentation on calloc().
+ * \param size  See MSDN documentation on calloc().
+ * \param s     Memory section.
+ * \return      See MSDN documentation on calloc().
+ */
+void *FDKcalloc_L(const UINT n, const UINT size, MEMORY_SECTION s);
+
+/**
+ *  Allocate aligned memory in a specific memory section.
+ *  See FDKcalloc_L() description for details - same applies here.
+ */
+void *FDKaalloc_L(const UINT size, const UINT alignment, MEMORY_SECTION s);
+
+/**
+ *  Free memory that was allocated in a specific memory section.
+ */
+void  FDKfree_L(void *ptr);
+
+/**
+ *  Free aligned memory that was allocated in a specific memory section.
+ */
+void  FDKafree_L(void *ptr);
+
+
+/**
+ * Copy memory. Source and destination memory must not overlap.
+ * Either use implementation from a Standard Library, or, if no Standard Library
+ * is available, a generic implementation.
+ * The define ::USE_BUILTIN_MEM_FUNCTIONS in genericStds.cpp controls what to use.
+ * The function arguments correspond to the standard memcpy(). Please see MSDN
+ * documentation for details on how to use it.
+ */
+void FDKmemcpy(void *dst, const void *src, const UINT size);
+
+/**
+ * Copy memory. Source and destination memory are allowed to overlap.
+ * Either use implementation from a Standard Library, or, if no Standard Library
+ * is available, a generic implementation.
+ * The define ::USE_BUILTIN_MEM_FUNCTIONS in genericStds.cpp controls what to use.
+ * The function arguments correspond to the standard memmove(). Please see MSDN
+ * documentation for details on how to use it.
+*/
+void FDKmemmove(void *dst, const void *src, const UINT size);
+
+/**
+ * Clear memory.
+ * Either use implementation from a Standard Library, or, if no Standard Library
+ * is available, a generic implementation.
+ * The define ::USE_BUILTIN_MEM_FUNCTIONS in genericStds.cpp controls what to use.
+ * The function arguments correspond to the standard memclear(). Please see MSDN
+ * documentation for details on how to use it.
+*/
+void FDKmemclear(void *memPtr, const UINT size);
+
+/**
+ * Fill memory with values.
+ * The function arguments correspond to the standard memset(). Please see MSDN
+ * documentation for details on how to use it.
+ */
+void FDKmemset(void *memPtr, const INT value, const UINT size);
+
+/* Compare function wrappers */
+INT   FDKmemcmp(const void *s1, const void *s2, const UINT size);
+INT   FDKstrcmp(const char *s1, const char *s2);
+INT   FDKstrncmp(const char *s1, const char *s2, const UINT size);
+
+UINT  FDKstrlen(const char *s);
+
+#define FDKmax(a,b) ( (a) > (b) ? (a):(b))
+#define FDKmin(a,b) ( (a) < (b) ? (a):(b))
+
+#define FDK_INT_MAX ((INT)0x7FFFFFFF)
+#define FDK_INT_MIN ((INT)0x80000000)
+
+/* Math function wrappers. Only intended for compatibility, not to be highly optimized. */
+/* Used for debugging, dev code .. */
+
+INT FDKabs(INT j);
+double FDKfabs(double x);
+double FDKpow(double x, double y);
+double FDKsqrt(double x);
+double FDKatan(double x);
+double FDKlog(double x);
+double FDKsin(double x);
+double FDKcos(double x);
+double FDKexp(double x);
+#define FDKlog2(a) (FDKlog(a)*1.442695041) /* log(2.0) = 1.442695041 */
+#define FDKlog10(a) (FDKlog(a)*0.434294482) /* 1.0/log(10.0) = 0.434294482 */
+double FDKatan2(double y, double x);
+double FDKacos(double x);
+double FDKtan(double x);
+double FDKfloor(double x);
+double FDKceil(double x);
+INT   FDKatoi(const char *nptr);
+long  FDKatol(const char *nptr);
+float FDKatof(const char *nptr);
+/* LONG LONG FDKatoll(const char *nptr); */
+/* LONG LONG FDKatoq(const char *nptr); */
+
+
+
+/* FILE I/O */
+
+/*!
+ *  Check platform for endianess.
+ *
+ * \return  1 if platform is little endian, non-1 if platform is big endian.
+ */
+#ifdef __cplusplus
+inline
+#else
+static
+#endif
+int IS_LITTLE_ENDIAN(void) {
+  int __dummy = 1;
+  return ( *( (UCHAR*)(&(__dummy) ) ) );
+}
+
+/*!
+ *  Convert input value to little endian format.
+ *
+ * \param val  Value to be converted. It may be in both big or little endian.
+ * \return     Value in little endian format.
+ */
+#define TO_LITTLE_ENDIAN(val) \
+  ( (IS_LITTLE_ENDIAN()) ? \
+     (val) \
+   : ( (((val) & 0xff) << 24) || (((val) & 0xff00)<< 8) || (((val) & 0xff0000)>>8) || (((val) & 0xff000000) >> 24) ) )
+
+
+/*!
+ * \fn     FDKFILE *FDKfopen(const char *filename, const char *mode);
+ *         Standard fopen() wrapper.
+ * \fn     INT FDKfclose(FDKFILE *FP);
+ *         Standard fclose() wrapper.
+ * \fn     INT FDKfseek(FDKFILE *FP, LONG OFFSET, int WHENCE);
+ *         Standard fseek() wrapper.
+ * \fn     INT FDKftell(FDKFILE *FP);
+ *         Standard ftell() wrapper.
+ * \fn     INT FDKfflush(FDKFILE *fp);
+ *         Standard fflush() wrapper.
+ * \fn     UINT FDKfwrite(void *ptrf, INT size, UINT nmemb, FDKFILE *fp);
+ *         Standard fwrite() wrapper.
+ * \fn     UINT FDKfread(void *dst, INT size, UINT nmemb, FDKFILE *fp);
+ *         Standard fread() wrapper.
+ */
+typedef void FDKFILE;
+extern const INT FDKSEEK_SET, FDKSEEK_CUR, FDKSEEK_END;
+
+FDKFILE *FDKfopen(const char *filename, const char *mode);
+INT FDKfclose(FDKFILE *FP);
+INT FDKfseek(FDKFILE *FP, LONG OFFSET, int WHENCE);
+INT FDKftell(FDKFILE *FP);
+INT FDKfflush(FDKFILE *fp);
+UINT FDKfwrite(void *ptrf, INT size, UINT nmemb, FDKFILE *fp);
+UINT FDKfread(void *dst, INT size, UINT nmemb, FDKFILE *fp);
+char* FDKfgets(void *dst, INT size, FDKFILE *fp);
+void FDKrewind(FDKFILE *fp);
+INT FDKfeof(FDKFILE *fp);
+
+/**
+ * \brief        Write each member in little endian order. Convert automatically to host endianess.
+ * \param ptrf   Pointer to memory where to read data from.
+ * \param size   Size of each item to be written.
+ * \param nmemb  Number of items to be written.
+ * \param fp     File pointer of type FDKFILE.
+ * \return       Number of items read on success and fread() error on failure.
+ */
+UINT FDKfwrite_EL(void *ptrf, INT size, UINT nmemb, FDKFILE *fp);
+
+/**
+ * \brief        Read variable of size "size" as little endian. Convert automatically to host endianess.
+ *                4-byte alignment is enforced for 24 bit data, at 32 bit full scale.
+ * \param dst    Pointer to memory where to store data into.
+ * \param size   Size of each item to be read.
+ * \param nmemb  Number of items to be read.
+ * \param fp     File pointer of type FDKFILE.
+ * \return       Number of items read on success and fread() error on failure.
+ */
+UINT FDKfread_EL(void *dst, INT size, UINT nmemb, FDKFILE *fp);
+
+
+/**
+ * \brief  Print FDK software disclaimer.
+ */
+void FDKprintDisclaimer(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GENERICSTDS_H__ */
--- ffmpeg-2.5/localinc/fdk-aac/machine_type.h.dl_headers~	2014-12-04 22:53:11.253165674 +0100
+++ ffmpeg-2.5/localinc/fdk-aac/machine_type.h	2014-12-04 22:53:11.253165674 +0100
@@ -0,0 +1,357 @@
+
+/* -----------------------------------------------------------------------------------------------------------
+Software License for The Fraunhofer FDK AAC Codec Library for Android
+
+© Copyright  1995 - 2013 Fraunhofer-Gesellschaft zur Förderung der angewandten Forschung e.V.
+  All rights reserved.
+
+ 1.    INTRODUCTION
+The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software that implements
+the MPEG Advanced Audio Coding ("AAC") encoding and decoding scheme for digital audio.
+This FDK AAC Codec software is intended to be used on a wide variety of Android devices.
+
+AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient general perceptual
+audio codecs. AAC-ELD is considered the best-performing full-bandwidth communications codec by
+independent studies and is widely deployed. AAC has been standardized by ISO and IEC as part
+of the MPEG specifications.
+
+Patent licenses for necessary patent claims for the FDK AAC Codec (including those of Fraunhofer)
+may be obtained through Via Licensing (www.vialicensing.com) or through the respective patent owners
+individually for the purpose of encoding or decoding bit streams in products that are compliant with
+the ISO/IEC MPEG audio standards. Please note that most manufacturers of Android devices already license
+these patent claims through Via Licensing or directly from the patent owners, and therefore FDK AAC Codec
+software may already be covered under those patent licenses when it is used for those licensed purposes only.
+
+Commercially-licensed AAC software libraries, including floating-point versions with enhanced sound quality,
+are also available from Fraunhofer. Users are encouraged to check the Fraunhofer website for additional
+applications information and documentation.
+
+2.    COPYRIGHT LICENSE
+
+Redistribution and use in source and binary forms, with or without modification, are permitted without
+payment of copyright license fees provided that you satisfy the following conditions:
+
+You must retain the complete text of this software license in redistributions of the FDK AAC Codec or
+your modifications thereto in source code form.
+
+You must retain the complete text of this software license in the documentation and/or other materials
+provided with redistributions of the FDK AAC Codec or your modifications thereto in binary form.
+You must make available free of charge copies of the complete source code of the FDK AAC Codec and your
+modifications thereto to recipients of copies in binary form.
+
+The name of Fraunhofer may not be used to endorse or promote products derived from this library without
+prior written permission.
+
+You may not charge copyright license fees for anyone to use, copy or distribute the FDK AAC Codec
+software or your modifications thereto.
+
+Your modified versions of the FDK AAC Codec must carry prominent notices stating that you changed the software
+and the date of any change. For modified versions of the FDK AAC Codec, the term
+"Fraunhofer FDK AAC Codec Library for Android" must be replaced by the term
+"Third-Party Modified Version of the Fraunhofer FDK AAC Codec Library for Android."
+
+3.    NO PATENT LICENSE
+
+NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without limitation the patents of Fraunhofer,
+ARE GRANTED BY THIS SOFTWARE LICENSE. Fraunhofer provides no warranty of patent non-infringement with
+respect to this software.
+
+You may use this FDK AAC Codec software or modifications thereto only for purposes that are authorized
+by appropriate patent licenses.
+
+4.    DISCLAIMER
+
+This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright holders and contributors
+"AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, including but not limited to the implied warranties
+of merchantability and fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary, or consequential damages,
+including but not limited to procurement of substitute goods or services; loss of use, data, or profits,
+or business interruption, however caused and on any theory of liability, whether in contract, strict
+liability, or tort (including negligence), arising in any way out of the use of this software, even if
+advised of the possibility of such damage.
+
+5.    CONTACT INFORMATION
+
+Fraunhofer Institute for Integrated Circuits IIS
+Attention: Audio and Multimedia Departments - FDK AAC LL
+Am Wolfsmantel 33
+91058 Erlangen, Germany
+
+www.iis.fraunhofer.de/amm
+amm-info@iis.fraunhofer.de
+----------------------------------------------------------------------------------------------------------- */
+
+/**************************  Fraunhofer IIS FDK SysLib  **********************
+
+   Author(s):
+
+******************************************************************************/
+
+/** \file   machine_type.h
+ *  \brief  Type defines for various processors and compiler tools.
+ */
+
+#if !defined(__MACHINE_TYPE_H__)
+#define __MACHINE_TYPE_H__
+
+
+/* Library calling convention spec. __cdecl and friends might be added here as required. */
+  #define LINKSPEC_H
+  #define LINKSPEC_CPP
+
+
+/**
+ *  collate all corresponding compiler specific macros to detect a debug build, and set the DEBUG macro if that is the case.
+ */
+#if defined(_DEBUG)
+#define DEBUG
+#endif
+
+
+/* for doxygen the following docu parts must be separated */
+/** \var  SCHAR
+ *        Data type representing at least 1 byte signed integer on all supported platforms.
+ */
+/** \var  UCHAR
+ *        Data type representing at least 1 byte unsigned integer on all supported platforms.
+ */
+/** \var  INT
+ *        Data type representing at least 4 byte signed integer on all supported platforms.
+ */
+/** \var  UINT
+ *        Data type representing at least 4 byte unsigned integer on all supported platforms.
+ */
+/** \var  LONG
+ *        Data type representing 4 byte signed integer on all supported platforms.
+ */
+/** \var  ULONG
+ *        Data type representing 4 byte unsigned integer on all supported platforms.
+ */
+/** \var  SHORT
+ *        Data type representing 2 byte signed integer on all supported platforms.
+ */
+/** \var  USHORT
+ *        Data type representing 2 byte unsigned integer on all supported platforms.
+ */
+/** \var  INT64
+ *        Data type representing 8 byte signed integer on all supported platforms.
+ */
+/** \var  UINT64
+ *        Data type representing 8 byte unsigned integer on all supported platforms.
+ */
+/** \def  SHORT_BITS
+ *        Number of bits the data type short represents. sizeof() is not suited to get this info,
+ *        because a byte is not always defined as 8 bits.
+ */
+/** \def  CHAR_BITS
+ *        Number of bits the data type char represents. sizeof() is not suited to get this info,
+ *        because a byte is not always defined as 8 bits.
+ */
+/** \var  INT_PCM
+ *        Data type representing the width of input and output PCM samples.
+ */
+
+
+  typedef signed int INT;
+  typedef unsigned int UINT;
+#ifdef __x86_64__
+  /* force FDK long-datatypes to 4 byte  */
+  /* jdr: Use defines to avoid type alias problems on 64 bit machines. */
+  #define LONG INT
+  #define ULONG UINT
+#else /* __x86_64__ */
+  typedef signed long LONG;
+  typedef unsigned long ULONG;
+#endif	/* __x86_64__ */
+  typedef signed short SHORT;
+  typedef unsigned short USHORT;
+  typedef signed char SCHAR;
+  typedef unsigned char UCHAR;
+
+  #define SHORT_BITS 16
+  #define CHAR_BITS 8
+
+
+/* Define 64 bit base integer type. */
+#ifdef _MSC_VER
+  typedef __int64 INT64;
+  typedef unsigned __int64 UINT64;
+#else
+  typedef long long INT64;
+  typedef unsigned long long UINT64;
+#endif
+
+#ifndef NULL
+  #ifdef __cplusplus
+    #define NULL    0
+  #else
+    #define NULL    ((void *)0)
+  #endif
+#endif
+
+/* Assert is functional on x86 PC's and also when debugging is turned on. */
+#if defined(DEBUG) || defined(__i686__) || defined(__i586__) || defined(__i386__) || defined(__x86_64__) || defined(_M_IX86) || defined(FDK_DEBUG) || defined(FDK_ASSERT_ENABLE)
+  #include <assert.h>
+  #define FDK_ASSERT(x) assert(x)
+#else
+  #define FDK_ASSERT(ignore)
+#endif
+
+  typedef SHORT        INT_PCM;
+  #define WAV_BITS     16
+  #define SAMPLE_BITS  16
+  #define SAMPLE_MAX (((LONG)1<<(SAMPLE_BITS-1))-1)
+  #define SAMPLE_MIN (~SAMPLE_MAX)
+
+/*!
+* \def    RAM_ALIGN
+*  Used to align memory as prefix before memory declaration. For example:
+   \code
+   RAM_ALIGN
+   int myArray[16];
+   \endcode
+
+   Note, that not all platforms support this mechanism. For example with TI compilers
+   a preprocessor pragma is used, but to do something like
+
+   \code
+   #define RAM_ALIGN #pragma DATA_ALIGN(x)
+   \encode
+
+   would require the preprocessor to process this line twice to fully resolve it. Hence,
+   a fully platform-independant way to use alignment is not supported.
+
+* \def    ALIGNMENT_DEFAULT
+*         Default alignment in bytes.
+*/
+#if defined(__GNUC__)	/* cppp replaced: elif */
+  #define ALIGNMENT_DEFAULT 8
+  #define RAM_ALIGN __attribute__((aligned(ALIGNMENT_DEFAULT)))
+#else
+  #define ALIGNMENT_DEFAULT 8
+  #define RAM_ALIGN
+#endif
+
+
+/*!
+* \def  RESTRICT
+*       The restrict keyword is supported by some platforms and RESTRICT maps to
+*       either the corresponding keyword on each platform or to void if the
+*       compiler does not provide such feature.
+*
+* \def  WORD_ALIGNED(x)
+*       Tells the compiler that pointer x is WORD aligned.
+*       At the moment only supported by TI compilers.
+*
+* \def  DWORD_ALIGNED(x)
+*       Tells the compiler that pointer x is DWORD aligned.
+*       At the moment only supported by TI compilers.
+*/
+  #define RESTRICT
+  #define WORD_ALIGNED(x)
+  #define DWORD_ALIGNED(x)
+
+
+/*-----------------------------------------------------------------------------------
+ * ALIGN_SIZE
+ *-----------------------------------------------------------------------------------*/
+/*!
+ * \brief  This macro aligns a given value depending on ::ALIGNMENT_DEFAULT.
+ *
+ * For example if #ALIGNMENT_DEFAULT equals 8, then:
+ * - ALIGN_SIZE(3) returns 8
+ * - ALIGN_SIZE(8) returns 8
+ * - ALIGN_SIZE(9) returns 16
+ */
+#define ALIGN_SIZE(a) ((a)+ (((INT)ALIGNMENT_DEFAULT - ((INT)(a) & (ALIGNMENT_DEFAULT-1)) ) & (ALIGNMENT_DEFAULT-1)))
+
+/*-----------------------------------------------------------------------------------
+ * ALIGN_PTR
+ * cast (a) to width of pointer
+ *-----------------------------------------------------------------------------------*/
+/*!
+ * \brief  This macro aligns a given address depending on ::ALIGNMENT_DEFAULT.
+ */
+#define ALIGN_PTR(a) ( (unsigned char*)(a) + (((INT)ALIGNMENT_DEFAULT - ((INT)(UINT64)(a) & (ALIGNMENT_DEFAULT-1)) ) & (ALIGNMENT_DEFAULT-1)) )
+
+ /* Alignment macro for libSYS heap implementation */
+#define ALIGNMENT_EXTRES    ( ALIGNMENT_DEFAULT )
+#define ALGN_SIZE_EXTRES(a) ((a)+ (((INT)ALIGNMENT_EXTRES - ((INT)(a) & (ALIGNMENT_EXTRES-1)) ) & (ALIGNMENT_EXTRES-1)))
+
+
+/*!
+ * \def  FORCEINLINE
+ *       Sometimes compiler do not do what they are told to do, and in case of inlining some
+ *       additional command might be necessary depending on the platform.
+ *
+ * \def  FDK_INLINE
+ *       Defines how the compiler is told to inline stuff.
+ */
+#ifdef DEBUG
+#undef FORCEINLINE
+#define FORCEINLINE
+#else
+#ifndef FORCEINLINE
+  #if defined(__GNUC__)	/* cppp replaced: elif */
+    #define FORCEINLINE __attribute((always_inline))
+  #else
+    #define FORCEINLINE
+  #endif
+#endif
+#endif
+
+  /* for all other platforms */
+  #define FDK_INLINE inline
+
+
+/*!
+ * \def  LNK_SECTION_DATA_L1
+ *       The LNK_SECTION_* defines allow memory to be drawn from specific memory
+ *       sections. Used as prefix before variable declaration.
+ *
+ * \def  LNK_SECTION_DATA_L2
+ *       See ::LNK_SECTION_DATA_L1
+ * \def  LNK_SECTION_L1_DATA_A
+ *       See ::LNK_SECTION_DATA_L1
+ * \def  LNK_SECTION_L1_DATA_B
+ *       See ::LNK_SECTION_DATA_L1
+ * \def  LNK_SECTION_CONSTDATA_L1
+ *       See ::LNK_SECTION_DATA_L1
+ * \def  LNK_SECTION_CONSTDATA
+ *       See ::LNK_SECTION_DATA_L1
+ * \def  LNK_SECTION_CODE_L1
+ *       See ::LNK_SECTION_DATA_L1
+ * \def  LNK_SECTION_CODE_L2
+ *       See ::LNK_SECTION_DATA_L1
+ * \def  LNK_SECTION_INITCODE
+ *       See ::LNK_SECTION_DATA_L1
+ */
+/**************************************************
+ * Code Section macros
+ **************************************************/
+  #define LNK_SECTION_CODE_L1
+  #define LNK_SECTION_CODE_L2
+  #define LNK_SECTION_INITCODE
+
+/* Memory section macros. */
+
+  /* default fall back */
+  #define LNK_SECTION_DATA_L1
+  #define LNK_SECTION_DATA_L2
+  #define LNK_SECTION_CONSTDATA
+  #define LNK_SECTION_CONSTDATA_L1
+
+  #define LNK_SECTION_L1_DATA_A
+  #define LNK_SECTION_L1_DATA_B
+
+
+#ifdef _MSC_VER
+  /*
+   * Sometimes certain features are excluded from compilation and therefore the warning 4065 may occur:
+   * "switch statement contains 'default' but no 'case' labels"
+   * We consider this warning irrelevant and disable it.
+   */
+  #pragma warning( disable : 4065 )
+#endif
+
+#endif /* __MACHINE_TYPE_H__ */
--- ffmpeg-2.5/localinc/fdk-aac/aacdecoder_lib.h.dl_headers~	2014-12-04 22:53:11.249832352 +0100
+++ ffmpeg-2.5/localinc/fdk-aac/aacdecoder_lib.h	2014-12-04 22:53:11.249832352 +0100
@@ -0,0 +1,689 @@
+
+/* -----------------------------------------------------------------------------------------------------------
+Software License for The Fraunhofer FDK AAC Codec Library for Android
+
+© Copyright  1995 - 2013 Fraunhofer-Gesellschaft zur Förderung der angewandten Forschung e.V.
+  All rights reserved.
+
+ 1.    INTRODUCTION
+The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software that implements
+the MPEG Advanced Audio Coding ("AAC") encoding and decoding scheme for digital audio.
+This FDK AAC Codec software is intended to be used on a wide variety of Android devices.
+
+AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient general perceptual
+audio codecs. AAC-ELD is considered the best-performing full-bandwidth communications codec by
+independent studies and is widely deployed. AAC has been standardized by ISO and IEC as part
+of the MPEG specifications.
+
+Patent licenses for necessary patent claims for the FDK AAC Codec (including those of Fraunhofer)
+may be obtained through Via Licensing (www.vialicensing.com) or through the respective patent owners
+individually for the purpose of encoding or decoding bit streams in products that are compliant with
+the ISO/IEC MPEG audio standards. Please note that most manufacturers of Android devices already license
+these patent claims through Via Licensing or directly from the patent owners, and therefore FDK AAC Codec
+software may already be covered under those patent licenses when it is used for those licensed purposes only.
+
+Commercially-licensed AAC software libraries, including floating-point versions with enhanced sound quality,
+are also available from Fraunhofer. Users are encouraged to check the Fraunhofer website for additional
+applications information and documentation.
+
+2.    COPYRIGHT LICENSE
+
+Redistribution and use in source and binary forms, with or without modification, are permitted without
+payment of copyright license fees provided that you satisfy the following conditions:
+
+You must retain the complete text of this software license in redistributions of the FDK AAC Codec or
+your modifications thereto in source code form.
+
+You must retain the complete text of this software license in the documentation and/or other materials
+provided with redistributions of the FDK AAC Codec or your modifications thereto in binary form.
+You must make available free of charge copies of the complete source code of the FDK AAC Codec and your
+modifications thereto to recipients of copies in binary form.
+
+The name of Fraunhofer may not be used to endorse or promote products derived from this library without
+prior written permission.
+
+You may not charge copyright license fees for anyone to use, copy or distribute the FDK AAC Codec
+software or your modifications thereto.
+
+Your modified versions of the FDK AAC Codec must carry prominent notices stating that you changed the software
+and the date of any change. For modified versions of the FDK AAC Codec, the term
+"Fraunhofer FDK AAC Codec Library for Android" must be replaced by the term
+"Third-Party Modified Version of the Fraunhofer FDK AAC Codec Library for Android."
+
+3.    NO PATENT LICENSE
+
+NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without limitation the patents of Fraunhofer,
+ARE GRANTED BY THIS SOFTWARE LICENSE. Fraunhofer provides no warranty of patent non-infringement with
+respect to this software.
+
+You may use this FDK AAC Codec software or modifications thereto only for purposes that are authorized
+by appropriate patent licenses.
+
+4.    DISCLAIMER
+
+This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright holders and contributors
+"AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, including but not limited to the implied warranties
+of merchantability and fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary, or consequential damages,
+including but not limited to procurement of substitute goods or services; loss of use, data, or profits,
+or business interruption, however caused and on any theory of liability, whether in contract, strict
+liability, or tort (including negligence), arising in any way out of the use of this software, even if
+advised of the possibility of such damage.
+
+5.    CONTACT INFORMATION
+
+Fraunhofer Institute for Integrated Circuits IIS
+Attention: Audio and Multimedia Departments - FDK AAC LL
+Am Wolfsmantel 33
+91058 Erlangen, Germany
+
+www.iis.fraunhofer.de/amm
+amm-info@iis.fraunhofer.de
+----------------------------------------------------------------------------------------------------------- */
+
+/*****************************  MPEG-4 AAC Decoder  **************************
+
+   Author(s):   Manuel Jander
+
+******************************************************************************/
+
+/**
+ * \file   aacdecoder_lib.h
+ * \brief  FDK AAC decoder library interface header file.
+ *
+
+\page INTRO Introduction
+
+\section SCOPE Scope
+
+This document describes the high-level interface and usage of the ISO/MPEG-2/4 AAC Decoder
+library developed by the Fraunhofer Institute for Integrated Circuits (IIS).
+Depending on the library configuration, it implements decoding of AAC-LC (Low-Complexity),
+HE-AAC (High-Efficiency AAC, v1 and v2), AAC-LD (Low-Delay) and AAC-ELD (Enhanced Low-Delay).
+
+All references to SBR (Spectral Band Replication) are only applicable to HE-AAC and AAC-ELD
+versions of the library. All references to PS (Parametric Stereo) are only applicable to
+HE-AAC v2 versions of the library.
+
+\section DecoderBasics Decoder Basics
+
+This document can only give a rough overview about the ISO/MPEG-2 and ISO/MPEG-4 AAC audio
+coding standard. To understand all the terms in this document, you are encouraged to read
+the following documents.
+
+- ISO/IEC 13818-7 (MPEG-2 AAC), which defines the syntax of MPEG-2 AAC audio bitstreams.
+- ISO/IEC 14496-3 (MPEG-4 AAC, subpart 1 and 4), which defines the syntax of MPEG-4 AAC audio bitstreams.
+- Lutzky, Schuller, Gayer, Kr&auml;mer, Wabnik, "A guideline to audio codec delay", 116th AES Convention, May 8, 2004
+
+MPEG Advanced Audio Coding is based on a time-to-frequency mapping of the signal. The signal
+is partitioned into overlapping portions and transformed into frequency domain. The spectral
+components are then quantized and coded.\n
+An MPEG2 or MPEG4 AAC audio bitstream is composed of frames. Contrary to MPEG-1/2 Layer-3 (mp3),
+the length of individual frames is not restricted to a fixed number of bytes, but can take on
+any length between 1 and 768 bytes.
+
+
+\page LIBUSE Library Usage
+
+\section InterfaceDescritpion API Description
+
+All API header files are located in the folder /include of the release package. They are described in
+detail in this document. All header files are provided for usage in C/C++ programs. The AAC decoder library
+API functions are located at aacdecoder_lib.h.
+
+In binary releases the decoder core resides in statically linkable libraries called for example libAACdec.a,
+(Linux) or FDK_aacDec_lib (Microsoft Visual C++).
+
+\section Calling_Sequence Calling Sequence
+
+For decoding of ISO/MPEG-2/4 AAC or HE-AAC v2 bitstreams the following sequence is mandatory. Input read
+and output write functions as well as the corresponding open and close functions are left out, since they
+may be implemented differently according to the user's specific requirements. The example implementation in
+main.cpp uses file-based input/output, and in such case call mpegFileRead_Open() to open an input file and
+to allocate memory for the required structures, and the corresponding mpegFileRead_Close() to close opened
+files and to de-allocate associated structures. mpegFileRead_Open() tries to detect the bitstream format and
+in case of MPEG-4 file format or Raw Packets file format (a Fraunhofer IIS proprietary format) reads the Audio
+Specific Config data (ASC). An unsuccessful attempt to recognize the bitstream format requires the user to
+provide this information manually (see \ref CommandLineUsage). For any other bitstream formats that are
+usually applicable in streaming applications, the decoder itself will try to synchronize and parse the given
+bitstream fragment using the FDK transport library. Hence, for streaming applications (without file access)
+this step is not necessary.
+
+-# Call aacDecoder_Open() to open and retrieve a handle to a new AAC decoder instance.
+\dontinclude main.cpp
+\skipline aacDecoder_Open
+-# If out-of-band config data (Audio Specific Config (ASC) or Stream Mux Config (SMC)) is available, call
+aacDecoder_ConfigRaw() to pass it to the decoder and before the decoding process starts. If this data is
+not available in advance, the decoder will get it from the bitstream  and configure itself while decoding
+with aacDecoder_DecodeFrame().
+-# Begin decoding loop.
+\skipline do {
+-# Read data from bitstream file or stream into a client-supplied input buffer ("inBuffer" in main.cpp).
+If it is very small like just 4, aacDecoder_DecodeFrame() will
+repeatedly return ::AAC_DEC_NOT_ENOUGH_BITS until enough bits were fed by aacDecoder_Fill(). Only read data
+when this buffer has completely been processed and is then empty. For file-based input execute
+mpegFileRead_Read() or any other implementation with similar functionality.
+-# Call aacDecoder_Fill() to fill the decoder's internal bitstream input buffer with the client-supplied
+external bitstream input buffer.
+\skipline aacDecoder_Fill
+-# Call aacDecoder_DecodeFrame() which writes decoded PCM audio data to a client-supplied buffer. It is the
+client's responsibility to allocate a buffer which is large enough to hold this output data.
+\skipline aacDecoder_DecodeFrame
+If the bitstream's configuration (number of channels, sample rate, frame size) is not known in advance, you may
+call aacDecoder_GetStreamInfo() to retrieve a structure containing this information and then initialize an audio
+output device. In the example main.cpp, if the number of channels or the sample rate has changed since program
+start or since the previously decoded frame, the audio output device will be re-initialized. If WAVE file output
+is chosen, a new WAVE file for each new configuration will be created.
+\skipline aacDecoder_GetStreamInfo
+-# Repeat steps 5 to 7 until no data to decode is available anymore, or if an error occured.
+\skipline } while
+-# Call aacDecoder_Close() to de-allocate all AAC decoder and transport layer structures.
+\skipline aacDecoder_Close
+
+\section BufferSystem Buffer System
+
+There are three main buffers in an AAC decoder application. One external input buffer to hold bitstream
+data from file I/O or elsewhere, one decoder-internal input buffer, and one to hold the decoded output
+PCM sample data, whereas this output buffer may overlap with the external input buffer.
+
+The external input buffer is set in the example framework main.cpp and its size is defined by ::IN_BUF_SIZE.
+You may freely choose different sizes here. To feed the data to the decoder-internal input buffer, use the
+function aacDecoder_Fill(). This function returns important information about how many bytes in the
+external input buffer have not yet been copied into the internal input buffer (variable bytesValid).
+Once the external buffer has been fully copied, it can be re-filled again.
+In case you want to re-fill it when there are still unprocessed bytes (bytesValid is unequal 0), you
+would have to additionally perform a memcpy(), so that just means unnecessary computational overhead
+and therefore we recommend to re-fill the buffer only when bytesValid is 0.
+
+\image latex dec_buffer.png "Lifecycle of the external input buffer" width=9cm
+
+The size of the decoder-internal input buffer is set in tpdec_lib.h (see define ::TRANSPORTDEC_INBUF_SIZE).
+You may choose a smaller size under the following considerations:
+
+- each input channel requires 768 bytes
+- the whole buffer must be of size 2^n
+
+So for example a stereo decoder:
+
+\f[
+TRANSPORTDEC\_INBUF\_SIZE = 2 * 768 = 1536 => 2048
+\f]
+
+tpdec_lib.h and TRANSPORTDEC_INBUF_SIZE are not part of the decoder's library interface. Therefore
+only source-code clients may change this setting. If you received a library release, please ask us and
+we can change this in order to meet your memory requirements.
+
+\page OutputFormat Decoder audio output
+
+\section OutputFormatObtaining Obtaining channel mapping information
+
+The decoded audio output format is indicated by a set of variables of the CStreamInfo structure.
+While the members sampleRate, frameSize and numChannels might be quite self explaining,
+pChannelType and pChannelIndices might require some more detailed explanation.
+
+These two arrays indicate what is each output channel supposed to be. Both array have
+CStreamInfo::numChannels cells. Each cell of pChannelType indicates the channel type, described in
+the enum ::AUDIO_CHANNEL_TYPE defined in FDK_audio.h. The cells of pChannelIndices indicate the sub index
+among the channels starting with 0 among all channels of the same audio channel type.
+
+The indexing scheme is the same as for MPEG-2/4. Thus indices are counted upwards starting from the front
+direction (thus a center channel if any, will always be index 0). Then the indices count up, starting always
+with the left side, pairwise from front toward back. For detailed explanation, please refer to
+ISO/IEC 13818-7:2005(E), chapter 8.5.3.2.
+
+In case a Program Config is included in the audio configuration, the channel mapping described within
+it will be adopted.
+
+In case of MPEG-D Surround the channel mapping will follow the same criteria described in ISO/IEC 13818-7:2005(E),
+but adding corresponding top channels to the channel types front, side and back, in order to avoid any
+loss of information.
+
+\section OutputFormatChange Changing the audio output format
+
+The channel interleaving scheme and the actual channel order can be changed at runtime through the
+parameters ::AAC_PCM_OUTPUT_INTERLEAVED and ::AAC_PCM_OUTPUT_CHANNEL_MAPPING. See the description of those
+parameters and the decoder library function aacDecoder_SetParam() for more detail.
+
+\section OutputFormatExample Channel mapping examples
+
+The following examples illustrate the location of individual audio samples in the audio buffer that
+is passed to aacDecoder_DecodeFrame() and the expected data in the CStreamInfo structure which can be obtained
+by calling aacDecoder_GetStreamInfo().
+
+\subsection ExamplesStereo Stereo
+
+In case of ::AAC_PCM_OUTPUT_INTERLEAVED set to 0 and ::AAC_PCM_OUTPUT_CHANNEL_MAPPING set to 1,
+a AAC-LC bit stream which has channelConfiguration = 2 in its audio specific config would lead
+to the following values in CStreamInfo:
+
+CStreamInfo::numChannels = 2
+
+CStreamInfo::pChannelType = { ::ACT_FRONT, ::ACT_FRONT }
+
+CStreamInfo::pChannelIndices = { 0, 1 }
+
+Since ::AAC_PCM_OUTPUT_INTERLEAVED is set to 0, the audio channels will be located as contiguous blocks
+in the output buffer as follows:
+
+\verbatim
+  <left sample 0>  <left sample 1>  <left sample 2>  ... <left sample N>
+  <right sample 0> <right sample 1> <right sample 2> ... <right sample N>
+\endverbatim
+
+Where N equals to CStreamInfo::frameSize .
+
+\subsection ExamplesSurround Surround 5.1
+
+In case of ::AAC_PCM_OUTPUT_INTERLEAVED set to 1 and ::AAC_PCM_OUTPUT_CHANNEL_MAPPING set to 1,
+a AAC-LC bit stream which has channelConfiguration = 6 in its audio specific config, would lead
+to the following values in CStreamInfo:
+
+CStreamInfo::numChannels = 6
+
+CStreamInfo::pChannelType = { ::ACT_FRONT, ::ACT_FRONT, ::ACT_FRONT, ::ACT_LFE, ::ACT_BACK, ::ACT_BACK }
+
+CStreamInfo::pChannelIndices = { 1, 2, 0, 0, 0, 1 }
+
+Since ::AAC_PCM_OUTPUT_CHANNEL_MAPPING is 1, WAV file channel ordering will be used. For a 5.1 channel
+scheme, thus the channels would be: front left, front right, center, LFE, surround left, surround right.
+Thus the third channel is the center channel, receiving the index 0. The other front channels are
+front left, front right being placed as first and second channels with indices 1 and 2 correspondingly.
+There is only one LFE, placed as the fourth channel and index 0. Finally both surround
+channels get the type definition ACT_BACK, and the indices 0 and 1.
+
+Since ::AAC_PCM_OUTPUT_INTERLEAVED is set to 1, the audio channels will be placed in the output buffer
+as follows:
+
+\verbatim
+<front left sample 0> <front right sample 0>
+<center sample 0> <LFE sample 0>
+<surround left sample 0> <surround right sample 0>
+
+<front left sample 1> <front right sample 1>
+<center sample 1> <LFE sample 1>
+<surround left sample 1> <surround right sample 1>
+
+...
+
+<front left sample N> <front right sample N>
+<center sample N> <LFE sample N>
+<surround left sample N> <surround right sample N>
+\endverbatim
+
+Where N equals to CStreamInfo::frameSize .
+
+\subsection ExamplesArib ARIB coding mode 2/1
+
+In case of ::AAC_PCM_OUTPUT_INTERLEAVED set to 1 and ::AAC_PCM_OUTPUT_CHANNEL_MAPPING set to 1,
+in case of a ARIB bit stream using coding mode 2/1 as described in ARIB STD-B32 Part 2 Version 2.1-E1, page 61,
+would lead to the following values in CStreamInfo:
+
+CStreamInfo::numChannels = 3
+
+CStreamInfo::pChannelType = { ::ACT_FRONT, ::ACT_FRONT,:: ACT_BACK }
+
+CStreamInfo::pChannelIndices = { 0, 1, 0 }
+
+The audio channels will be placed as follows in the audio output buffer:
+
+\verbatim
+<front left sample 0> <front right sample 0>  <mid surround sample 0>
+
+<front left sample 1> <front right sample 1> <mid surround sample 1>
+
+...
+
+<front left sample N> <front right sample N> <mid surround sample N>
+
+Where N equals to CStreamInfo::frameSize .
+
+\endverbatim
+
+*/
+
+#ifndef AACDECODER_LIB_H
+#define AACDECODER_LIB_H
+
+#include "machine_type.h"
+#include "FDK_audio.h"
+
+#include "genericStds.h"
+
+/**
+ * \brief  AAC decoder error codes.
+ */
+typedef enum {
+  AAC_DEC_OK                             = 0x0000,  /*!< No error occured. Output buffer is valid and error free. */
+  AAC_DEC_OUT_OF_MEMORY                  = 0x0002,  /*!< Heap returned NULL pointer. Output buffer is invalid. */
+  AAC_DEC_UNKNOWN                        = 0x0005,  /*!< Error condition is of unknown reason, or from a another module. Output buffer is invalid. */
+
+  /* Synchronization errors. Output buffer is invalid. */
+  aac_dec_sync_error_start               = 0x1000,
+  AAC_DEC_TRANSPORT_SYNC_ERROR           = 0x1001,  /*!< The transport decoder had syncronisation problems. Do not exit decoding. Just feed new
+                                                         bitstream data. */
+  AAC_DEC_NOT_ENOUGH_BITS                = 0x1002,  /*!< The input buffer ran out of bits. */
+  aac_dec_sync_error_end                 = 0x1FFF,
+
+  /* Initialization errors. Output buffer is invalid. */
+  aac_dec_init_error_start               = 0x2000,
+  AAC_DEC_INVALID_HANDLE                 = 0x2001,  /*!< The handle passed to the function call was invalid (NULL). */
+  AAC_DEC_UNSUPPORTED_AOT                = 0x2002,  /*!< The AOT found in the configuration is not supported. */
+  AAC_DEC_UNSUPPORTED_FORMAT             = 0x2003,  /*!< The bitstream format is not supported.  */
+  AAC_DEC_UNSUPPORTED_ER_FORMAT          = 0x2004,  /*!< The error resilience tool format is not supported. */
+  AAC_DEC_UNSUPPORTED_EPCONFIG           = 0x2005,  /*!< The error protection format is not supported. */
+  AAC_DEC_UNSUPPORTED_MULTILAYER         = 0x2006,  /*!< More than one layer for AAC scalable is not supported. */
+  AAC_DEC_UNSUPPORTED_CHANNELCONFIG      = 0x2007,  /*!< The channel configuration (either number or arrangement) is not supported. */
+  AAC_DEC_UNSUPPORTED_SAMPLINGRATE       = 0x2008,  /*!< The sample rate specified in the configuration is not supported. */
+  AAC_DEC_INVALID_SBR_CONFIG             = 0x2009,  /*!< The SBR configuration is not supported. */
+  AAC_DEC_SET_PARAM_FAIL                 = 0x200A,  /*!< The parameter could not be set. Either the value was out of range or the parameter does
+                                                         not exist. */
+  AAC_DEC_NEED_TO_RESTART                = 0x200B,  /*!< The decoder needs to be restarted, since the requiered configuration change cannot be
+                                                         performed. */
+  aac_dec_init_error_end                 = 0x2FFF,
+
+  /* Decode errors. Output buffer is valid but concealed. */
+  aac_dec_decode_error_start             = 0x4000,
+  AAC_DEC_TRANSPORT_ERROR                = 0x4001,  /*!< The transport decoder encountered an unexpected error. */
+  AAC_DEC_PARSE_ERROR                    = 0x4002,  /*!< Error while parsing the bitstream. Most probably it is corrupted, or the system crashed. */
+  AAC_DEC_UNSUPPORTED_EXTENSION_PAYLOAD  = 0x4003,  /*!< Error while parsing the extension payload of the bitstream. The extension payload type
+                                                         found is not supported. */
+  AAC_DEC_DECODE_FRAME_ERROR             = 0x4004,  /*!< The parsed bitstream value is out of range. Most probably the bitstream is corrupt, or
+                                                         the system crashed. */
+  AAC_DEC_CRC_ERROR                      = 0x4005,  /*!< The embedded CRC did not match. */
+  AAC_DEC_INVALID_CODE_BOOK              = 0x4006,  /*!< An invalid codebook was signalled. Most probably the bitstream is corrupt, or the system
+                                                         crashed. */
+  AAC_DEC_UNSUPPORTED_PREDICTION         = 0x4007,  /*!< Predictor found, but not supported in the AAC Low Complexity profile. Most probably the
+                                                         bitstream is corrupt, or has a wrong format. */
+  AAC_DEC_UNSUPPORTED_CCE                = 0x4008,  /*!< A CCE element was found which is not supported. Most probably the bitstream is corrupt, or
+                                                         has a wrong format. */
+  AAC_DEC_UNSUPPORTED_LFE                = 0x4009,  /*!< A LFE element was found which is not supported. Most probably the bitstream is corrupt, or
+                                                         has a wrong format. */
+  AAC_DEC_UNSUPPORTED_GAIN_CONTROL_DATA  = 0x400A,  /*!< Gain control data found but not supported. Most probably the bitstream is corrupt, or has
+                                                         a wrong format. */
+  AAC_DEC_UNSUPPORTED_SBA                = 0x400B,  /*!< SBA found, but currently not supported in the BSAC profile. */
+  AAC_DEC_TNS_READ_ERROR                 = 0x400C,  /*!< Error while reading TNS data. Most probably the bitstream is corrupt or the system
+                                                         crashed. */
+  AAC_DEC_RVLC_ERROR                     = 0x400D,  /*!< Error while decoding error resillient data. */
+  aac_dec_decode_error_end               = 0x4FFF,
+
+  /* Ancillary data errors. Output buffer is valid. */
+  aac_dec_anc_data_error_start           = 0x8000,
+  AAC_DEC_ANC_DATA_ERROR                 = 0x8001,  /*!< Non severe error concerning the ancillary data handling. */
+  AAC_DEC_TOO_SMALL_ANC_BUFFER           = 0x8002,  /*!< The registered ancillary data buffer is too small to receive the parsed data. */
+  AAC_DEC_TOO_MANY_ANC_ELEMENTS          = 0x8003,  /*!< More than the allowed number of ancillary data elements should be written to buffer. */
+  aac_dec_anc_data_error_end             = 0x8FFF
+
+
+} AAC_DECODER_ERROR;
+
+
+/** Macro to identify initialization errors. */
+#define IS_INIT_ERROR(err)   ( (((err)>=aac_dec_init_error_start)   && ((err)<=aac_dec_init_error_end))   ? 1 : 0)
+/** Macro to identify decode errors. */
+#define IS_DECODE_ERROR(err) ( (((err)>=aac_dec_decode_error_start) && ((err)<=aac_dec_decode_error_end)) ? 1 : 0)
+/** Macro to identify if the audio output buffer contains valid samples after calling aacDecoder_DecodeFrame(). */
+#define IS_OUTPUT_VALID(err) ( ((err) == AAC_DEC_OK) || IS_DECODE_ERROR(err) )
+
+/**
+ * \brief AAC decoder setting parameters
+ */
+typedef enum
+{
+  AAC_PCM_OUTPUT_INTERLEAVED              = 0x0000,  /*!< PCM output mode (1: interleaved (default); 0: not interleaved). */
+  AAC_PCM_OUTPUT_CHANNELS                 = 0x0001,  /*!< Number of PCM output channels (if different from encoded audio channels, downmixing or
+                                                          upmixing is applied). \n
+                                                          -1: Disable up-/downmixing. The decoder output contains the same number of channels as the
+                                                              encoded bitstream. \n
+                                                           1: The decoder performs a mono matrix mix-down if the encoded audio channels are greater
+                                                              than one. Thus it ouputs always exact one channel. \n
+                                                           2: The decoder performs a stereo matrix mix-down if the encoded audio channels are greater
+                                                              than two. If the encoded audio channels are smaller than two the decoder duplicates the
+                                                              output. Thus it ouputs always exact two channels. \n */
+  AAC_PCM_DUAL_CHANNEL_OUTPUT_MODE        = 0x0002,  /*!< Defines how the decoder processes two channel signals:
+                                                          0: Leave both signals as they are (default).
+                                                          1: Create a dual mono output signal from channel 1.
+                                                          2: Create a dual mono output signal from channel 2.
+                                                          3: Create a dual mono output signal by mixing both channels (L' = R' = 0.5*Ch1 + 0.5*Ch2). */
+  AAC_PCM_OUTPUT_CHANNEL_MAPPING          = 0x0003,  /*!< Output buffer channel ordering. 0: MPEG PCE style order, 1: WAV file channel order (default). */
+
+  AAC_CONCEAL_METHOD                      = 0x0100,  /*!< Error concealment: Processing method. \n
+                                                          0: Spectral muting. \n
+                                                          1: Noise substitution (see ::CONCEAL_NOISE). \n
+                                                          2: Energy interpolation (adds additional signal delay of one frame, see ::CONCEAL_INTER). \n */
+
+  AAC_DRC_BOOST_FACTOR                    = 0x0200,  /*!< Dynamic Range Control: Scaling factor for boosting gain values.
+                                                          Defines how the boosting DRC factors (conveyed in the bitstream) will be applied to the
+                                                          decoded signal. The valid values range from 0 (don't apply boost factors) to 127 (fully
+                                                          apply all boosting factors). */
+  AAC_DRC_ATTENUATION_FACTOR              = 0x0201,  /*!< Dynamic Range Control: Scaling factor for attenuating gain values. Same as
+                                                          AAC_DRC_BOOST_FACTOR but for attenuating DRC factors. */
+  AAC_DRC_REFERENCE_LEVEL                 = 0x0202,  /*!< Dynamic Range Control: Target reference level. Defines the level below full-scale
+                                                          (quantized in steps of 0.25dB) to which the output audio signal will be normalized to by
+                                                          the DRC module. The valid values range from 0 (full-scale) to 127 (31.75 dB below
+                                                          full-scale). The value smaller than 0 switches off normalization. */
+  AAC_DRC_HEAVY_COMPRESSION               = 0x0203,  /*!< Dynamic Range Control: En-/Disable DVB specific heavy compression (aka RF mode).
+                                                          If set to 1, the decoder will apply the compression values from the DVB specific ancillary
+                                                          data field. At the same time the MPEG-4 Dynamic Range Control tool will be disabled. By
+                                                          default heavy compression is disabled. */
+
+  AAC_QMF_LOWPOWER                        = 0x0300,  /*!< Quadrature Mirror Filter (QMF) Bank processing mode. \n
+                                                          -1: Use internal default. Implies MPEG Surround partially complex accordingly. \n
+                                                           0: Use complex QMF data mode. \n
+                                                           1: Use real (low power) QMF data mode. \n */
+
+  AAC_MPEGS_ENABLE                        = 0x0500,  /*!< MPEG Surround: Allow/Disable decoding of MPS content. Available only for decoders with MPEG
+                                                          Surround support. */
+
+  AAC_TPDEC_CLEAR_BUFFER                  = 0x0603   /*!< Clear internal bit stream buffer of transport layers. The decoder will start decoding
+                                                          at new data passed after this event and any previous data is discarded. */
+
+} AACDEC_PARAM;
+
+/**
+ * \brief This structure gives information about the currently decoded audio data.
+ *        All fields are read-only.
+ */
+typedef struct
+{
+  /* These three members are the only really relevant ones for the user.                                                           */
+  INT               sampleRate;          /*!< The samplerate in Hz of the fully decoded PCM audio signal (after SBR processing).   */
+  INT               frameSize;           /*!< The frame size of the decoded PCM audio signal. \n
+                                              1024 or 960 for AAC-LC \n
+                                              2048 or 1920 for HE-AAC (v2) \n
+                                              512 or 480 for AAC-LD and AAC-ELD                                                    */
+  INT               numChannels;         /*!< The number of output audio channels in the decoded and interleaved PCM audio signal. */
+  AUDIO_CHANNEL_TYPE *pChannelType;       /*!< Audio channel type of each output audio channel.           */
+  UCHAR             *pChannelIndices;     /*!< Audio channel index for each output audio channel.
+                                               See ISO/IEC 13818-7:2005(E), 8.5.3.2 Explicit channel mapping using a program_config_element() */
+  /* Decoder internal members. */
+  INT               aacSampleRate;       /*!< sampling rate in Hz without SBR (from configuration info).                           */
+  INT               profile;             /*!< MPEG-2 profile (from file header) (-1: not applicable (e. g. MPEG-4)).               */
+  AUDIO_OBJECT_TYPE aot;                 /*!< Audio Object Type (from ASC): is set to the appropriate value for MPEG-2 bitstreams (e. g. 2 for AAC-LC). */
+  INT               channelConfig;       /*!< Channel configuration (0: PCE defined, 1: mono, 2: stereo, ...                       */
+  INT               bitRate;             /*!< Instantaneous bit rate.                   */
+  INT               aacSamplesPerFrame;  /*!< Samples per frame for the AAC core (from ASC). \n
+                                              1024 or 960 for AAC-LC \n
+                                              512 or 480 for AAC-LD and AAC-ELD         */
+  INT               aacNumChannels;      /*!< The number of audio channels after AAC core processing (before PS or MPS processing).
+                                              CAUTION: This are not the final number of output channels! */
+  AUDIO_OBJECT_TYPE extAot;              /*!< Extension Audio Object Type (from ASC)   */
+  INT               extSamplingRate;     /*!< Extension sampling rate in Hz (from ASC) */
+
+  UINT              flags;               /*!< Copy if internal flags. Only to be written by the decoder, and only to be read externally. */
+
+  SCHAR             epConfig;            /*!< epConfig level (from ASC): only level 0 supported, -1 means no ER (e. g. AOT=2, MPEG-2 AAC, etc.)  */
+
+  /* Statistics */
+  INT               numLostAccessUnits;  /*!< This integer will reflect the estimated amount of lost access units in case aacDecoder_DecodeFrame()
+                                              returns AAC_DEC_TRANSPORT_SYNC_ERROR. It will be < 0 if the estimation failed. */
+
+  UINT              numTotalBytes;       /*!< This is the number of total bytes that have passed through the decoder. */
+  UINT              numBadBytes;         /*!< This is the number of total bytes that were considered with errors from numTotalBytes. */
+  UINT              numTotalAccessUnits; /*!< This is the number of total access units that have passed through the decoder. */
+  UINT              numBadAccessUnits;   /*!< This is the number of total access units that were considered with errors from numTotalBytes. */
+
+} CStreamInfo;
+
+
+typedef struct AAC_DECODER_INSTANCE *HANDLE_AACDECODER;
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/**
+ * \brief Initialize ancillary data buffer.
+ *
+ * \param self    AAC decoder handle.
+ * \param buffer  Pointer to (external) ancillary data buffer.
+ * \param size    Size of the buffer pointed to by buffer.
+ * \return        Error code.
+ */
+LINKSPEC_H AAC_DECODER_ERROR
+aacDecoder_AncDataInit ( HANDLE_AACDECODER self,
+                         UCHAR            *buffer,
+                         int               size );
+
+/**
+ * \brief Get one ancillary data element.
+ *
+ * \param self   AAC decoder handle.
+ * \param index  Index of the ancillary data element to get.
+ * \param ptr    Pointer to a buffer receiving a pointer to the requested ancillary data element.
+ * \param size   Pointer to a buffer receiving the length of the requested ancillary data element.
+ * \return       Error code.
+ */
+LINKSPEC_H AAC_DECODER_ERROR
+aacDecoder_AncDataGet ( HANDLE_AACDECODER self,
+                        int               index,
+                        UCHAR           **ptr,
+                        int              *size );
+
+/**
+ * \brief Set one single decoder parameter.
+ *
+ * \param self   AAC decoder handle.
+ * \param param  Parameter to be set.
+ * \param value  Parameter value.
+ * \return       Error code.
+ */
+LINKSPEC_H AAC_DECODER_ERROR
+aacDecoder_SetParam ( const HANDLE_AACDECODER  self,
+                      const AACDEC_PARAM       param,
+                      const INT                value );
+
+
+/**
+ * \brief              Get free bytes inside decoder internal buffer
+ * \param self    Handle of AAC decoder instance
+ * \param pFreeBytes Pointer to variable receving amount of free bytes inside decoder internal buffer
+ * \return             Error code
+ */
+LINKSPEC_H AAC_DECODER_ERROR
+aacDecoder_GetFreeBytes ( const HANDLE_AACDECODER  self,
+                                            UINT *pFreeBytes);
+
+/**
+ * \brief               Open an AAC decoder instance
+ * \param transportFmt  The transport type to be used
+ * \return              AAC decoder handle
+ */
+LINKSPEC_H HANDLE_AACDECODER
+aacDecoder_Open ( TRANSPORT_TYPE transportFmt, UINT nrOfLayers );
+
+/**
+ * \brief Explicitly configure the decoder by passing a raw AudioSpecificConfig (ASC) or a StreamMuxConfig (SMC),
+ *  contained in a binary buffer. This is required for MPEG-4 and Raw Packets file format bitstreams
+ *  as well as for LATM bitstreams with no in-band SMC. If the transport format is LATM with or without
+ *  LOAS, configuration is assumed to be an SMC, for all other file formats an ASC.
+ *
+ * \param self    AAC decoder handle.
+ * \param conf    Pointer to an unsigned char buffer containing the binary configuration buffer (either ASC or SMC).
+ * \param length  Length of the configuration buffer in bytes.
+ * \return        Error code.
+ */
+LINKSPEC_H AAC_DECODER_ERROR
+aacDecoder_ConfigRaw ( HANDLE_AACDECODER self,
+                       UCHAR            *conf[],
+                       const UINT        length[] );
+
+
+/**
+ * \brief Fill AAC decoder's internal input buffer with bitstream data from the external input buffer.
+ *  The function only copies such data as long as the decoder-internal input buffer is not full.
+ *  So it grabs whatever it can from pBuffer and returns information (bytesValid) so that at a
+ *  subsequent call of %aacDecoder_Fill(), the right position in pBuffer can be determined to
+ *  grab the next data.
+ *
+ * \param self        AAC decoder handle.
+ * \param pBuffer     Pointer to external input buffer.
+ * \param bufferSize  Size of external input buffer. This argument is required because decoder-internally
+ *                    we need the information to calculate the offset to pBuffer, where the next
+ *                    available data is, which is then fed into the decoder-internal buffer (as much
+ *                    as possible). Our example framework implementation fills the buffer at pBuffer
+ *                    again, once it contains no available valid bytes anymore (meaning bytesValid equal 0).
+ * \param bytesValid  Number of bitstream bytes in the external bitstream buffer that have not yet been
+ *                    copied into the decoder's internal bitstream buffer by calling this function.
+ *                    The value is updated according to the amount of newly copied bytes.
+ * \return            Error code.
+ */
+LINKSPEC_H AAC_DECODER_ERROR
+aacDecoder_Fill ( HANDLE_AACDECODER  self,
+                  UCHAR             *pBuffer[],
+                  const UINT         bufferSize[],
+                  UINT              *bytesValid );
+
+#define AACDEC_CONCEAL  1 /*!< Flag for aacDecoder_DecodeFrame(): do not consider new input data. Do concealment. */
+#define AACDEC_FLUSH    2 /*!< Flag for aacDecoder_DecodeFrame(): Do not consider new input data. Flush filterbanks (output delayed audio). */
+#define AACDEC_INTR     4 /*!< Flag for aacDecoder_DecodeFrame(): Signal an input bit stream data discontinuity. Resync any internals as necessary. */
+#define AACDEC_CLRHIST  8 /*!< Flag for aacDecoder_DecodeFrame(): Clear all signal delay lines and history buffers.
+                               Caution: This can cause discontinuities in the output signal. */
+
+/**
+ * \brief            Decode one audio frame
+ *
+ * \param self       AAC decoder handle.
+ * \param pTimeData  Pointer to external output buffer where the decoded PCM samples will be stored into.
+ * \param flags      Bit field with flags for the decoder: \n
+ *                   (flags & AACDEC_CONCEAL) == 1: Do concealment. \n
+ *                   (flags & AACDEC_FLUSH) == 2: Discard input data. Flush filter banks (output delayed audio). \n
+ *                   (flags & AACDEC_INTR) == 4: Input data is discontinuous. Resynchronize any internals as necessary.
+ * \return           Error code.
+ */
+LINKSPEC_H AAC_DECODER_ERROR
+aacDecoder_DecodeFrame ( HANDLE_AACDECODER  self,
+                         INT_PCM           *pTimeData,
+                         const INT          timeDataSize,
+                         const UINT         flags );
+
+/**
+ * \brief       De-allocate all resources of an AAC decoder instance.
+ *
+ * \param self  AAC decoder handle.
+ * \return      void
+ */
+LINKSPEC_H void aacDecoder_Close ( HANDLE_AACDECODER self );
+
+/**
+ * \brief       Get CStreamInfo handle from decoder.
+ *
+ * \param self  AAC decoder handle.
+ * \return      Reference to requested CStreamInfo.
+ */
+LINKSPEC_H CStreamInfo* aacDecoder_GetStreamInfo( HANDLE_AACDECODER self );
+
+/**
+ * \brief       Get decoder library info.
+ *
+ * \param info  Pointer to an allocated LIB_INFO structure.
+ * \return      0 on success
+ */
+LINKSPEC_H INT aacDecoder_GetLibInfo( LIB_INFO *info );
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* AACDECODER_LIB_H */
--- ffmpeg-2.5/localinc/fdk-aac/aacenc_lib.h.dl_headers~	2014-12-04 22:53:11.253165674 +0100
+++ ffmpeg-2.5/localinc/fdk-aac/aacenc_lib.h	2014-12-04 22:53:11.253165674 +0100
@@ -0,0 +1,1228 @@
+
+/* -----------------------------------------------------------------------------------------------------------
+Software License for The Fraunhofer FDK AAC Codec Library for Android
+
+© Copyright  1995 - 2013 Fraunhofer-Gesellschaft zur Förderung der angewandten Forschung e.V.
+  All rights reserved.
+
+ 1.    INTRODUCTION
+The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software that implements
+the MPEG Advanced Audio Coding ("AAC") encoding and decoding scheme for digital audio.
+This FDK AAC Codec software is intended to be used on a wide variety of Android devices.
+
+AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient general perceptual
+audio codecs. AAC-ELD is considered the best-performing full-bandwidth communications codec by
+independent studies and is widely deployed. AAC has been standardized by ISO and IEC as part
+of the MPEG specifications.
+
+Patent licenses for necessary patent claims for the FDK AAC Codec (including those of Fraunhofer)
+may be obtained through Via Licensing (www.vialicensing.com) or through the respective patent owners
+individually for the purpose of encoding or decoding bit streams in products that are compliant with
+the ISO/IEC MPEG audio standards. Please note that most manufacturers of Android devices already license
+these patent claims through Via Licensing or directly from the patent owners, and therefore FDK AAC Codec
+software may already be covered under those patent licenses when it is used for those licensed purposes only.
+
+Commercially-licensed AAC software libraries, including floating-point versions with enhanced sound quality,
+are also available from Fraunhofer. Users are encouraged to check the Fraunhofer website for additional
+applications information and documentation.
+
+2.    COPYRIGHT LICENSE
+
+Redistribution and use in source and binary forms, with or without modification, are permitted without
+payment of copyright license fees provided that you satisfy the following conditions:
+
+You must retain the complete text of this software license in redistributions of the FDK AAC Codec or
+your modifications thereto in source code form.
+
+You must retain the complete text of this software license in the documentation and/or other materials
+provided with redistributions of the FDK AAC Codec or your modifications thereto in binary form.
+You must make available free of charge copies of the complete source code of the FDK AAC Codec and your
+modifications thereto to recipients of copies in binary form.
+
+The name of Fraunhofer may not be used to endorse or promote products derived from this library without
+prior written permission.
+
+You may not charge copyright license fees for anyone to use, copy or distribute the FDK AAC Codec
+software or your modifications thereto.
+
+Your modified versions of the FDK AAC Codec must carry prominent notices stating that you changed the software
+and the date of any change. For modified versions of the FDK AAC Codec, the term
+"Fraunhofer FDK AAC Codec Library for Android" must be replaced by the term
+"Third-Party Modified Version of the Fraunhofer FDK AAC Codec Library for Android."
+
+3.    NO PATENT LICENSE
+
+NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without limitation the patents of Fraunhofer,
+ARE GRANTED BY THIS SOFTWARE LICENSE. Fraunhofer provides no warranty of patent non-infringement with
+respect to this software.
+
+You may use this FDK AAC Codec software or modifications thereto only for purposes that are authorized
+by appropriate patent licenses.
+
+4.    DISCLAIMER
+
+This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright holders and contributors
+"AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, including but not limited to the implied warranties
+of merchantability and fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary, or consequential damages,
+including but not limited to procurement of substitute goods or services; loss of use, data, or profits,
+or business interruption, however caused and on any theory of liability, whether in contract, strict
+liability, or tort (including negligence), arising in any way out of the use of this software, even if
+advised of the possibility of such damage.
+
+5.    CONTACT INFORMATION
+
+Fraunhofer Institute for Integrated Circuits IIS
+Attention: Audio and Multimedia Departments - FDK AAC LL
+Am Wolfsmantel 33
+91058 Erlangen, Germany
+
+www.iis.fraunhofer.de/amm
+amm-info@iis.fraunhofer.de
+----------------------------------------------------------------------------------------------------------- */
+
+/**************************** MPEG-4 HE-AAC Encoder **************************
+
+  Initial author:       M. Lohwasser
+******************************************************************************/
+
+/**
+ * \file   aacenc_lib.h
+ * \brief  FDK AAC Encoder library interface header file.
+ *
+\mainpage  Introduction
+
+\section Scope
+
+This document describes the high-level interface and usage of the ISO/MPEG-2/4 AAC Encoder
+library developed by the Fraunhofer Institute for Integrated Circuits (IIS).
+
+The library implements encoding on the basis of the MPEG-2 and MPEG-4 AAC Low-Complexity
+standard, and depending on the library's configuration, MPEG-4 High-Efficiency AAC v2 and/or AAC-ELD standard.
+
+All references to SBR (Spectral Band Replication) are only applicable to HE-AAC or AAC-ELD versions
+of the library. All references to PS (Parametric Stereo) are only applicable to HE-AAC v2
+versions of the library.
+
+\section encBasics Encoder Basics
+
+This document can only give a rough overview about the ISO/MPEG-2 and ISO/MPEG-4 AAC audio coding
+standard. To understand all the terms in this document, you are encouraged to read the following documents.
+
+- ISO/IEC 13818-7 (MPEG-2 AAC), which defines the syntax of MPEG-2 AAC audio bitstreams.
+- ISO/IEC 14496-3 (MPEG-4 AAC, subparts 1 and 4), which defines the syntax of MPEG-4 AAC audio bitstreams.
+- Lutzky, Schuller, Gayer, Kr&auml;mer, Wabnik, "A guideline to audio codec delay", 116th AES Convention, May 8, 2004
+
+MPEG Advanced Audio Coding is based on a time-to-frequency mapping of the signal. The signal is
+partitioned into overlapping portions and transformed into frequency domain. The spectral components
+are then quantized and coded. \n
+An MPEG-2 or MPEG-4 AAC audio bitstream is composed of frames. Contrary to MPEG-1/2 Layer-3 (mp3), the
+length of individual frames is not restricted to a fixed number of bytes, but can take on any length
+between 1 and 768 bytes.
+
+
+\page LIBUSE Library Usage
+
+\section InterfaceDescription API Files
+
+All API header files are located in the folder /include of the release package. All header files
+are provided for usage in C/C++ programs. The AAC encoder library API functions are located at
+aacenc_lib.h.
+
+In binary releases the encoder core resides in statically linkable libraries called for example
+libAACenc.a/libFDK.a (LINUX) or FDK_fastaaclib.lib (MS Visual C++) for the plain AAC-LC core encoder
+and libSBRenc.a (LINUX) or FDK_sbrEncLib.lib (MS Visual C++) for the SBR (Spectral Band
+Replication) and PS (Parametric Stereo) modules.
+
+\section CallingSequence Calling Sequence
+
+For encoding of ISO/MPEG-2/4 AAC bitstreams the following sequence is mandatory. Input read and output
+write functions as well as the corresponding open and close functions are left out, since they may be
+implemented differently according to the user's specific requirements. The example implementation in
+main.cpp uses file-based input/output.
+
+-# Call aacEncOpen() to allocate encoder instance with required \ref encOpen "configuration".\n
+\dontinclude main.cpp
+\skipline hAacEncoder =
+\skipline aacEncOpen
+-# Call aacEncoder_SetParam() for each parameter to be set. AOT, samplingrate, channelMode, bitrate and transport type are \ref encParams "mandatory".
+\code
+    ErrorStatus = aacEncoder_SetParam(hAacEncoder, parameter, value);
+\endcode
+-# Call aacEncEncode() with NULL parameters to \ref encReconf "initialize" encoder instance with present parameter set.
+\skipline aacEncEncode
+-# Call aacEncInfo() to retrieve a configuration data block to be transmitted out of band. This is required when using RFC3640 or RFC3016 like transport.
+\dontinclude main.cpp
+\skipline encInfo
+\skipline aacEncInfo
+-# Encode input audio data in loop.
+\skip Encode as long as
+\skipline do
+\until {
+Feed \ref feedInBuf "input buffer" with new audio data and provide input/output \ref bufDes "arguments" to aacEncEncode().
+\skipline aacEncEncode
+\until ;
+Write \ref writeOutData "output data" to file or audio device. \skipline while
+-# Call aacEncClose() and destroy encoder instance.
+\skipline aacEncClose
+
+\section encOpen Encoder Instance Allocation
+
+The assignment of the aacEncOpen() function is very flexible and can be used in the following way.
+- If the amount of memory consumption is not an issue, the encoder instance can be allocated
+for the maximum number of possible audio channels (for example 6 or 8) with the full functional range supported by the library.
+This is the default open procedure for the AAC encoder if memory consumption does not need to be minimized.
+\code aacEncOpen(&hAacEncoder,0,0) \endcode
+- If the required MPEG-4 AOTs do not call for the full functional range of the library, encoder modules can be allocated selectively.
+\verbatim
+------------------------------------------------------
+ AAC | SBR |  PS | MD |         FLAGS         | value
+-----+-----+-----+----+-----------------------+-------
+  X  |  -  |  -  |  - | (0x01)                |  0x01
+  X  |  X  |  -  |  - | (0x01|0x02)           |  0x03
+  X  |  X  |  X  |  - | (0x01|0x02|0x04)      |  0x07
+  X  |  -  |  -  |  X | (0x01          |0x10) |  0x11
+  X  |  X  |  -  |  X | (0x01|0x02     |0x10) |  0x13
+  X  |  X  |  X  |  X | (0x01|0x02|0x04|0x10) |  0x17
+------------------------------------------------------
+ - AAC: Allocate AAC Core Encoder module.
+ - SBR: Allocate Spectral Band Replication module.
+ - PS: Allocate Parametric Stereo module.
+ - MD: Allocate Meta Data module within AAC encoder.
+\endverbatim
+\code aacEncOpen(&hAacEncoder,value,0) \endcode
+- Specifying the maximum number of channels to be supported in the encoder instance can be done as follows.
+ - For example allocate an encoder instance which supports 2 channels for all supported AOTs.
+   The library itself may be capable of encoding up to 6 or 8 channels but in this example only 2 channel encoding is required and thus only buffers for 2 channels are allocated to save data memory.
+\code aacEncOpen(&hAacEncoder,0,2) \endcode
+ - Additionally the maximum number of supported channels in the SBR module can be denoted separately.\n
+   In this example the encoder instance provides a maximum of 6 channels out of which up to 2 channels support SBR.
+   This encoder instance can produce for example 5.1 channel AAC-LC streams or stereo HE-AAC (v2) streams.
+   HE-AAC 5.1 multi channel is not possible since only 2 out of 6 channels support SBR, which saves data memory.
+\code aacEncOpen(&hAacEncoder,0,6|(2<<8)) \endcode
+\n
+
+\section bufDes Input/Output Arguments
+
+\subsection allocIOBufs Provide Buffer Descriptors
+In the present encoder API, the input and output buffers are described with \ref AACENC_BufDesc "buffer descriptors". This mechanism allows a flexible handling
+of input and output buffers without impact to the actual encoding call. Optional buffers are necessary e.g. for ancillary data, meta data input or additional output
+buffers describing superframing data in DAB+ or DRM+.\n
+At least one input buffer for audio input data and one output buffer for bitstream data must be allocated. The input buffer size can be a user defined multiple
+of the number of input channels. PCM input data will be copied from the user defined PCM buffer to an internal input buffer and so input data can be less than one AAC audio frame.
+The output buffer size should be 6144 bits per channel excluding the LFE channel.
+If the output data does not fit into the provided buffer, an AACENC_ERROR will be returned by aacEncEncode().
+\dontinclude main.cpp
+\skipline inputBuffer
+\until outputBuffer
+All input and output buffer must be clustered in input and output buffer arrays.
+\skipline inBuffer
+\until outBufferElSize
+Allocate buffer descriptors
+\skipline AACENC_BufDesc
+\skipline AACENC_BufDesc
+Initialize input buffer descriptor
+\skipline inBufDesc
+\until bufElSizes
+Initialize output buffer descriptor
+\skipline outBufDesc
+\until bufElSizes
+
+\subsection argLists Provide Input/Output Argument Lists
+The input and output arguments of an aacEncEncode() call are described in argument structures.
+\dontinclude main.cpp
+\skipline AACENC_InArgs
+\skipline AACENC_OutArgs
+
+\section feedInBuf Feed Input Buffer
+The input buffer should be handled as a modulo buffer. New audio data in the form of pulse-code-
+modulated samples (PCM) must be read from external and be fed to the input buffer depending on its
+fill level. The required sample bitrate (represented by the data type INT_PCM which is 16, 24 or 32
+bits wide) is fixed and depends on library configuration (usually 16 bit).
+
+\dontinclude main.cpp
+\skipline WAV_InputRead
+\until ;
+After the encoder's internal buffer is fed with incoming audio samples, and aacEncEncode()
+processed the new input data, update/move remaining samples in input buffer, simulating a modulo buffer:
+\skipline outargs.numInSamples>0
+\until }
+
+\section writeOutData Output Bitstream Data
+If any AAC bitstream data is available, write it to output file or device. This can be done once the
+following condition is true:
+\dontinclude main.cpp
+\skip Valid bitstream available
+\skipline outargs
+
+\skipline outBytes>0
+
+If you use file I/O then for example call mpegFileWrite_Write() from the library libMpegFileWrite
+
+\dontinclude main.cpp
+\skipline mpegFileWrite_Write
+
+\section cfgMetaData Meta Data Configuration
+
+If the present library is configured with Metadata support, it is possible to insert meta data side info into the generated
+audio bitstream while encoding.
+
+To work with meta data the encoder instance has to be \ref encOpen "allocated" with meta data support. The meta data mode must be be configured with
+the ::AACENC_METADATA_MODE parameter and aacEncoder_SetParam() function.
+\code aacEncoder_SetParam(hAacEncoder, AACENC_METADATA_MODE, 0-2); \endcode
+
+This configuration indicates how to embed meta data into bitstrem. Either no insertion, MPEG or ETSI style.
+The meta data itself must be specified within the meta data setup structure AACENC_MetaData.
+
+Changing one of the AACENC_MetaData setup parameters can be achieved from outside the library within ::IN_METADATA_SETUP input
+buffer. There is no need to supply meta data setup structure every frame. If there is no new meta setup data available, the
+encoder uses the previous setup or the default configuration in initial state.
+
+In general the audio compressor and limiter within the encoder library can be configured with the ::AACENC_METADATA_DRC_PROFILE parameter
+AACENC_MetaData::drc_profile and and AACENC_MetaData::comp_profile.
+\n
+
+\section encReconf Encoder Reconfiguration
+
+The encoder library allows reconfiguration of the encoder instance with new settings
+continuously between encoding frames. Each parameter to be changed must be set with
+a single aacEncoder_SetParam() call. The internal status of each parameter can be
+retrieved with an aacEncoder_GetParam() call.\n
+There is no stand-alone reconfiguration function available. When parameters were
+modified from outside the library, an internal control mechanism triggers the necessary
+reconfiguration process which will be applied at the beginning of the following
+aacEncEncode() call. This state can be observed from external via the AACENC_INIT_STATUS
+and aacEncoder_GetParam() function. The reconfiguration process can also be applied
+immediately when all parameters of an aacEncEncode() call are NULL with a valid encoder
+handle.\n\n
+The internal reconfiguration process can be controlled from extern with the following access.
+\code aacEncoder_SetParam(hAacEncoder, AACENC_CONTROL_STATE, AACENC_CTRLFLAGS); \endcode
+
+
+\section encParams Encoder Parametrization
+
+All parameteres listed in ::AACENC_PARAM can be modified within an encoder instance.
+
+\subsection encMandatory Mandatory Encoder Parameters
+The following parameters must be specified when the encoder instance is initialized.
+\code
+aacEncoder_SetParam(hAacEncoder, AACENC_AOT, value);
+aacEncoder_SetParam(hAacEncoder, AACENC_BITRATE, value);
+aacEncoder_SetParam(hAacEncoder, AACENC_SAMPLERATE, value);
+aacEncoder_SetParam(hAacEncoder, AACENC_CHANNELMODE, value);
+\endcode
+Beyond that is an internal auto mode which preinitizializes the ::AACENC_BITRATE parameter
+if the parameter was not set from extern. The bitrate depends on the number of effective
+channels and sampling rate and is determined as follows.
+\code
+AAC-LC (AOT_AAC_LC): 1.5 bits per sample
+HE-AAC (AOT_SBR): 0.625 bits per sample (dualrate sbr)
+HE-AAC (AOT_SBR): 1.125 bits per sample (downsampled sbr)
+HE-AAC v2 (AOT_PS): 0.5 bits per sample
+\endcode
+
+\subsection channelMode Channel Mode Configuration
+The input audio data is described with the ::AACENC_CHANNELMODE parameter in the
+aacEncoder_SetParam() call. It is not possible to use the encoder instance with a 'number of
+input channels' argument. Instead, the channelMode must be set as follows.
+\code aacEncoder_SetParam(hAacEncoder, AACENC_CHANNELMODE, value); \endcode
+The parameter is specified in ::CHANNEL_MODE and can be mapped from the number of input channels
+in the following way.
+\dontinclude main.cpp
+\skip CHANNEL_MODE chMode = MODE_INVALID;
+\until return
+
+\subsection encQual Audio Quality Considerations
+The default encoder configuration is suggested to be used. Encoder tools such as TNS and PNS
+are activated by default and are internally controlled (see \ref BEHAVIOUR_TOOLS).
+
+There is an additional quality parameter called ::AACENC_AFTERBURNER. In the default
+configuration this quality switch is deactivated because it would cause a workload
+increase which might be significant. If workload is not an issue in the application
+we recommended to activate this feature.
+\code aacEncoder_SetParam(hAacEncoder, AACENC_AFTERBURNER, 1); \endcode
+
+\subsection encELD ELD Auto Configuration Mode
+For ELD configuration a so called auto configurator is available which configures SBR and the SBR ratio by itself.
+The configurator is used when the encoder parameter ::AACENC_SBR_MODE and ::AACENC_SBR_RATIO are not set explicitely.
+
+Based on sampling rate and chosen bitrate per channel a reasonable SBR configuration will be used.
+\verbatim
+------------------------------------------------------------
+  Sampling Rate  | Channel Bitrate |  SBR |       SBR Ratio
+-----------------+-----------------+------+-----------------
+ ]min, 16] kHz   |     min - 27999 |   on | downsampled SBR
+                 |   28000 -   max |  off |             ---
+-----------------+-----------------+------+-----------------
+ ]16 - 24] kHz   |     min - 39999 |   on | downsampled SBR
+                 |   40000 -   max |  off |             ---
+-----------------+-----------------+------+-----------------
+ ]24 - 32] kHz   |     min - 27999 |   on |    dualrate SBR
+                 |   28000 - 55999 |   on | downsampled SBR
+                 |   56000 -   max |  off |             ---
+-----------------+-----------------+------+-----------------
+ ]32 - 44.1] kHz |     min - 63999 |   on |    dualrate SBR
+                 |   64000 -   max |  off |             ---
+-----------------+-----------------+------+-----------------
+ ]44.1 - 48] kHz |     min - 63999 |   on |    dualrate SBR
+                 |   64000 - max   |  off |             ---
+------------------------------------------------------------
+\endverbatim
+
+
+\section audiochCfg Audio Channel Configuration
+The MPEG standard refers often to the so-called Channel Configuration. This Channel Configuration is used for a fixed Channel
+Mapping. The configurations 1-7 are predefined in MPEG standard and used for implicit signalling within the encoded bitstream.
+For user defined Configurations the Channel Configuration is set to 0 and the Channel Mapping must be explecitly described with an appropriate
+Program Config Element. The present Encoder implementation does not allow the user to configure this Channel Configuration from
+extern. The Encoder implementation supports fixed Channel Modes which are mapped to Channel Configuration as follow.
+\verbatim
+-------------------------------------------------------------------------------
+ ChannelMode           | ChCfg  | front_El      | side_El  | back_El  | lfe_El
+-----------------------+--------+---------------+----------+----------+--------
+MODE_1                 |      1 | SCE           |          |          |
+MODE_2                 |      2 | CPE           |          |          |
+MODE_1_2               |      3 | SCE, CPE      |          |          |
+MODE_1_2_1             |      4 | SCE, CPE      |          | SCE      |
+MODE_1_2_2             |      5 | SCE, CPE      |          | CPE      |
+MODE_1_2_2_1           |      6 | SCE, CPE      |          | CPE      | LFE
+MODE_1_2_2_2_1         |      7 | SCE, CPE, CPE |          | CPE      | LFE
+-----------------------+--------+---------------+----------+----------+--------
+MODE_7_1_REAR_SURROUND |      0 | SCE, CPE      |          | CPE, CPE | LFE
+MODE_7_1_FRONT_CENTER  |      0 | SCE, CPE, CPE |          | CPE      | LFE
+-------------------------------------------------------------------------------
+ - SCE: Single Channel Element.
+ - CPE: Channel Pair.
+ - SCE: Low Frequency Element.
+\endverbatim
+
+Moreover, the Table describes all fixed Channel Elements for each Channel Mode which are assigned to a speaker arrangement. The
+arrangement includes front, side, back and lfe Audio Channel Elements.\n
+This mapping of Audio Channel Elements is defined in MPEG standard for Channel Config 1-7. The Channel assignment for MODE_1_1,
+MODE_2_2 and MODE_2_1 is used from the ARIB standard. All other configurations are defined as suggested in MPEG.\n
+In case of Channel Config 0 or writing matrix mixdown coefficients, the encoder enables the writing of Program Config Element
+itself as described in \ref encPCE. The configuration used in Program Config Element refers to the denoted Table.\n
+Beside the Channel Element assignment the Channel Modes are resposible for audio input data channel mapping. The Channel Mapping
+of the audio data depends on the selected ::AACENC_CHANNELORDER which can be MPEG or WAV like order.\n
+Following Table describes the complete channel mapping for both Channel Order configurations.
+\verbatim
+---------------------------------------------------------------------------------------
+ChannelMode            |  MPEG-Channelorder            |  WAV-Channelorder
+-----------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
+MODE_1                 | 0 |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |
+MODE_2                 | 0 | 1 |   |   |   |   |   |   | 0 | 1 |   |   |   |   |   |
+MODE_1_2               | 0 | 1 | 2 |   |   |   |   |   | 2 | 0 | 1 |   |   |   |   |
+MODE_1_2_1             | 0 | 1 | 2 | 3 |   |   |   |   | 2 | 0 | 1 | 3 |   |   |   |
+MODE_1_2_2             | 0 | 1 | 2 | 3 | 4 |   |   |   | 2 | 0 | 1 | 3 | 4 |   |   |
+MODE_1_2_2_1           | 0 | 1 | 2 | 3 | 4 | 5 |   |   | 2 | 0 | 1 | 4 | 5 | 3 |   |
+MODE_1_2_2_2_1         | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 2 | 6 | 7 | 0 | 1 | 4 | 5 | 3
+-----------------------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
+MODE_7_1_REAR_SURROUND | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 2 | 0 | 1 | 6 | 7 | 4 | 5 | 3
+MODE_7_1_FRONT_CENTER  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 2 | 6 | 7 | 0 | 1 | 4 | 5 | 3
+---------------------------------------------------------------------------------------
+\endverbatim
+
+The denoted mapping is important for correct audio channel assignment when using MPEG or WAV ordering. The incoming audio
+channels are distributed MPEG like starting at the front channels and ending at the back channels. The distribution is used as
+described in Table concering Channel Config and fix channel elements. Please see the following example for clarification.
+
+\verbatim
+Example: MODE_1_2_2_1 - WAV-Channelorder 5.1
+------------------------------------------
+ Input Channel      | Coder Channel
+--------------------+---------------------
+ 2 (front center)   | 0 (SCE channel)
+ 0 (left center)    | 1 (1st of 1st CPE)
+ 1 (right center)   | 2 (2nd of 1st CPE)
+ 4 (left surround)  | 3 (1st of 2nd CPE)
+ 5 (right surround) | 4 (2nd of 2nd CPE)
+ 3 (LFE)            | 5 (LFE)
+------------------------------------------
+\endverbatim
+
+
+\section suppBitrates Supported Bitrates
+
+The FDK AAC Encoder provides a wide range of supported bitrates.
+The minimum and maximum allowed bitrate depends on the Audio Object Type. For AAC-LC the minimum
+bitrate is the bitrate that is required to write the most basic and minimal valid bitstream.
+It consists of the bitstream format header information and other static/mandatory information
+within the AAC payload. The maximum AAC framesize allowed by the MPEG-4 standard
+determines the maximum allowed bitrate for AAC-LC. For HE-AAC and HE-AAC v2 a library internal
+look-up table is used.
+
+A good working point in terms of audio quality, sampling rate and bitrate, is at 1 to 1.5
+bits/audio sample for AAC-LC, 0.625 bits/audio sample for dualrate HE-AAC, 1.125 bits/audio sample
+for downsampled HE-AAC and 0.5 bits/audio sample for HE-AAC v2.
+For example for one channel with a sampling frequency of 48 kHz, the range from
+48 kbit/s to 72 kbit/s achieves reasonable audio quality for AAC-LC.
+
+For HE-AAC and HE-AAC v2 the lowest possible audio input sampling frequency is 16 kHz because then the
+AAC-LC core encoder operates in dual rate mode at its lowest possible sampling frequency, which is 8 kHz.
+HE-AAC v2 requires stereo input audio data.
+
+Please note that in HE-AAC or HE-AAC v2 mode the encoder supports much higher bitrates than are
+appropriate for HE-AAC or HE-AAC v2. For example, at a bitrate of more than 64 kbit/s for a stereo
+audio signal at 44.1 kHz it usually makes sense to use AAC-LC, which will produce better audio
+quality at that bitrate than HE-AAC or HE-AAC v2.
+
+\section reommendedConfig Recommended Sampling Rate and Bitrate Combinations
+
+The following table provides an overview of recommended encoder configuration parameters
+which we determined by virtue of numerous listening tests.
+
+\subsection reommendedConfigLC AAC-LC, HE-AAC, HE-AACv2 in Dualrate SBR mode.
+\verbatim
+-----------------------------------------------------------------------------------
+Audio Object Type  |  Bit Rate Range  |            Supported  | Preferred  | No. of
+                   |         [bit/s]  |       Sampling Rates  |    Sampl.  |  Chan.
+                   |                  |                [kHz]  |      Rate  |
+                   |                  |                       |     [kHz]  |
+-------------------+------------------+-----------------------+------------+-------
+AAC LC + SBR + PS  |   8000 -  11999  |         22.05, 24.00  |     24.00  |      2
+AAC LC + SBR + PS  |  12000 -  17999  |                32.00  |     32.00  |      2
+AAC LC + SBR + PS  |  18000 -  39999  |  32.00, 44.10, 48.00  |     44.10  |      2
+AAC LC + SBR + PS  |  40000 -  56000  |  32.00, 44.10, 48.00  |     48.00  |      2
+-------------------+------------------+-----------------------+------------+-------
+AAC LC + SBR       |   8000 -  11999  |         22.05, 24.00  |     24.00  |      1
+AAC LC + SBR       |  12000 -  17999  |                32.00  |     32.00  |      1
+AAC LC + SBR       |  18000 -  39999  |  32.00, 44.10, 48.00  |     44.10  |      1
+AAC LC + SBR       |  40000 -  56000  |  32.00, 44.10, 48.00  |     48.00  |      1
+AAC LC + SBR       |  16000 -  27999  |  32.00, 44.10, 48.00  |     32.00  |      2
+AAC LC + SBR       |  28000 -  63999  |  32.00, 44.10, 48.00  |     44.10  |      2
+AAC LC + SBR       |  64000 - 128000  |  32.00, 44.10, 48.00  |     48.00  |      2
+-------------------+------------------+-----------------------+------------+-------
+AAC LC + SBR       |  64000 -  69999  |  32.00, 44.10, 48.00  |     32.00  | 5, 5.1
+AAC LC + SBR       |  70000 - 159999  |  32.00, 44.10, 48.00  |     44.10  | 5, 5.1
+AAC LC + SBR       | 160000 - 245999  |  32.00, 44.10, 48.00  |     48.00  |      5
+AAC LC + SBR       | 160000 - 265999  |  32.00, 44.10, 48.00  |     48.00  |    5.1
+-------------------+------------------+-----------------------+------------+-------
+AAC LC             |   8000 -  15999  | 11.025, 12.00, 16.00  |     12.00  |      1
+AAC LC             |  16000 -  23999  |                16.00  |     16.00  |      1
+AAC LC             |  24000 -  31999  |  16.00, 22.05, 24.00  |     24.00  |      1
+AAC LC             |  32000 -  55999  |                32.00  |     32.00  |      1
+AAC LC             |  56000 - 160000  |  32.00, 44.10, 48.00  |     44.10  |      1
+AAC LC             | 160001 - 288000  |                48.00  |     48.00  |      1
+-------------------+------------------+-----------------------+------------+-------
+AAC LC             |  16000 -  23999  | 11.025, 12.00, 16.00  |     12.00  |      2
+AAC LC             |  24000 -  31999  |                16.00  |     16.00  |      2
+AAC LC             |  32000 -  39999  |  16.00, 22.05, 24.00  |     22.05  |      2
+AAC LC             |  40000 -  95999  |                32.00  |     32.00  |      2
+AAC LC             |  96000 - 111999  |  32.00, 44.10, 48.00  |     32.00  |      2
+AAC LC             | 112000 - 320001  |  32.00, 44.10, 48.00  |     44.10  |      2
+AAC LC             | 320002 - 576000  |                48.00  |     48.00  |      2
+-------------------+------------------+-----------------------+------------+-------
+AAC LC             | 160000 - 239999  |                32.00  |     32.00  | 5, 5.1
+AAC LC             | 240000 - 279999  |  32.00, 44.10, 48.00  |     32.00  | 5, 5.1
+AAC LC             | 280000 - 800000  |  32.00, 44.10, 48.00  |     44.10  | 5, 5.1
+-----------------------------------------------------------------------------------
+\endverbatim \n
+
+\subsection reommendedConfigLD AAC-LD, AAC-ELD, AAC-ELD with SBR in Dualrate SBR mode.
+\verbatim
+-----------------------------------------------------------------------------------
+Audio Object Type  |  Bit Rate Range  |            Supported  | Preferred  | No. of
+                   |         [bit/s]  |       Sampling Rates  |    Sampl.  |  Chan.
+                   |                  |                [kHz]  |      Rate  |
+                   |                  |                       |     [kHz]  |
+-------------------+------------------+-----------------------+------------+-------
+ELD + SBR          |  18000 -  24999  |        32.00 - 44.10  |     32.00  |      1
+ELD + SBR          |  25000 -  31999  |        32.00 - 48.00  |     32.00  |      1
+ELD + SBR          |  32000 -  64000  |        32.00 - 48.00  |     48.00  |      1
+-------------------+------------------+-----------------------+------------+-------
+ELD + SBR          |  32000 -  51999  |        32.00 - 48.00  |     44.10  |      2
+ELD + SBR          |  52000 - 128000  |        32.00 - 48.00  |     48.00  |      2
+-------------------+------------------+-----------------------+------------+-------
+ELD + SBR          |  72000 - 160000  |        44.10 - 48.00  |     48.00  |      3
+-------------------+------------------+-----------------------+------------+-------
+ELD + SBR          |  96000 - 212000  |        44.10 - 48.00  |     48.00  |      4
+-------------------+------------------+-----------------------+------------+-------
+ELD + SBR          | 120000 - 246000  |        44.10 - 48.00  |     48.00  |      5
+-------------------+------------------+-----------------------+------------+-------
+ELD + SBR          | 120000 - 266000  |        44.10 - 48.00  |     48.00  |    5.1
+-------------------+------------------+-----------------------+------------+-------
+LD, ELD            |  16000 -  19999  |        16.00 - 24.00  |     16.00  |      1
+LD, ELD            |  20000 -  39999  |        16.00 - 32.00  |     24.00  |      1
+LD, ELD            |  40000 -  49999  |        22.05 - 32.00  |     32.00  |      1
+LD, ELD            |  50000 -  61999  |        24.00 - 44.10  |     32.00  |      1
+LD, ELD            |  62000 -  84999  |        32.00 - 48.00  |     44.10  |      1
+LD, ELD            |  85000 - 192000  |        44.10 - 48.00  |     48.00  |      1
+-------------------+------------------+-----------------------+------------+-------
+LD, ELD            |  64000 -  75999  |        24.00 - 32.00  |     32.00  |      2
+LD, ELD            |  76000 -  97999  |        24.00 - 44.10  |     32.00  |      2
+LD, ELD            |  98000 - 135999  |        32.00 - 48.00  |     44.10  |      2
+LD, ELD            | 136000 - 384000  |        44.10 - 48.00  |     48.00  |      2
+-------------------+------------------+-----------------------+------------+-------
+LD, ELD            |  96000 - 113999  |        24.00 - 32.00  |     32.00  |      3
+LD, ELD            | 114000 - 146999  |        24.00 - 44.10  |     32.00  |      3
+LD, ELD            | 147000 - 203999  |        32.00 - 48.00  |     44.10  |      3
+LD, ELD            | 204000 - 576000  |        44.10 - 48.00  |     48.00  |      3
+-------------------+------------------+-----------------------+------------+-------
+LD, ELD            | 128000 - 151999  |        24.00 - 32.00  |     32.00  |      4
+LD, ELD            | 152000 - 195999  |        24.00 - 44.10  |     32.00  |      4
+LD, ELD            | 196000 - 271999  |        32.00 - 48.00  |     44.10  |      4
+LD, ELD            | 272000 - 768000  |        44.10 - 48.00  |     48.00  |      4
+-------------------+------------------+-----------------------+------------+-------
+LD, ELD            | 160000 - 189999  |        24.00 - 32.00  |     32.00  |      5
+LD, ELD            | 190000 - 244999  |        24.00 - 44.10  |     32.00  |      5
+LD, ELD            | 245000 - 339999  |        32.00 - 48.00  |     44.10  |      5
+LD, ELD            | 340000 - 960000  |        44.10 - 48.00  |     48.00  |      5
+-----------------------------------------------------------------------------------
+\endverbatim \n
+
+\subsection reommendedConfigELD AAC-ELD with SBR in Downsampled SBR mode.
+\verbatim
+-----------------------------------------------------------------------------------
+Audio Object Type  |  Bit Rate Range  |            Supported  | Preferred  | No. of
+                   |         [bit/s]  |       Sampling Rates  |    Sampl.  |  Chan.
+                   |                  |                [kHz]  |      Rate  |
+                   |                  |                       |     [kHz]  |
+-------------------+------------------+-----------------------+------------+-------
+ELD + SBR          |  18000 -  24999  |        16.00 - 22.05  |     22.05  |      1
+(downsampled SBR)  |  25000 -  35999  |        22.05 - 32.00  |     24.00  |      1
+                   |  36000 -  64000  |        32.00 - 48.00  |     32.00  |      1
+-----------------------------------------------------------------------------------
+\endverbatim \n
+
+
+\page ENCODERBEHAVIOUR Encoder Behaviour
+
+\section BEHAVIOUR_BANDWIDTH Bandwidth
+
+The FDK AAC encoder usually does not use the full frequency range of the input signal, but restricts the bandwidth
+according to certain library-internal settings. They can be changed in the table "bandWidthTable" in the
+file bandwidth.cpp (if available).
+
+The encoder API provides the ::AACENC_BANDWIDTH parameter to adjust the bandwidth explicitly.
+\code
+aacEncoder_SetParam(hAacEncoder, AACENC_BANDWIDTH, value);
+\endcode
+
+However it is not recommended to change these settings, because they are based on numerious listening
+tests and careful tweaks to ensure the best overall encoding quality.
+
+Theoretically a signal of for example 48 kHz can contain frequencies up to 24 kHz, but to use this full range
+in an audio encoder usually does not make sense. Usually the encoder has a very limited amount of
+bits to spend (typically 128 kbit/s for stereo 48 kHz content) and to allow full range bandwidth would
+waste a lot of these bits for frequencies the human ear is hardly able to perceive anyway, if at all. Hence it
+is wise to use the available bits for the really important frequency range and just skip the rest.
+At lower bitrates (e. g. <= 80 kbit/s for stereo 48 kHz content) the encoder will choose an even smaller
+bandwidth, because an encoded signal with smaller bandwidth and hence less artifacts sounds better than a signal
+with higher bandwidth but then more coding artefacts across all frequencies. These artefacts would occur if
+small bitrates and high bandwidths are chosen because the available bits are just not enough to encode all
+frequencies well.
+
+Unfortunately some people evaluate encoding quality based on possible bandwidth as well, but it is a two-sided
+sword considering the trade-off described above.
+
+Another aspect is workload consumption. The higher the allowed bandwidth, the more frequency lines have to be
+processed, which in turn increases the workload.
+
+\section FRAMESIZES_AND_BIT_RESERVOIR Frame Sizes & Bit Reservoir
+
+For AAC there is a difference between constant bit rate and constant frame
+length due to the so-called bit reservoir technique, which allows the encoder to use less
+bits in an AAC frame for those audio signal sections which are easy to encode,
+and then spend them at a later point in
+time for more complex audio sections. The extent to which this "bit exchange"
+is done is limited to allow for reliable and relatively low delay real time
+streaming.
+Over a longer period in time the bitrate will be constant in the AAC constant
+bitrate mode, e.g. for ISDN transmission. This means that in AAC each bitstream
+frame will in general have a different length in bytes but over time it
+will reach the target bitrate. One could also make an MPEG compliant
+AAC encoder which always produces constant length packages for each AAC frame,
+but the audio quality would be considerably worse since the bit reservoir
+technique would have to be switched off completely. A higher bit rate would have
+to be used to get the same audio quality as with an enabled bit reservoir.
+
+The maximum AAC frame length, regardless of the available bit reservoir, is defined
+as 6144 bits per channel.
+
+For mp3 by the way, the same bit reservoir technique exists, but there each bit
+stream frame has a constant length for a given bit rate (ignoring the
+padding byte). In mp3 there is a so-called "back pointer" which tells
+the decoder which bits belong to the current mp3 frame - and in general some or
+many bits have been transmitted in an earlier mp3 frame. Basically this leads to
+the same "bit exchange between mp3 frames" as in AAC but with virtually constant
+length frames.
+
+This variable frame length at "constant bit rate" is not something special
+in this Fraunhofer IIS AAC encoder. AAC has been designed in that way.
+
+\subsection BEHAVIOUR_ESTIM_AVG_FRAMESIZES Estimating Average Frame Sizes
+
+A HE-AAC v1 or v2 audio frame contains 2048 PCM samples per channel (there is
+also one mode with 1920 samples per channel but this is only for special purposes
+such as DAB+ digital radio).
+
+The number of HE-AAC frames \f$N\_FRAMES\f$ per second at 44.1 kHz is:
+
+\f[
+N\_FRAMES = 44100 / 2048 = 21.5332
+\f]
+
+At a bit rate of 8 kbps the average number of bits per frame \f$N\_BITS\_PER\_FRAME\f$ is:
+
+\f[
+N\_BITS\_PER\_FRAME = 8000 / 21.5332 = 371.52
+\f]
+
+which is about 46.44 bytes per encoded frame.
+
+At a bit rate of 32 kbps, which is quite high for single channel HE-AAC v1, it is:
+
+\f[
+N\_BITS\_PER\_FRAME = 32000 / 21.5332 = 1486
+\f]
+
+which is about 185.76 bytes per encoded frame.
+
+These bits/frame figures are average figures where each AAC frame generally has a different
+size in bytes. To calculate the same for AAC-LC just use 1024 instead of 2048 PCM samples per
+frame and channel.
+For AAC-LD/ELD it is either 480 or 512 PCM samples per frame and channel.
+
+
+\section BEHAVIOUR_TOOLS Encoder Tools
+
+The AAC encoder supports TNS, PNS, MS, Intensity and activates these tools depending on the audio signal and
+the encoder configuration (i.e. bitrate or AOT). It is not required to configure these tools manually.
+
+PNS improves encoding quality only for certain bitrates. Therefore it makes sense to activate PNS only for
+these bitrates and save the processing power required for PNS (about 10 % of the encoder) when using other
+bitrates. This is done automatically inside the encoder library. PNS is disabled inside the encoder library if
+an MPEG-2 AOT is choosen since PNS is an MPEG-4 AAC feature.
+
+If SBR is activated, the encoder automatically deactivates PNS internally. If TNS is disabled but PNS is allowed,
+the encoder deactivates PNS calculation internally.
+
+*/
+
+#ifndef _AAC_ENC_LIB_H_
+#define _AAC_ENC_LIB_H_
+
+#include "machine_type.h"
+#include "FDK_audio.h"
+
+#define AACENCODER_LIB_VL0 3
+#define AACENCODER_LIB_VL1 4
+#define AACENCODER_LIB_VL2 12
+
+/**
+ *  AAC encoder error codes.
+ */
+typedef enum {
+    AACENC_OK                     = 0x0000,  /*!< No error happened. All fine. */
+
+    AACENC_INVALID_HANDLE         = 0x0020,  /*!< Handle passed to function call was invalid. */
+    AACENC_MEMORY_ERROR           = 0x0021,  /*!< Memory allocation failed. */
+    AACENC_UNSUPPORTED_PARAMETER  = 0x0022,  /*!< Parameter not available. */
+    AACENC_INVALID_CONFIG         = 0x0023,  /*!< Configuration not provided. */
+
+    AACENC_INIT_ERROR             = 0x0040,  /*!< General initialization error. */
+    AACENC_INIT_AAC_ERROR         = 0x0041,  /*!< AAC library initialization error. */
+    AACENC_INIT_SBR_ERROR         = 0x0042,  /*!< SBR library initialization error. */
+    AACENC_INIT_TP_ERROR          = 0x0043,  /*!< Transport library initialization error. */
+    AACENC_INIT_META_ERROR        = 0x0044,  /*!< Meta data library initialization error. */
+
+    AACENC_ENCODE_ERROR           = 0x0060,  /*!< The encoding process was interrupted by an unexpected error. */
+
+    AACENC_ENCODE_EOF             = 0x0080   /*!< End of file reached. */
+
+} AACENC_ERROR;
+
+
+/**
+ *  AAC encoder buffer descriptors identifier.
+ *  This identifier are used within buffer descriptors AACENC_BufDesc::bufferIdentifiers.
+ */
+typedef enum {
+    /* Input buffer identifier. */
+    IN_AUDIO_DATA      = 0,                  /*!< Audio input buffer, interleaved INT_PCM samples. */
+    IN_ANCILLRY_DATA   = 1,                  /*!< Ancillary data to be embedded into bitstream. */
+    IN_METADATA_SETUP  = 2,                  /*!< Setup structure for embedding meta data. */
+
+    /* Output buffer identifier. */
+    OUT_BITSTREAM_DATA = 3,                  /*!< Buffer holds bitstream output data. */
+    OUT_AU_SIZES       = 4                   /*!< Buffer contains sizes of each access unit. This information
+                                                  is necessary for superframing. */
+
+} AACENC_BufferIdentifier;
+
+
+/**
+ *  AAC encoder handle.
+ */
+typedef struct AACENCODER *HANDLE_AACENCODER;
+
+
+/**
+ *  Provides some info about the encoder configuration.
+ */
+typedef struct {
+
+    UINT                maxOutBufBytes;      /*!< Maximum number of encoder bitstream bytes within one frame.
+                                                  Size depends on maximum number of supported channels in encoder instance.
+                                                  For superframing (as used for example in DAB+), size has to be a multiple accordingly. */
+
+    UINT                maxAncBytes;         /*!< Maximum number of ancillary data bytes which can be inserted into
+                                                  bitstream within one frame. */
+
+    UINT                inBufFillLevel;      /*!< Internal input buffer fill level in samples per channel. This parameter
+                                                  will automatically be cleared if samplingrate or channel(Mode/Order) changes. */
+
+    UINT                inputChannels;       /*!< Number of input channels expected in encoding process. */
+
+    UINT                frameLength;         /*!< Amount of input audio samples consumed each frame per channel, depending
+                                                  on audio object type configuration. */
+
+    UINT                encoderDelay;        /*!< Codec delay in PCM samples/channel. Depends on framelength and AOT. Does not
+                                                  include framing delay for filling up encoder PCM input buffer. */
+
+    UCHAR               confBuf[64];         /*!< Configuration buffer in binary format as an AudioSpecificConfig
+                                                  or StreamMuxConfig according to the selected transport type. */
+
+    UINT                confSize;            /*!< Number of valid bytes in confBuf. */
+
+} AACENC_InfoStruct;
+
+
+/**
+ *  Describes the input and output buffers for an aacEncEncode() call.
+ */
+typedef struct {
+    INT                 numBufs;             /*!< Number of buffers. */
+    void              **bufs;                /*!< Pointer to vector containing buffer addresses. */
+    INT                *bufferIdentifiers;   /*!< Identifier of each buffer element. See ::AACENC_BufferIdentifier. */
+    INT                *bufSizes;            /*!< Size of each buffer in 8-bit bytes. */
+    INT                *bufElSizes;          /*!< Size of each buffer element in bytes. */
+
+} AACENC_BufDesc;
+
+
+/**
+ *  Defines the input arguments for an aacEncEncode() call.
+ */
+typedef struct {
+    INT                 numInSamples;        /*!< Number of valid input audio samples (multiple of input channels). */
+    INT                 numAncBytes;         /*!< Number of ancillary data bytes to be encoded. */
+
+} AACENC_InArgs;
+
+
+/**
+ *  Defines the output arguments for an aacEncEncode() call.
+ */
+typedef struct {
+    INT                 numOutBytes;         /*!< Number of valid bitstream bytes generated during aacEncEncode(). */
+    INT                 numInSamples;        /*!< Number of input audio samples consumed by the encoder. */
+    INT                 numAncBytes;         /*!< Number of ancillary data bytes consumed by the encoder. */
+
+} AACENC_OutArgs;
+
+
+/**
+ *  Meta Data Compression Profiles.
+ */
+typedef enum {
+    AACENC_METADATA_DRC_NONE          = 0,   /*!< None. */
+    AACENC_METADATA_DRC_FILMSTANDARD  = 1,   /*!< Film standard. */
+    AACENC_METADATA_DRC_FILMLIGHT     = 2,   /*!< Film light. */
+    AACENC_METADATA_DRC_MUSICSTANDARD = 3,   /*!< Music standard. */
+    AACENC_METADATA_DRC_MUSICLIGHT    = 4,   /*!< Music light. */
+    AACENC_METADATA_DRC_SPEECH        = 5    /*!< Speech. */
+
+} AACENC_METADATA_DRC_PROFILE;
+
+
+/**
+ *  Meta Data setup structure.
+ */
+typedef struct {
+
+  AACENC_METADATA_DRC_PROFILE drc_profile;             /*!< MPEG DRC compression profile. See ::AACENC_METADATA_DRC_PROFILE. */
+  AACENC_METADATA_DRC_PROFILE comp_profile;            /*!< ETSI heavy compression profile. See ::AACENC_METADATA_DRC_PROFILE. */
+
+  INT                         drc_TargetRefLevel;      /*!< Used to define expected level to:
+                                                            Scaled with 16 bit. x*2^16. */
+  INT                         comp_TargetRefLevel;     /*!< Adjust limiter to avoid overload.
+                                                            Scaled with 16 bit. x*2^16. */
+
+  INT                         prog_ref_level_present;  /*!< Flag, if prog_ref_level is present */
+  INT                         prog_ref_level;          /*!< Programme Reference Level = Dialogue Level:
+                                                            -31.75dB .. 0 dB ; stepsize: 0.25dB
+                                                            Scaled with 16 bit. x*2^16.*/
+
+  UCHAR                       PCE_mixdown_idx_present; /*!< Flag, if dmx-idx should be written in programme config element */
+  UCHAR                       ETSI_DmxLvl_present;     /*!< Flag, if dmx-lvl should be written in ETSI-ancData */
+
+  SCHAR                       centerMixLevel;          /*!< Center downmix level (0...7, according to table) */
+  SCHAR                       surroundMixLevel;        /*!< Surround downmix level (0...7, according to table) */
+
+  UCHAR                       dolbySurroundMode;       /*!< Indication for Dolby Surround Encoding Mode.
+                                                            - 0: Dolby Surround mode not indicated
+                                                            - 1: 2-ch audio part is not Dolby surround encoded
+                                                            - 2: 2-ch audio part is Dolby surround encoded */
+} AACENC_MetaData;
+
+
+/**
+ * AAC encoder control flags.
+ *
+ * In interaction with the ::AACENC_CONTROL_STATE parameter it is possible to get information about the internal
+ * initialization process. It is also possible to overwrite the internal state from extern when necessary.
+ */
+typedef enum
+{
+    AACENC_INIT_NONE              = 0x0000,  /*!< Do not trigger initialization. */
+    AACENC_INIT_CONFIG            = 0x0001,  /*!< Initialize all encoder modules configuration. */
+    AACENC_INIT_STATES            = 0x0002,  /*!< Reset all encoder modules history buffer. */
+    AACENC_INIT_TRANSPORT         = 0x1000,  /*!< Initialize transport lib with new parameters. */
+    AACENC_RESET_INBUFFER         = 0x2000,  /*!< Reset fill level of internal input buffer. */
+    AACENC_INIT_ALL               = 0xFFFF   /*!< Initialize all. */
+}
+AACENC_CTRLFLAGS;
+
+
+/**
+ * \brief  AAC encoder setting parameters.
+ *
+ * Use aacEncoder_SetParam() function to configure, or use aacEncoder_GetParam() function to read
+ * the internal status of the following parameters.
+ */
+typedef enum
+{
+  AACENC_AOT                      = 0x0100,  /*!< Audio object type. See ::AUDIO_OBJECT_TYPE in FDK_audio.h.
+                                                  - 2: MPEG-4 AAC Low Complexity.
+                                                  - 5: MPEG-4 AAC Low Complexity with Spectral Band Replication (HE-AAC).
+                                                  - 29: MPEG-4 AAC Low Complexity with Spectral Band Replication and Parametric Stereo (HE-AAC v2).
+                                                        This configuration can be used only with stereo input audio data.
+                                                  - 23: MPEG-4 AAC Low-Delay.
+                                                  - 39: MPEG-4 AAC Enhanced Low-Delay. Since there is no ::AUDIO_OBJECT_TYPE for ELD in
+                                                        combination with SBR defined, enable SBR explicitely by ::AACENC_SBR_MODE parameter.
+                                                  - 129: MPEG-2 AAC Low Complexity.
+                                                  - 132: MPEG-2 AAC Low Complexity with Spectral Band Replication (HE-AAC).
+                                                  - 156: MPEG-2 AAC Low Complexity with Spectral Band Replication and Parametric Stereo (HE-AAC v2).
+                                                         This configuration can be used only with stereo input audio data. */
+
+  AACENC_BITRATE                  = 0x0101,  /*!< Total encoder bitrate. This parameter is mandatory and interacts with ::AACENC_BITRATEMODE.
+                                                  - CBR: Bitrate in bits/second.
+                                                    See \ref suppBitrates for details. */
+
+  AACENC_BITRATEMODE              = 0x0102,  /*!< Bitrate mode. Configuration can be different kind of bitrate configurations:
+                                                  - 0: Constant bitrate, use bitrate according to ::AACENC_BITRATE. (default)
+                                                       Within none LD/ELD ::AUDIO_OBJECT_TYPE, the CBR mode makes use of full allowed bitreservoir.
+                                                       In contrast, at Low-Delay ::AUDIO_OBJECT_TYPE the bitreservoir is kept very small.
+                                                  - 8: LD/ELD full bitreservoir for packet based transmission. */
+
+  AACENC_SAMPLERATE               = 0x0103,  /*!< Audio input data sampling rate. Encoder supports following sampling rates:
+                                                  8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 64000, 88200, 96000 */
+
+  AACENC_SBR_MODE                 = 0x0104,  /*!< Configure SBR independently of the chosen Audio Object Type ::AUDIO_OBJECT_TYPE.
+                                                  This parameter is for ELD audio object type only.
+                                                  - -1: Use ELD SBR auto configurator (default).
+                                                  - 0: Disable Spectral Band Replication.
+                                                  - 1: Enable Spectral Band Replication. */
+
+  AACENC_GRANULE_LENGTH           = 0x0105,  /*!< Core encoder (AAC) audio frame length in samples:
+                                                  - 1024: Default configuration.
+                                                  - 512: Default LD/ELD configuration.
+                                                  - 480: Optional length in LD/ELD configuration. */
+
+  AACENC_CHANNELMODE              = 0x0106,  /*!< Set explicit channel mode. Channel mode must match with number of input channels.
+                                                  - 1-7 and 33,34: MPEG channel modes supported, see ::CHANNEL_MODE in FDK_audio.h. */
+
+  AACENC_CHANNELORDER             = 0x0107,  /*!< Input audio data channel ordering scheme:
+                                                  - 0: MPEG channel ordering (e. g. 5.1: C, L, R, SL, SR, LFE). (default)
+                                                  - 1: WAVE file format channel ordering (e. g. 5.1: L, R, C, LFE, SL, SR). */
+
+  AACENC_SBR_RATIO                = 0x0108,  /*!<  Controls activation of downsampled SBR. With downsampled SBR, the delay will be
+                                                   shorter. On the other hand, for achieving the same quality level, downsampled SBR
+                                                   needs more bits than dual-rate SBR.
+                                                   With downsampled SBR, the AAC encoder will work at the same sampling rate as the
+                                                   SBR encoder (single rate).
+                                                   Downsampled SBR is supported for AAC-ELD and HE-AACv1.
+                                                   - 1: Downsampled SBR (default for ELD).
+                                                   - 2: Dual-rate SBR   (default for HE-AAC). */
+
+  AACENC_AFTERBURNER              = 0x0200,  /*!< This parameter controls the use of the afterburner feature.
+                                                  The afterburner is a type of analysis by synthesis algorithm which increases the
+                                                  audio quality but also the required processing power. It is recommended to always
+                                                  activate this if additional memory consumption and processing power consumption
+                                                  is not a problem. If increased MHz and memory consumption are an issue then the MHz
+                                                  and memory cost of this optional module need to be evaluated against the improvement
+                                                  in audio quality on a case by case basis.
+                                                  - 0: Disable afterburner (default).
+                                                  - 1: Enable afterburner. */
+
+  AACENC_BANDWIDTH                = 0x0203,  /*!< Core encoder audio bandwidth:
+                                                  - 0: Determine bandwidth internally (default, see chapter \ref BEHAVIOUR_BANDWIDTH).
+                                                  - 1 to fs/2: Frequency bandwidth in Hertz. (Experts only, better do not
+                                                               touch this value to avoid degraded audio quality) */
+
+  AACENC_TRANSMUX                 = 0x0300,  /*!< Transport type to be used. See ::TRANSPORT_TYPE in FDK_audio.h. Following
+                                                  types can be configured in encoder library:
+                                                  - 0: raw access units
+                                                  - 1: ADIF bitstream format
+                                                  - 2: ADTS bitstream format
+                                                  - 6: Audio Mux Elements (LATM) with muxConfigPresent = 1
+                                                  - 7: Audio Mux Elements (LATM) with muxConfigPresent = 0, out of band StreamMuxConfig
+                                                  - 10: Audio Sync Stream (LOAS) */
+
+  AACENC_HEADER_PERIOD            = 0x0301,  /*!< Frame count period for sending in-band configuration buffers within LATM/LOAS
+                                                  transport layer. Additionally this parameter configures the PCE repetition period
+                                                  in raw_data_block(). See \ref encPCE.
+                                                  - 0xFF: auto-mode default 10 for TT_MP4_ADTS, TT_MP4_LOAS and TT_MP4_LATM_MCP1, otherwise 0.
+                                                  - n: Frame count period. */
+
+  AACENC_SIGNALING_MODE           = 0x0302,  /*!< Signaling mode of the extension AOT:
+                                                  - 0: Implicit backward compatible signaling (default for non-MPEG-4 based
+                                                       AOT's and for the transport formats ADIF and ADTS)
+                                                       - A stream that uses implicit signaling can be decoded by every AAC decoder, even AAC-LC-only decoders
+                                                       - An AAC-LC-only decoder will only decode the low-frequency part of the stream, resulting in a band-limited output
+                                                       - This method works with all transport formats
+                                                       - This method does not work with downsampled SBR
+                                                  - 1: Explicit backward compatible signaling
+                                                       - A stream that uses explicit backward compatible signaling can be decoded by every AAC decoder, even AAC-LC-only decoders
+                                                       - An AAC-LC-only decoder will only decode the low-frequency part of the stream, resulting in a band-limited output
+                                                       - A decoder not capable of decoding PS will only decode the AAC-LC+SBR part.
+                                                         If the stream contained PS, the result will be a a decoded mono downmix
+                                                       - This method does not work with ADIF or ADTS. For LOAS/LATM, it only works with AudioMuxVersion==1
+                                                       - This method does work with downsampled SBR
+                                                  - 2: Explicit hierarchical signaling (default for MPEG-4 based AOT's and for all transport formats excluding ADIF and ADTS)
+                                                       - A stream that uses explicit hierarchical signaling can be decoded only by HE-AAC decoders
+                                                       - An AAC-LC-only decoder will not decode a stream that uses explicit hierarchical signaling
+                                                       - A decoder not capable of decoding PS will not decode the stream at all if it contained PS
+                                                       - This method does not work with ADIF or ADTS. It works with LOAS/LATM and the MPEG-4 File format
+                                                       - This method does work with downsampled SBR
+
+                                                   For making sure that the listener always experiences the best audio quality,
+                                                   explicit hierarchical signaling should be used.
+                                                   This makes sure that only a full HE-AAC-capable decoder will decode those streams.
+                                                   The audio is played at full bandwidth.
+                                                   For best backwards compatibility, it is recommended to encode with implicit SBR signaling.
+                                                   A decoder capable of AAC-LC only will then only decode the AAC part, which means the decoded
+                                                   audio will sound band-limited.
+
+                                                   For MPEG-2 transport types (ADTS,ADIF), only implicit signaling is possible.
+
+                                                   For LOAS and LATM, explicit backwards compatible signaling only works together with AudioMuxVersion==1.
+                                                   The reason is that, for explicit backwards compatible signaling, additional information will be appended to the ASC.
+                                                   A decoder that is only capable of decoding AAC-LC will skip this part.
+                                                   Nevertheless, for jumping to the end of the ASC, it needs to know the ASC length.
+                                                   Transmitting the length of the ASC is a feature of AudioMuxVersion==1, it is not possible to transmit the
+                                                   length of the ASC with AudioMuxVersion==0, therefore an AAC-LC-only decoder will not be able to parse a
+                                                   LOAS/LATM stream that was being encoded with AudioMuxVersion==0.
+
+                                                   For downsampled SBR, explicit signaling is mandatory. The reason for this is that the
+                                                   extension sampling frequency (which is in case of SBR the sampling frequqncy of the SBR part)
+                                                   can only be signaled in explicit mode.
+
+                                                   For AAC-ELD, the SBR information is transmitted in the ELDSpecific Config, which is part of the
+                                                   AudioSpecificConfig. Therefore, the settings here will have no effect on AAC-ELD.*/
+
+  AACENC_TPSUBFRAMES              = 0x0303,  /*!< Number of sub frames in a transport frame for LOAS/LATM or ADTS (default 1).
+                                                  - ADTS: Maximum number of sub frames restricted to 4.
+                                                  - LOAS/LATM: Maximum number of sub frames restricted to 2.*/
+
+  AACENC_PROTECTION               = 0x0306,  /*!< Configure protection in tranpsort layer:
+                                                  - 0: No protection. (default)
+                                                  - 1: CRC active for ADTS bitstream format. */
+
+  AACENC_ANCILLARY_BITRATE        = 0x0500,  /*!< Constant ancillary data bitrate in bits/second.
+                                                  - 0: Either no ancillary data or insert exact number of bytes, denoted via
+                                                       input parameter, numAncBytes in AACENC_InArgs.
+                                                  - else: Insert ancillary data with specified bitrate. */
+
+  AACENC_METADATA_MODE            = 0x0600,  /*!< Configure Meta Data. See ::AACENC_MetaData for further details:
+                                                  - 0: Do not embed any metadata.
+                                                  - 1: Embed MPEG defined metadata only.
+                                                  - 2: Embed all metadata. */
+
+  AACENC_CONTROL_STATE            = 0xFF00,  /*!< There is an automatic process which internally reconfigures the encoder instance
+                                                  when a configuration parameter changed or an error occured. This paramerter allows
+                                                  overwriting or getting the control status of this process. See ::AACENC_CTRLFLAGS. */
+
+  AACENC_NONE                     = 0xFFFF   /*!< ------ */
+
+} AACENC_PARAM;
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \brief  Open an instance of the encoder.
+ *
+ * Allocate memory for an encoder instance with a functional range denoted by the function parameters.
+ * Preinitialize encoder instance with default configuration.
+ *
+ * \param phAacEncoder  A pointer to an encoder handle. Initialized on return.
+ * \param encModules    Specify encoder modules to be supported in this encoder instance:
+ *                      - 0x0: Allocate memory for all available encoder modules.
+ *                      - else: Select memory allocation regarding encoder modules. Following flags are possible and can be combined.
+ *                              - 0x01: AAC module.
+ *                              - 0x02: SBR module.
+ *                              - 0x04: PS module.
+ *                              - 0x10: Metadata module.
+ *                              - example: (0x01|0x02|0x04|0x10) allocates all modules and is equivalent to default configuration denotet by 0x0.
+ * \param maxChannels   Number of channels to be allocated. This parameter can be used in different ways:
+ *                      - 0: Allocate maximum number of AAC and SBR channels as supported by the library.
+ *                      - nChannels: Use same maximum number of channels for allocating memory in AAC and SBR module.
+ *                      - nChannels | (nSbrCh<<8): Number of SBR channels can be different to AAC channels to save data memory.
+ *
+ * \return
+ *          - AACENC_OK, on succes.
+ *          - AACENC_INVALID_HANDLE, AACENC_MEMORY_ERROR, AACENC_INVALID_CONFIG, on failure.
+ */
+AACENC_ERROR aacEncOpen(
+        HANDLE_AACENCODER        *phAacEncoder,
+        const UINT                encModules,
+        const UINT                maxChannels
+        );
+
+
+/**
+ * \brief  Close the encoder instance.
+ *
+ * Deallocate encoder instance and free whole memory.
+ *
+ * \param phAacEncoder  Pointer to the encoder handle to be deallocated.
+ *
+ * \return
+ *          - AACENC_OK, on success.
+ *          - AACENC_INVALID_HANDLE, on failure.
+ */
+AACENC_ERROR aacEncClose(
+        HANDLE_AACENCODER        *phAacEncoder
+        );
+
+
+/**
+ * \brief Encode audio data.
+ *
+ * This function is mainly for encoding audio data. In addition the function can be used for an encoder (re)configuration
+ * process.
+ * - PCM input data will be retrieved from external input buffer until the fill level allows encoding a single frame.
+ *   This functionality allows an external buffer with reduced size in comparison to the AAC or HE-AAC audio frame length.
+ * - If the value of the input samples argument is zero, just internal reinitialization will be applied if it is
+ *   requested.
+ * - At the end of a file the flushing process can be triggerd via setting the value of the input samples argument to -1.
+ *   The encoder delay lines are fully flushed when the encoder returns no valid bitstream data AACENC_OutArgs::numOutBytes.
+ *   Furthermore the end of file is signaled by the return value AACENC_ENCODE_EOF.
+ * - If an error occured in the previous frame or any of the encoder parameters changed, an internal reinitialization
+ *   process will be applied before encoding the incoming audio samples.
+ * - The function can also be used for an independent reconfiguration process without encoding. The first parameter has to be a
+ *   valid encoder handle and all other parameters can be set to NULL.
+ * - If the size of the external bitbuffer in outBufDesc is not sufficient for writing the whole bitstream, an internal
+ *   error will be the return value and a reconfiguration will be triggered.
+ *
+ * \param hAacEncoder           A valid AAC encoder handle.
+ * \param inBufDesc             Input buffer descriptor, see AACENC_BufDesc:
+ *                              - At least one input buffer with audio data is expected.
+ *                              - Optionally a second input buffer with ancillary data can be fed.
+ * \param outBufDesc            Output buffer descriptor, see AACENC_BufDesc:
+ *                              - Provide one output buffer for the encoded bitstream.
+ * \param inargs                Input arguments, see AACENC_InArgs.
+ * \param outargs               Output arguments, AACENC_OutArgs.
+ *
+ * \return
+ *          - AACENC_OK, on success.
+ *          - AACENC_INVALID_HANDLE, AACENC_ENCODE_ERROR, on failure in encoding process.
+ *          - AACENC_INVALID_CONFIG, AACENC_INIT_ERROR, AACENC_INIT_AAC_ERROR, AACENC_INIT_SBR_ERROR, AACENC_INIT_TP_ERROR,
+ *            AACENC_INIT_META_ERROR, on failure in encoder initialization.
+ *          - AACENC_ENCODE_EOF, when flushing fully concluded.
+ */
+AACENC_ERROR aacEncEncode(
+        const HANDLE_AACENCODER   hAacEncoder,
+        const AACENC_BufDesc     *inBufDesc,
+        const AACENC_BufDesc     *outBufDesc,
+        const AACENC_InArgs      *inargs,
+        AACENC_OutArgs           *outargs
+        );
+
+
+/**
+ * \brief  Acquire info about present encoder instance.
+ *
+ * This function retrieves information of the encoder configuration. In addition to informative internal states,
+ * a configuration data block of the current encoder settings will be returned. The format is either Audio Specific Config
+ * in case of Raw Packets transport format or StreamMuxConfig in case of LOAS/LATM transport format. The configuration
+ * data block is binary coded as specified in ISO/IEC 14496-3 (MPEG-4 audio), to be used directly for MPEG-4 File Format
+ * or RFC3016 or RFC3640 applications.
+ *
+ * \param hAacEncoder           A valid AAC encoder handle.
+ * \param pInfo                 Pointer to AACENC_InfoStruct. Filled on return.
+ *
+ * \return
+ *          - AACENC_OK, on succes.
+ *          - AACENC_INIT_ERROR, on failure.
+ */
+AACENC_ERROR aacEncInfo(
+        const HANDLE_AACENCODER   hAacEncoder,
+        AACENC_InfoStruct        *pInfo
+        );
+
+
+/**
+ * \brief  Set one single AAC encoder parameter.
+ *
+ * This function allows configuration of all encoder parameters specified in ::AACENC_PARAM. Each parameter must be
+ * set with a separate function call. An internal validation of the configuration value range will be done and an
+ * internal reconfiguration will be signaled. The actual configuration adoption is part of the subsequent aacEncEncode() call.
+ *
+ * \param hAacEncoder           A valid AAC encoder handle.
+ * \param param                 Parameter to be set. See ::AACENC_PARAM.
+ * \param value                 Parameter value. See parameter description in ::AACENC_PARAM.
+ *
+ * \return
+ *          - AACENC_OK, on success.
+ *          - AACENC_INVALID_HANDLE, AACENC_UNSUPPORTED_PARAMETER, AACENC_INVALID_CONFIG, on failure.
+ */
+AACENC_ERROR aacEncoder_SetParam(
+        const HANDLE_AACENCODER   hAacEncoder,
+        const AACENC_PARAM        param,
+        const UINT                value
+        );
+
+
+/**
+ * \brief  Get one single AAC encoder parameter.
+ *
+ * This function is the complement to aacEncoder_SetParam(). After encoder reinitialization with user defined settings,
+ * the internal status can be obtained of each parameter, specified with ::AACENC_PARAM.
+ *
+ * \param hAacEncoder           A valid AAC encoder handle.
+ * \param param                 Parameter to be returned. See ::AACENC_PARAM.
+ *
+ * \return  Internal configuration value of specifed parameter ::AACENC_PARAM.
+ */
+UINT aacEncoder_GetParam(
+        const HANDLE_AACENCODER   hAacEncoder,
+        const AACENC_PARAM        param
+        );
+
+
+/**
+ * \brief  Get information about encoder library build.
+ *
+ * Fill a given LIB_INFO structure with library version information.
+ *
+ * \param info  Pointer to an allocated LIB_INFO struct.
+ *
+ * \return
+ *          - AACENC_OK, on success.
+ *          - AACENC_INVALID_HANDLE, AACENC_INIT_ERROR, on failure.
+ */
+AACENC_ERROR aacEncGetLibInfo(
+        LIB_INFO                 *info
+        );
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif   /* _AAC_ENC_LIB_H_ */
--- ffmpeg-2.5/localinc/faaccfg.h.dl_headers~	2014-12-04 22:53:11.246499031 +0100
+++ ffmpeg-2.5/localinc/faaccfg.h	2014-12-04 22:53:11.246499031 +0100
@@ -0,0 +1,122 @@
+/*
+ * FAAC - Freeware Advanced Audio Coder
+ * Copyright (C) 2001 Menno Bakker
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * $Id: faaccfg.h,v 1.3 2004/07/04 12:12:05 corrados Exp $
+ */
+
+#ifndef _FAACCFG_H_
+#define _FAACCFG_H_
+
+#define FAAC_CFG_VERSION 104
+
+/* MPEG ID's */
+#define MPEG2 1
+#define MPEG4 0
+
+/* AAC object types */
+#define MAIN 1
+#define LOW  2
+#define SSR  3
+#define LTP  4
+
+/* Input Formats */
+#define FAAC_INPUT_NULL    0
+#define FAAC_INPUT_16BIT   1
+#define FAAC_INPUT_24BIT   2
+#define FAAC_INPUT_32BIT   3
+#define FAAC_INPUT_FLOAT   4
+
+#define SHORTCTL_NORMAL    0
+#define SHORTCTL_NOSHORT   1
+#define SHORTCTL_NOLONG    2
+
+#pragma pack(push, 1)
+typedef struct faacEncConfiguration
+{
+    /* config version */
+    int version;
+
+    /* library version */
+    char *name;
+
+    /* copyright string */
+    char *copyright;
+
+    /* MPEG version, 2 or 4 */
+    unsigned int mpegVersion;
+
+    /* AAC object type */
+    unsigned int aacObjectType;
+
+    /* Allow mid/side coding */
+    unsigned int allowMidside;
+
+    /* Use one of the channels as LFE channel */
+    unsigned int useLfe;
+
+    /* Use Temporal Noise Shaping */
+    unsigned int useTns;
+
+    /* bitrate / channel of AAC file */
+    unsigned long bitRate;
+
+    /* AAC file frequency bandwidth */
+    unsigned int bandWidth;
+
+    /* Quantizer quality */
+    unsigned long quantqual;
+
+    /* Bitstream output format (0 = Raw; 1 = ADTS) */
+    unsigned int outputFormat;
+
+    /* psychoacoustic model list */
+    psymodellist_t *psymodellist;
+
+    /* selected index in psymodellist */
+    unsigned int psymodelidx;
+
+    /*
+		PCM Sample Input Format
+		0	FAAC_INPUT_NULL			invalid, signifies a misconfigured config
+		1	FAAC_INPUT_16BIT		native endian 16bit
+		2	FAAC_INPUT_24BIT		native endian 24bit in 24 bits		(not implemented)
+		3	FAAC_INPUT_32BIT		native endian 24bit in 32 bits		(DEFAULT)
+		4	FAAC_INPUT_FLOAT		32bit floating point
+    */
+    unsigned int inputFormat;
+
+    /* block type enforcing (SHORTCTL_NORMAL/SHORTCTL_NOSHORT/SHORTCTL_NOLONG) */
+    int shortctl;
+	
+	/*
+		Channel Remapping
+
+		Default			0, 1, 2, 3 ... 63  (64 is MAX_CHANNELS in coder.h)
+
+		WAVE 4.0		2, 0, 1, 3
+		WAVE 5.0		2, 0, 1, 3, 4
+		WAVE 5.1		2, 0, 1, 4, 5, 3
+		AIFF 5.1		2, 0, 3, 1, 4, 5 
+	*/
+	int channel_map[64];	
+
+} faacEncConfiguration, *faacEncConfigurationPtr;
+
+#pragma pack(pop)
+
+#endif /* _FAACCFG_H_ */
--- ffmpeg-2.5/localinc/faac.h.dl_headers~	2014-12-04 22:53:11.246499031 +0100
+++ ffmpeg-2.5/localinc/faac.h	2014-12-04 22:53:11.246499031 +0100
@@ -0,0 +1,99 @@
+/*
+ * FAAC - Freeware Advanced Audio Coder
+ * Copyright (C) 2001 Menno Bakker
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * $Id: faac.h,v 1.36 2009/01/25 18:50:32 menno Exp $
+ */
+
+#ifndef _FAAC_H_
+#define _FAAC_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#if defined(_WIN32) && !defined(__MINGW32__)
+# ifndef FAACAPI
+#  define FAACAPI __stdcall
+# endif
+#else
+# ifndef FAACAPI
+#  define FAACAPI
+# endif
+#endif
+
+#pragma pack(push, 1)
+
+typedef struct {
+  void *ptr;
+  char *name;
+}
+psymodellist_t;
+
+#include "faaccfg.h"
+
+
+typedef void *faacEncHandle;
+
+#ifndef HAVE_INT32_T
+typedef signed int int32_t;
+#endif
+
+/*
+	Allows an application to get FAAC version info. This is intended
+	purely for informative purposes.
+
+	Returns FAAC_CFG_VERSION.
+*/
+int FAACAPI faacEncGetVersion(char **faac_id_string,
+			      char **faac_copyright_string);
+
+
+faacEncConfigurationPtr FAACAPI
+  faacEncGetCurrentConfiguration(faacEncHandle hEncoder);
+
+
+int FAACAPI faacEncSetConfiguration(faacEncHandle hEncoder,
+				    faacEncConfigurationPtr config);
+
+
+faacEncHandle FAACAPI faacEncOpen(unsigned long sampleRate,
+				  unsigned int numChannels,
+				  unsigned long *inputSamples,
+				  unsigned long *maxOutputBytes);
+
+
+int FAACAPI faacEncGetDecoderSpecificInfo(faacEncHandle hEncoder, unsigned char **ppBuffer,
+					  unsigned long *pSizeOfDecoderSpecificInfo);
+
+
+int FAACAPI faacEncEncode(faacEncHandle hEncoder, int32_t * inputBuffer, unsigned int samplesInput,
+			 unsigned char *outputBuffer,
+			 unsigned int bufferSize);
+
+
+int FAACAPI faacEncClose(faacEncHandle hEncoder);
+
+
+
+#pragma pack(pop)
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* _FAAC_H_ */
--- ffmpeg-2.5/localinc/lame/lame.h.dl_headers~	2014-12-04 22:53:11.253165674 +0100
+++ ffmpeg-2.5/localinc/lame/lame.h	2014-12-04 22:53:11.253165674 +0100
@@ -0,0 +1,1243 @@
+/*
+ *	Interface to MP3 LAME encoding engine
+ *
+ *	Copyright (c) 1999 Mark Taylor
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/* $Id: lame.h,v 1.170.2.4 2009/01/18 15:44:28 robert Exp $ */
+
+#ifndef LAME_LAME_H
+#define LAME_LAME_H
+
+/* for size_t typedef */
+#include <stddef.h>
+/* for va_list typedef */
+#include <stdarg.h>
+/* for FILE typedef, TODO: remove when removing lame_mp3_tags_fid */
+#include <stdio.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#if defined(WIN32) || defined(_WIN32)
+#undef CDECL
+#define CDECL __cdecl
+#else
+#define CDECL
+#endif
+
+
+#define DEPRECATED_OR_OBSOLETE_CODE_REMOVED 1
+
+
+typedef enum vbr_mode_e {
+  vbr_off=0,
+  vbr_mt,               /* obsolete, same as vbr_mtrh */
+  vbr_rh,
+  vbr_abr,
+  vbr_mtrh,
+  vbr_max_indicator,    /* Don't use this! It's used for sanity checks.       */
+  vbr_default=vbr_mtrh    /* change this to change the default VBR mode of LAME */
+} vbr_mode;
+
+
+/* MPEG modes */
+typedef enum MPEG_mode_e {
+  STEREO = 0,
+  JOINT_STEREO,
+  DUAL_CHANNEL,   /* LAME doesn't supports this! */
+  MONO,
+  NOT_SET,
+  MAX_INDICATOR   /* Don't use this! It's used for sanity checks. */
+} MPEG_mode;
+
+/* Padding types */
+typedef enum Padding_type_e {
+  PAD_NO = 0,
+  PAD_ALL,
+  PAD_ADJUST,
+  PAD_MAX_INDICATOR   /* Don't use this! It's used for sanity checks. */
+} Padding_type;
+
+
+
+/*presets*/
+typedef enum preset_mode_e {
+    /*values from 8 to 320 should be reserved for abr bitrates*/
+    /*for abr I'd suggest to directly use the targeted bitrate as a value*/
+    ABR_8 = 8,
+    ABR_320 = 320,
+
+    V9 = 410, /*Vx to match Lame and VBR_xx to match FhG*/
+    VBR_10 = 410,
+    V8 = 420,
+    VBR_20 = 420,
+    V7 = 430,
+    VBR_30 = 430,
+    V6 = 440,
+    VBR_40 = 440,
+    V5 = 450,
+    VBR_50 = 450,
+    V4 = 460,
+    VBR_60 = 460,
+    V3 = 470,
+    VBR_70 = 470,
+    V2 = 480,
+    VBR_80 = 480,
+    V1 = 490,
+    VBR_90 = 490,
+    V0 = 500,
+    VBR_100 = 500,
+
+
+
+    /*still there for compatibility*/
+    R3MIX = 1000,
+    STANDARD = 1001,
+    EXTREME = 1002,
+    INSANE = 1003,
+    STANDARD_FAST = 1004,
+    EXTREME_FAST = 1005,
+    MEDIUM = 1006,
+    MEDIUM_FAST = 1007
+} preset_mode;
+
+
+/*asm optimizations*/
+typedef enum asm_optimizations_e {
+    MMX = 1,
+    AMD_3DNOW = 2,
+    SSE = 3
+} asm_optimizations;
+
+
+/* psychoacoustic model */
+typedef enum Psy_model_e {
+    PSY_GPSYCHO = 1,
+    PSY_NSPSYTUNE = 2
+} Psy_model;
+
+
+struct lame_global_struct;
+typedef struct lame_global_struct lame_global_flags;
+typedef lame_global_flags *lame_t;
+
+
+
+
+/***********************************************************************
+ *
+ *  The LAME API
+ *  These functions should be called, in this order, for each
+ *  MP3 file to be encoded.  See the file "API" for more documentation
+ *
+ ***********************************************************************/
+
+
+/*
+ * REQUIRED:
+ * initialize the encoder.  sets default for all encoder parameters,
+ * returns NULL if some malloc()'s failed
+ * otherwise returns pointer to structure needed for all future
+ * API calls.
+ */
+lame_global_flags * CDECL lame_init(void);
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* obsolete version */
+int CDECL lame_init_old(lame_global_flags *);
+#endif
+
+/*
+ * OPTIONAL:
+ * set as needed to override defaults
+ */
+
+/********************************************************************
+ *  input stream description
+ ***********************************************************************/
+/* number of samples.  default = 2^32-1   */
+int CDECL lame_set_num_samples(lame_global_flags *, unsigned long);
+unsigned long CDECL lame_get_num_samples(const lame_global_flags *);
+
+/* input sample rate in Hz.  default = 44100hz */
+int CDECL lame_set_in_samplerate(lame_global_flags *, int);
+int CDECL lame_get_in_samplerate(const lame_global_flags *);
+
+/* number of channels in input stream. default=2  */
+int CDECL lame_set_num_channels(lame_global_flags *, int);
+int CDECL lame_get_num_channels(const lame_global_flags *);
+
+/*
+  scale the input by this amount before encoding.  default=0 (disabled)
+  (not used by decoding routines)
+*/
+int CDECL lame_set_scale(lame_global_flags *, float);
+float CDECL lame_get_scale(const lame_global_flags *);
+
+/*
+  scale the channel 0 (left) input by this amount before encoding.
+    default=0 (disabled)
+  (not used by decoding routines)
+*/
+int CDECL lame_set_scale_left(lame_global_flags *, float);
+float CDECL lame_get_scale_left(const lame_global_flags *);
+
+/*
+  scale the channel 1 (right) input by this amount before encoding.
+    default=0 (disabled)
+  (not used by decoding routines)
+*/
+int CDECL lame_set_scale_right(lame_global_flags *, float);
+float CDECL lame_get_scale_right(const lame_global_flags *);
+
+/*
+  output sample rate in Hz.  default = 0, which means LAME picks best value
+  based on the amount of compression.  MPEG only allows:
+  MPEG1    32, 44.1,   48khz
+  MPEG2    16, 22.05,  24
+  MPEG2.5   8, 11.025, 12
+  (not used by decoding routines)
+*/
+int CDECL lame_set_out_samplerate(lame_global_flags *, int);
+int CDECL lame_get_out_samplerate(const lame_global_flags *);
+
+
+/********************************************************************
+ *  general control parameters
+ ***********************************************************************/
+/* 1=cause LAME to collect data for an MP3 frame analyzer. default=0 */
+int CDECL lame_set_analysis(lame_global_flags *, int);
+int CDECL lame_get_analysis(const lame_global_flags *);
+
+/*
+  1 = write a Xing VBR header frame.
+  default = 1
+  this variable must have been added by a Hungarian notation Windows programmer :-)
+*/
+int CDECL lame_set_bWriteVbrTag(lame_global_flags *, int);
+int CDECL lame_get_bWriteVbrTag(const lame_global_flags *);
+
+/* 1=decode only.  use lame/mpglib to convert mp3/ogg to wav.  default=0 */
+int CDECL lame_set_decode_only(lame_global_flags *, int);
+int CDECL lame_get_decode_only(const lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* 1=encode a Vorbis .ogg file.  default=0 */
+/* DEPRECATED */
+int CDECL lame_set_ogg(lame_global_flags *, int);
+int CDECL lame_get_ogg(const lame_global_flags *);
+#endif
+
+/*
+  internal algorithm selection.  True quality is determined by the bitrate
+  but this variable will effect quality by selecting expensive or cheap algorithms.
+  quality=0..9.  0=best (very slow).  9=worst.
+  recommended:  2     near-best quality, not too slow
+                5     good quality, fast
+                7     ok quality, really fast
+*/
+int CDECL lame_set_quality(lame_global_flags *, int);
+int CDECL lame_get_quality(const lame_global_flags *);
+
+/*
+  mode = 0,1,2,3 = stereo, jstereo, dual channel (not supported), mono
+  default: lame picks based on compression ration and input channels
+*/
+int CDECL lame_set_mode(lame_global_flags *, MPEG_mode);
+MPEG_mode CDECL lame_get_mode(const lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/*
+  mode_automs.  Use a M/S mode with a switching threshold based on
+  compression ratio
+  DEPRECATED
+*/
+int CDECL lame_set_mode_automs(lame_global_flags *, int);
+int CDECL lame_get_mode_automs(const lame_global_flags *);
+#endif
+
+/*
+  force_ms.  Force M/S for all frames.  For testing only.
+  default = 0 (disabled)
+*/
+int CDECL lame_set_force_ms(lame_global_flags *, int);
+int CDECL lame_get_force_ms(const lame_global_flags *);
+
+/* use free_format?  default = 0 (disabled) */
+int CDECL lame_set_free_format(lame_global_flags *, int);
+int CDECL lame_get_free_format(const lame_global_flags *);
+
+/* perform ReplayGain analysis?  default = 0 (disabled) */
+int CDECL lame_set_findReplayGain(lame_global_flags *, int);
+int CDECL lame_get_findReplayGain(const lame_global_flags *);
+
+/* decode on the fly. Search for the peak sample. If the ReplayGain
+ * analysis is enabled then perform the analysis on the decoded data
+ * stream. default = 0 (disabled)
+ * NOTE: if this option is set the build-in decoder should not be used */
+int CDECL lame_set_decode_on_the_fly(lame_global_flags *, int);
+int CDECL lame_get_decode_on_the_fly(const lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* DEPRECATED: now does the same as lame_set_findReplayGain()
+   default = 0 (disabled) */
+int CDECL lame_set_ReplayGain_input(lame_global_flags *, int);
+int CDECL lame_get_ReplayGain_input(const lame_global_flags *);
+
+/* DEPRECATED: now does the same as
+   lame_set_decode_on_the_fly() && lame_set_findReplayGain()
+   default = 0 (disabled) */
+int CDECL lame_set_ReplayGain_decode(lame_global_flags *, int);
+int CDECL lame_get_ReplayGain_decode(const lame_global_flags *);
+
+/* DEPRECATED: now does the same as lame_set_decode_on_the_fly()
+   default = 0 (disabled) */
+int CDECL lame_set_findPeakSample(lame_global_flags *, int);
+int CDECL lame_get_findPeakSample(const lame_global_flags *);
+#endif
+
+/* counters for gapless encoding */
+int CDECL lame_set_nogap_total(lame_global_flags*, int);
+int CDECL lame_get_nogap_total(const lame_global_flags*);
+
+int CDECL lame_set_nogap_currentindex(lame_global_flags* , int);
+int CDECL lame_get_nogap_currentindex(const lame_global_flags*);
+
+
+/*
+ * OPTIONAL:
+ * Set printf like error/debug/message reporting functions.
+ * The second argument has to be a pointer to a function which looks like
+ *   void my_debugf(const char *format, va_list ap)
+ *   {
+ *       (void) vfprintf(stdout, format, ap);
+ *   }
+ * If you use NULL as the value of the pointer in the set function, the
+ * lame buildin function will be used (prints to stderr).
+ * To quiet any output you have to replace the body of the example function
+ * with just "return;" and use it in the set function.
+ */
+int CDECL lame_set_errorf(lame_global_flags *,
+                          void (*func)(const char *, va_list));
+int CDECL lame_set_debugf(lame_global_flags *,
+                          void (*func)(const char *, va_list));
+int CDECL lame_set_msgf  (lame_global_flags *,
+                          void (*func)(const char *, va_list));
+
+
+
+/* set one of brate compression ratio.  default is compression ratio of 11.  */
+int CDECL lame_set_brate(lame_global_flags *, int);
+int CDECL lame_get_brate(const lame_global_flags *);
+int CDECL lame_set_compression_ratio(lame_global_flags *, float);
+float CDECL lame_get_compression_ratio(const lame_global_flags *);
+
+
+int CDECL lame_set_preset( lame_global_flags*  gfp, int );
+int CDECL lame_set_asm_optimizations( lame_global_flags*  gfp, int, int );
+
+
+
+/********************************************************************
+ *  frame params
+ ***********************************************************************/
+/* mark as copyright.  default=0 */
+int CDECL lame_set_copyright(lame_global_flags *, int);
+int CDECL lame_get_copyright(const lame_global_flags *);
+
+/* mark as original.  default=1 */
+int CDECL lame_set_original(lame_global_flags *, int);
+int CDECL lame_get_original(const lame_global_flags *);
+
+/* error_protection.  Use 2 bytes from each frame for CRC checksum. default=0 */
+int CDECL lame_set_error_protection(lame_global_flags *, int);
+int CDECL lame_get_error_protection(const lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* padding_type. 0=pad no frames  1=pad all frames 2=adjust padding(default) */
+int CDECL lame_set_padding_type(lame_global_flags *, Padding_type);
+Padding_type CDECL lame_get_padding_type(const lame_global_flags *);
+#endif
+
+/* MP3 'private extension' bit  Meaningless.  default=0 */
+int CDECL lame_set_extension(lame_global_flags *, int);
+int CDECL lame_get_extension(const lame_global_flags *);
+
+/* enforce strict ISO compliance.  default=0 */
+int CDECL lame_set_strict_ISO(lame_global_flags *, int);
+int CDECL lame_get_strict_ISO(const lame_global_flags *);
+
+
+/********************************************************************
+ * quantization/noise shaping
+ ***********************************************************************/
+
+/* disable the bit reservoir. For testing only. default=0 */
+int CDECL lame_set_disable_reservoir(lame_global_flags *, int);
+int CDECL lame_get_disable_reservoir(const lame_global_flags *);
+
+/* select a different "best quantization" function. default=0  */
+int CDECL lame_set_quant_comp(lame_global_flags *, int);
+int CDECL lame_get_quant_comp(const lame_global_flags *);
+int CDECL lame_set_quant_comp_short(lame_global_flags *, int);
+int CDECL lame_get_quant_comp_short(const lame_global_flags *);
+
+int CDECL lame_set_experimentalX(lame_global_flags *, int); /* compatibility*/
+int CDECL lame_get_experimentalX(const lame_global_flags *);
+
+/* another experimental option.  for testing only */
+int CDECL lame_set_experimentalY(lame_global_flags *, int);
+int CDECL lame_get_experimentalY(const lame_global_flags *);
+
+/* another experimental option.  for testing only */
+int CDECL lame_set_experimentalZ(lame_global_flags *, int);
+int CDECL lame_get_experimentalZ(const lame_global_flags *);
+
+/* Naoki's psycho acoustic model.  default=0 */
+int CDECL lame_set_exp_nspsytune(lame_global_flags *, int);
+int CDECL lame_get_exp_nspsytune(const lame_global_flags *);
+
+void CDECL lame_set_msfix(lame_global_flags *, double);
+float CDECL lame_get_msfix(const lame_global_flags *);
+
+
+/********************************************************************
+ * VBR control
+ ***********************************************************************/
+/* Types of VBR.  default = vbr_off = CBR */
+int CDECL lame_set_VBR(lame_global_flags *, vbr_mode);
+vbr_mode CDECL lame_get_VBR(const lame_global_flags *);
+
+/* VBR quality level.  0=highest  9=lowest  */
+int CDECL lame_set_VBR_q(lame_global_flags *, int);
+int CDECL lame_get_VBR_q(const lame_global_flags *);
+
+/* VBR quality level.  0=highest  9=lowest, Range [0,...,10[  */
+int CDECL lame_set_VBR_quality(lame_global_flags *, float);
+float CDECL lame_get_VBR_quality(const lame_global_flags *);
+
+/* Ignored except for VBR=vbr_abr (ABR mode) */
+int CDECL lame_set_VBR_mean_bitrate_kbps(lame_global_flags *, int);
+int CDECL lame_get_VBR_mean_bitrate_kbps(const lame_global_flags *);
+
+int CDECL lame_set_VBR_min_bitrate_kbps(lame_global_flags *, int);
+int CDECL lame_get_VBR_min_bitrate_kbps(const lame_global_flags *);
+
+int CDECL lame_set_VBR_max_bitrate_kbps(lame_global_flags *, int);
+int CDECL lame_get_VBR_max_bitrate_kbps(const lame_global_flags *);
+
+/*
+  1=strictly enforce VBR_min_bitrate.  Normally it will be violated for
+  analog silence
+*/
+int CDECL lame_set_VBR_hard_min(lame_global_flags *, int);
+int CDECL lame_get_VBR_hard_min(const lame_global_flags *);
+
+/* for preset */
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+int CDECL lame_set_preset_expopts(lame_global_flags *, int);
+#endif
+
+/********************************************************************
+ * Filtering control
+ ***********************************************************************/
+/* freq in Hz to apply lowpass. Default = 0 = lame chooses.  -1 = disabled */
+int CDECL lame_set_lowpassfreq(lame_global_flags *, int);
+int CDECL lame_get_lowpassfreq(const lame_global_flags *);
+/* width of transition band, in Hz.  Default = one polyphase filter band */
+int CDECL lame_set_lowpasswidth(lame_global_flags *, int);
+int CDECL lame_get_lowpasswidth(const lame_global_flags *);
+
+/* freq in Hz to apply highpass. Default = 0 = lame chooses.  -1 = disabled */
+int CDECL lame_set_highpassfreq(lame_global_flags *, int);
+int CDECL lame_get_highpassfreq(const lame_global_flags *);
+/* width of transition band, in Hz.  Default = one polyphase filter band */
+int CDECL lame_set_highpasswidth(lame_global_flags *, int);
+int CDECL lame_get_highpasswidth(const lame_global_flags *);
+
+
+/********************************************************************
+ * psycho acoustics and other arguments which you should not change
+ * unless you know what you are doing
+ ***********************************************************************/
+
+/* only use ATH for masking */
+int CDECL lame_set_ATHonly(lame_global_flags *, int);
+int CDECL lame_get_ATHonly(const lame_global_flags *);
+
+/* only use ATH for short blocks */
+int CDECL lame_set_ATHshort(lame_global_flags *, int);
+int CDECL lame_get_ATHshort(const lame_global_flags *);
+
+/* disable ATH */
+int CDECL lame_set_noATH(lame_global_flags *, int);
+int CDECL lame_get_noATH(const lame_global_flags *);
+
+/* select ATH formula */
+int CDECL lame_set_ATHtype(lame_global_flags *, int);
+int CDECL lame_get_ATHtype(const lame_global_flags *);
+
+/* lower ATH by this many db */
+int CDECL lame_set_ATHlower(lame_global_flags *, float);
+float CDECL lame_get_ATHlower(const lame_global_flags *);
+
+/* select ATH adaptive adjustment type */
+int CDECL lame_set_athaa_type( lame_global_flags *, int);
+int CDECL lame_get_athaa_type( const lame_global_flags *);
+
+/* select the loudness approximation used by the ATH adaptive auto-leveling  */
+int CDECL lame_set_athaa_loudapprox( lame_global_flags *, int);
+int CDECL lame_get_athaa_loudapprox( const lame_global_flags *);
+
+/* adjust (in dB) the point below which adaptive ATH level adjustment occurs */
+int CDECL lame_set_athaa_sensitivity( lame_global_flags *, float);
+float CDECL lame_get_athaa_sensitivity( const lame_global_flags* );
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* OBSOLETE: predictability limit (ISO tonality formula) */
+int CDECL lame_set_cwlimit(lame_global_flags *, int);
+int CDECL lame_get_cwlimit(const lame_global_flags *);
+#endif
+
+/*
+  allow blocktypes to differ between channels?
+  default: 0 for jstereo, 1 for stereo
+*/
+int CDECL lame_set_allow_diff_short(lame_global_flags *, int);
+int CDECL lame_get_allow_diff_short(const lame_global_flags *);
+
+/* use temporal masking effect (default = 1) */
+int CDECL lame_set_useTemporal(lame_global_flags *, int);
+int CDECL lame_get_useTemporal(const lame_global_flags *);
+
+/* use temporal masking effect (default = 1) */
+int CDECL lame_set_interChRatio(lame_global_flags *, float);
+float CDECL lame_get_interChRatio(const lame_global_flags *);
+
+/* disable short blocks */
+int CDECL lame_set_no_short_blocks(lame_global_flags *, int);
+int CDECL lame_get_no_short_blocks(const lame_global_flags *);
+
+/* force short blocks */
+int CDECL lame_set_force_short_blocks(lame_global_flags *, int);
+int CDECL lame_get_force_short_blocks(const lame_global_flags *);
+
+/* Input PCM is emphased PCM (for instance from one of the rarely
+   emphased CDs), it is STRONGLY not recommended to use this, because
+   psycho does not take it into account, and last but not least many decoders
+   ignore these bits */
+int CDECL lame_set_emphasis(lame_global_flags *, int);
+int CDECL lame_get_emphasis(const lame_global_flags *);
+
+
+
+/************************************************************************/
+/* internal variables, cannot be set...                                 */
+/* provided because they may be of use to calling application           */
+/************************************************************************/
+/* version  0=MPEG-2  1=MPEG-1  (2=MPEG-2.5)     */
+int CDECL lame_get_version(const lame_global_flags *);
+
+/* encoder delay   */
+int CDECL lame_get_encoder_delay(const lame_global_flags *);
+
+/*
+  padding appended to the input to make sure decoder can fully decode
+  all input.  Note that this value can only be calculated during the
+  call to lame_encoder_flush().  Before lame_encoder_flush() has
+  been called, the value of encoder_padding = 0.
+*/
+int CDECL lame_get_encoder_padding(const lame_global_flags *);
+
+/* size of MPEG frame */
+int CDECL lame_get_framesize(const lame_global_flags *);
+
+/* number of PCM samples buffered, but not yet encoded to mp3 data. */
+int CDECL lame_get_mf_samples_to_encode( const lame_global_flags*  gfp );
+
+/*
+  size (bytes) of mp3 data buffered, but not yet encoded.
+  this is the number of bytes which would be output by a call to
+  lame_encode_flush_nogap.  NOTE: lame_encode_flush() will return
+  more bytes than this because it will encode the reamining buffered
+  PCM samples before flushing the mp3 buffers.
+*/
+int CDECL lame_get_size_mp3buffer( const lame_global_flags*  gfp );
+
+/* number of frames encoded so far */
+int CDECL lame_get_frameNum(const lame_global_flags *);
+
+/*
+  lame's estimate of the total number of frames to be encoded
+   only valid if calling program set num_samples
+*/
+int CDECL lame_get_totalframes(const lame_global_flags *);
+
+/* RadioGain value. Multiplied by 10 and rounded to the nearest. */
+int CDECL lame_get_RadioGain(const lame_global_flags *);
+
+/* AudiophileGain value. Multipled by 10 and rounded to the nearest. */
+int CDECL lame_get_AudiophileGain(const lame_global_flags *);
+
+/* the peak sample */
+float CDECL lame_get_PeakSample(const lame_global_flags *);
+
+/* Gain change required for preventing clipping. The value is correct only if
+   peak sample searching was enabled. If negative then the waveform
+   already does not clip. The value is multiplied by 10 and rounded up. */
+int CDECL lame_get_noclipGainChange(const lame_global_flags *);
+
+/* user-specified scale factor required for preventing clipping. Value is
+   correct only if peak sample searching was enabled and no user-specified
+   scaling was performed. If negative then either the waveform already does
+   not clip or the value cannot be determined */
+float CDECL lame_get_noclipScale(const lame_global_flags *);
+
+
+
+
+
+
+
+/*
+ * REQUIRED:
+ * sets more internal configuration based on data provided above.
+ * returns -1 if something failed.
+ */
+int CDECL lame_init_params(lame_global_flags *);
+
+
+/*
+ * OPTIONAL:
+ * get the version number, in a string. of the form:
+ * "3.63 (beta)" or just "3.63".
+ */
+const char*  CDECL get_lame_version       ( void );
+const char*  CDECL get_lame_short_version ( void );
+const char*  CDECL get_lame_very_short_version ( void );
+const char*  CDECL get_psy_version        ( void );
+const char*  CDECL get_lame_url           ( void );
+const char*  CDECL get_lame_os_bitness    ( void );
+
+/*
+ * OPTIONAL:
+ * get the version numbers in numerical form.
+ */
+typedef struct {
+    /* generic LAME version */
+    int major;
+    int minor;
+    int alpha;               /* 0 if not an alpha version                  */
+    int beta;                /* 0 if not a beta version                    */
+
+    /* version of the psy model */
+    int psy_major;
+    int psy_minor;
+    int psy_alpha;           /* 0 if not an alpha version                  */
+    int psy_beta;            /* 0 if not a beta version                    */
+
+    /* compile time features */
+    const char *features;    /* Don't make assumptions about the contents! */
+} lame_version_t;
+void CDECL get_lame_version_numerical(lame_version_t *);
+
+
+/*
+ * OPTIONAL:
+ * print internal lame configuration to message handler
+ */
+void CDECL lame_print_config(const lame_global_flags*  gfp);
+
+void CDECL lame_print_internals( const lame_global_flags *gfp);
+
+
+/*
+ * input pcm data, output (maybe) mp3 frames.
+ * This routine handles all buffering, resampling and filtering for you.
+ *
+ * return code     number of bytes output in mp3buf. Can be 0
+ *                 -1:  mp3buf was too small
+ *                 -2:  malloc() problem
+ *                 -3:  lame_init_params() not called
+ *                 -4:  psycho acoustic problems
+ *
+ * The required mp3buf_size can be computed from num_samples,
+ * samplerate and encoding rate, but here is a worst case estimate:
+ *
+ * mp3buf_size in bytes = 1.25*num_samples + 7200
+ *
+ * I think a tighter bound could be:  (mt, March 2000)
+ * MPEG1:
+ *    num_samples*(bitrate/8)/samplerate + 4*1152*(bitrate/8)/samplerate + 512
+ * MPEG2:
+ *    num_samples*(bitrate/8)/samplerate + 4*576*(bitrate/8)/samplerate + 256
+ *
+ * but test first if you use that!
+ *
+ * set mp3buf_size = 0 and LAME will not check if mp3buf_size is
+ * large enough.
+ *
+ * NOTE:
+ * if gfp->num_channels=2, but gfp->mode = 3 (mono), the L & R channels
+ * will be averaged into the L channel before encoding only the L channel
+ * This will overwrite the data in buffer_l[] and buffer_r[].
+ *
+*/
+int CDECL lame_encode_buffer (
+        lame_global_flags*  gfp,           /* global context handle         */
+        const short int     buffer_l [],   /* PCM data for left channel     */
+        const short int     buffer_r [],   /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+/*
+ * as above, but input has L & R channel data interleaved.
+ * NOTE:
+ * num_samples = number of samples in the L (or R)
+ * channel, not the total number of samples in pcm[]
+ */
+int CDECL lame_encode_buffer_interleaved(
+        lame_global_flags*  gfp,           /* global context handlei        */
+        short int           pcm[],         /* PCM data for left and right
+                                              channel, interleaved          */
+        int                 num_samples,   /* number of samples per channel,
+                                              _not_ number of samples in
+                                              pcm[]                         */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        int                 mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+
+/* as lame_encode_buffer, but for 'float's.
+ * !! NOTE: !! data must still be scaled to be in the same range as
+ * short int, +/- 32768
+ */
+int CDECL lame_encode_buffer_float(
+        lame_global_flags*  gfp,           /* global context handle         */
+        const float     buffer_l [],       /* PCM data for left channel     */
+        const float     buffer_r [],       /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+
+/* as lame_encode_buffer, but for long's
+ * !! NOTE: !! data must still be scaled to be in the same range as
+ * short int, +/- 32768
+ *
+ * This scaling was a mistake (doesn't allow one to exploit full
+ * precision of type 'long'.  Use lame_encode_buffer_long2() instead.
+ *
+ */
+int CDECL lame_encode_buffer_long(
+        lame_global_flags*  gfp,           /* global context handle         */
+        const long     buffer_l [],       /* PCM data for left channel     */
+        const long     buffer_r [],       /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+/* Same as lame_encode_buffer_long(), but with correct scaling.
+ * !! NOTE: !! data must still be scaled to be in the same range as
+ * type 'long'.   Data should be in the range:  +/- 2^(8*size(long)-1)
+ *
+ */
+int CDECL lame_encode_buffer_long2(
+        lame_global_flags*  gfp,           /* global context handle         */
+        const long     buffer_l [],       /* PCM data for left channel     */
+        const long     buffer_r [],       /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+/* as lame_encode_buffer, but for int's
+ * !! NOTE: !! input should be scaled to the maximum range of 'int'
+ * If int is 4 bytes, then the values should range from
+ * +/- 2147483648.
+ *
+ * This routine does not (and cannot, without loosing precision) use
+ * the same scaling as the rest of the lame_encode_buffer() routines.
+ *
+ */
+int CDECL lame_encode_buffer_int(
+        lame_global_flags*  gfp,           /* global context handle         */
+        const int      buffer_l [],       /* PCM data for left channel     */
+        const int      buffer_r [],       /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+
+
+
+
+/*
+ * REQUIRED:
+ * lame_encode_flush will flush the intenal PCM buffers, padding with
+ * 0's to make sure the final frame is complete, and then flush
+ * the internal MP3 buffers, and thus may return a
+ * final few mp3 frames.  'mp3buf' should be at least 7200 bytes long
+ * to hold all possible emitted data.
+ *
+ * will also write id3v1 tags (if any) into the bitstream
+ *
+ * return code = number of bytes output to mp3buf. Can be 0
+ */
+int CDECL lame_encode_flush(
+        lame_global_flags *  gfp,    /* global context handle                 */
+        unsigned char*       mp3buf, /* pointer to encoded MP3 stream         */
+        int                  size);  /* number of valid octets in this stream */
+
+/*
+ * OPTIONAL:
+ * lame_encode_flush_nogap will flush the internal mp3 buffers and pad
+ * the last frame with ancillary data so it is a complete mp3 frame.
+ *
+ * 'mp3buf' should be at least 7200 bytes long
+ * to hold all possible emitted data.
+ *
+ * After a call to this routine, the outputed mp3 data is complete, but
+ * you may continue to encode new PCM samples and write future mp3 data
+ * to a different file.  The two mp3 files will play back with no gaps
+ * if they are concatenated together.
+ *
+ * This routine will NOT write id3v1 tags into the bitstream.
+ *
+ * return code = number of bytes output to mp3buf. Can be 0
+ */
+int CDECL lame_encode_flush_nogap(
+        lame_global_flags *  gfp,    /* global context handle                 */
+        unsigned char*       mp3buf, /* pointer to encoded MP3 stream         */
+        int                  size);  /* number of valid octets in this stream */
+
+/*
+ * OPTIONAL:
+ * Normally, this is called by lame_init_params().  It writes id3v2 and
+ * Xing headers into the front of the bitstream, and sets frame counters
+ * and bitrate histogram data to 0.  You can also call this after
+ * lame_encode_flush_nogap().
+ */
+int CDECL lame_init_bitstream(
+        lame_global_flags *  gfp);    /* global context handle                 */
+
+
+
+/*
+ * OPTIONAL:    some simple statistics
+ * a bitrate histogram to visualize the distribution of used frame sizes
+ * a stereo mode histogram to visualize the distribution of used stereo
+ *   modes, useful in joint-stereo mode only
+ *   0: LR    left-right encoded
+ *   1: LR-I  left-right and intensity encoded (currently not supported)
+ *   2: MS    mid-side encoded
+ *   3: MS-I  mid-side and intensity encoded (currently not supported)
+ *
+ * attention: don't call them after lame_encode_finish
+ * suggested: lame_encode_flush -> lame_*_hist -> lame_close
+ */
+
+void CDECL lame_bitrate_hist(
+        const lame_global_flags * gfp,
+        int bitrate_count[14] );
+void CDECL lame_bitrate_kbps(
+        const lame_global_flags * gfp,
+        int bitrate_kbps [14] );
+void CDECL lame_stereo_mode_hist(
+        const lame_global_flags * gfp,
+        int stereo_mode_count[4] );
+
+void CDECL lame_bitrate_stereo_mode_hist (
+        const lame_global_flags * gfp,
+        int bitrate_stmode_count[14][4] );
+
+void CDECL lame_block_type_hist (
+        const lame_global_flags * gfp,
+        int btype_count[6] );
+
+void CDECL lame_bitrate_block_type_hist (
+        const lame_global_flags * gfp,
+        int bitrate_btype_count[14][6] );
+
+#if (DEPRECATED_OR_OBSOLETE_CODE_REMOVED && 0)
+#else
+/*
+ * OPTIONAL:
+ * lame_mp3_tags_fid will rewrite a Xing VBR tag to the mp3 file with file
+ * pointer fid.  These calls perform forward and backwards seeks, so make
+ * sure fid is a real file.  Make sure lame_encode_flush has been called,
+ * and all mp3 data has been written to the file before calling this
+ * function.
+ * NOTE:
+ * if VBR  tags are turned off by the user, or turned off by LAME because
+ * the output is not a regular file, this call does nothing
+ * NOTE:
+ * LAME wants to read from the file to skip an optional ID3v2 tag, so
+ * make sure you opened the file for writing and reading.
+ * NOTE:
+ * You can call lame_get_lametag_frame instead, if you want to insert
+ * the lametag yourself.
+*/
+void CDECL lame_mp3_tags_fid(lame_global_flags *, FILE* fid);
+#endif
+
+/*
+ * OPTIONAL:
+ * lame_get_lametag_frame copies the final LAME-tag into 'buffer'.
+ * The function returns the number of bytes copied into buffer, or
+ * the required buffer size, if the provided buffer is too small.
+ * Function failed, if the return value is larger than 'size'!
+ * Make sure lame_encode flush has been called before calling this function.
+ * NOTE:
+ * if VBR  tags are turned off by the user, or turned off by LAME,
+ * this call does nothing and returns 0.
+ * NOTE:
+ * LAME inserted an empty frame in the beginning of mp3 audio data,
+ * which you have to replace by the final LAME-tag frame after encoding.
+ * In case there is no ID3v2 tag, usually this frame will be the very first
+ * data in your mp3 file. If you put some other leading data into your
+ * file, you'll have to do some bookkeeping about where to write this buffer.
+ */
+size_t CDECL lame_get_lametag_frame(
+        const lame_global_flags *, unsigned char* buffer, size_t size);
+
+/*
+ * REQUIRED:
+ * final call to free all remaining buffers
+ */
+int  CDECL lame_close (lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/*
+ * OBSOLETE:
+ * lame_encode_finish combines lame_encode_flush() and lame_close() in
+ * one call.  However, once this call is made, the statistics routines
+ * will no longer work because the data will have been cleared, and
+ * lame_mp3_tags_fid() cannot be called to add data to the VBR header
+ */
+int CDECL lame_encode_finish(
+        lame_global_flags*  gfp,
+        unsigned char*      mp3buf,
+        int                 size );
+#endif
+
+
+
+
+
+
+/*********************************************************************
+ *
+ * decoding
+ *
+ * a simple interface to mpglib, part of mpg123, is also included if
+ * libmp3lame is compiled with HAVE_MPGLIB
+ *
+ *********************************************************************/
+
+struct hip_global_struct;
+typedef struct hip_global_struct hip_global_flags;
+typedef hip_global_flags *hip_t;
+
+
+typedef struct {
+  int header_parsed;   /* 1 if header was parsed and following data was
+                          computed                                       */
+  int stereo;          /* number of channels                             */
+  int samplerate;      /* sample rate                                    */
+  int bitrate;         /* bitrate                                        */
+  int mode;            /* mp3 frame type                                 */
+  int mode_ext;        /* mp3 frame type                                 */
+  int framesize;       /* number of samples per mp3 frame                */
+
+  /* this data is only computed if mpglib detects a Xing VBR header */
+  unsigned long nsamp; /* number of samples in mp3 file.                 */
+  int totalframes;     /* total number of frames in mp3 file             */
+
+  /* this data is not currently computed by the mpglib routines */
+  int framenum;        /* frames decoded counter                         */
+} mp3data_struct;
+
+/* required call to initialize decoder */
+hip_t CDECL hip_decode_init(void);
+
+/* cleanup call to exit decoder  */
+int CDECL hip_decode_exit(hip_t gfp);
+
+/*********************************************************************
+ * input 1 mp3 frame, output (maybe) pcm data.
+ *
+ *  nout = hip_decode(hip, mp3buf,len,pcm_l,pcm_r);
+ *
+ * input:
+ *    len          :  number of bytes of mp3 data in mp3buf
+ *    mp3buf[len]  :  mp3 data to be decoded
+ *
+ * output:
+ *    nout:  -1    : decoding error
+ *            0    : need more data before we can complete the decode
+ *           >0    : returned 'nout' samples worth of data in pcm_l,pcm_r
+ *    pcm_l[nout]  : left channel data
+ *    pcm_r[nout]  : right channel data
+ *
+ *********************************************************************/
+int CDECL hip_decode( hip_t           gfp
+                    , unsigned char * mp3buf
+                    , size_t          len
+                    , short           pcm_l[]
+                    , short           pcm_r[]
+                    );
+
+/* same as hip_decode, and also returns mp3 header data */
+int CDECL hip_decode_headers( hip_t           gfp
+                            , unsigned char*  mp3buf
+                            , size_t          len
+                            , short           pcm_l[]
+                            , short           pcm_r[]
+                            , mp3data_struct* mp3data
+                            );
+
+/* same as hip_decode, but returns at most one frame */
+int CDECL hip_decode1( hip_t          gfp
+                     , unsigned char* mp3buf
+                     , size_t         len
+                     , short          pcm_l[]
+                     , short          pcm_r[]
+                     );
+
+/* same as hip_decode1, but returns at most one frame and mp3 header data */
+int CDECL hip_decode1_headers( hip_t           gfp
+                             , unsigned char*  mp3buf
+                             , size_t          len
+                             , short           pcm_l[]
+                             , short           pcm_r[]
+                             , mp3data_struct* mp3data
+                             );
+
+/* same as hip_decode1_headers, but also returns enc_delay and enc_padding
+   from VBR Info tag, (-1 if no info tag was found) */
+int CDECL hip_decode1_headersB( hip_t gfp
+                              , unsigned char*   mp3buf
+                              , size_t           len
+                              , short            pcm_l[]
+                              , short            pcm_r[]
+                              , mp3data_struct*  mp3data
+                              , int             *enc_delay
+                              , int             *enc_padding
+                              );
+
+
+
+/* OBSOLETE:
+ * lame_decode... functions are there to keep old code working
+ * but it is strongly recommended to replace calls by hip_decode...
+ * function calls, see above.
+ */
+#if 1
+int CDECL lame_decode_init(void);
+int CDECL lame_decode(
+        unsigned char *  mp3buf,
+        int              len,
+        short            pcm_l[],
+        short            pcm_r[] );
+int CDECL lame_decode_headers(
+        unsigned char*   mp3buf,
+        int              len,
+        short            pcm_l[],
+        short            pcm_r[],
+        mp3data_struct*  mp3data );
+int CDECL lame_decode1(
+        unsigned char*  mp3buf,
+        int             len,
+        short           pcm_l[],
+        short           pcm_r[] );
+int CDECL lame_decode1_headers(
+        unsigned char*   mp3buf,
+        int              len,
+        short            pcm_l[],
+        short            pcm_r[],
+        mp3data_struct*  mp3data );
+int CDECL lame_decode1_headersB(
+        unsigned char*   mp3buf,
+        int              len,
+        short            pcm_l[],
+        short            pcm_r[],
+        mp3data_struct*  mp3data,
+        int              *enc_delay,
+        int              *enc_padding );
+int CDECL lame_decode_exit(void);
+
+#endif /* obsolete lame_decode API calls */
+
+
+/*********************************************************************
+ *
+ * id3tag stuff
+ *
+ *********************************************************************/
+
+/*
+ * id3tag.h -- Interface to write ID3 version 1 and 2 tags.
+ *
+ * Copyright (C) 2000 Don Melton.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* utility to obtain alphabetically sorted list of genre names with numbers */
+void CDECL id3tag_genre_list(
+        void (*handler)(int, const char *, void *),
+        void*  cookie);
+
+void CDECL id3tag_init     (lame_t gfp);
+
+/* force addition of version 2 tag */
+void CDECL id3tag_add_v2   (lame_t gfp);
+
+/* add only a version 1 tag */
+void CDECL id3tag_v1_only  (lame_t gfp);
+
+/* add only a version 2 tag */
+void CDECL id3tag_v2_only  (lame_t gfp);
+
+/* pad version 1 tag with spaces instead of nulls */
+void CDECL id3tag_space_v1 (lame_t gfp);
+
+/* pad version 2 tag with extra 128 bytes */
+void CDECL id3tag_pad_v2   (lame_t gfp);
+
+/* pad version 2 tag with extra n bytes */
+void CDECL id3tag_set_pad  (lame_t gfp, size_t n);
+
+void CDECL id3tag_set_title(lame_t gfp, const char* title);
+void CDECL id3tag_set_artist(lame_t gfp, const char* artist);
+void CDECL id3tag_set_album(lame_t gfp, const char* album);
+void CDECL id3tag_set_year(lame_t gfp, const char* year);
+void CDECL id3tag_set_comment(lame_t gfp, const char* comment);
+            
+/* return -1 result if track number is out of ID3v1 range
+                    and ignored for ID3v1 */
+int CDECL id3tag_set_track(lame_t gfp, const char* track);
+
+/* return non-zero result if genre name or number is invalid
+  result 0: OK
+  result -1: genre number out of range
+  result -2: no valid ID3v1 genre name, mapped to ID3v1 'Other'
+             but taken as-is for ID3v2 genre tag */
+int CDECL id3tag_set_genre(lame_t gfp, const char* genre);
+
+/* return non-zero result if field name is invalid */
+int CDECL id3tag_set_fieldvalue(lame_t gfp, const char* fieldvalue);
+
+/* return non-zero result if image type is invalid */
+int CDECL id3tag_set_albumart(lame_t gfp, const char* image, size_t size);
+
+/* lame_get_id3v1_tag copies ID3v1 tag into buffer.
+ * Function returns number of bytes copied into buffer, or number
+ * of bytes rquired if buffer 'size' is too small.
+ * Function fails, if returned value is larger than 'size'.
+ * NOTE:
+ * This functions does nothing, if user/LAME disabled ID3v1 tag.
+ */
+size_t CDECL lame_get_id3v1_tag(lame_t gfp, unsigned char* buffer, size_t size);
+
+/* lame_get_id3v2_tag copies ID3v2 tag into buffer.
+ * Function returns number of bytes copied into buffer, or number
+ * of bytes rquired if buffer 'size' is too small.
+ * Function fails, if returned value is larger than 'size'.
+ * NOTE:
+ * This functions does nothing, if user/LAME disabled ID3v2 tag.
+ */
+size_t CDECL lame_get_id3v2_tag(lame_t gfp, unsigned char* buffer, size_t size);
+
+/* normaly lame_init_param writes ID3v2 tags into the audio stream
+ * Call lame_set_write_id3tag_automatic(gfp, 0) before lame_init_param
+ * to turn off this behaviour and get ID3v2 tag with above function
+ * write it yourself into your file.
+ */
+void CDECL lame_set_write_id3tag_automatic(lame_global_flags * gfp, int);
+int CDECL lame_get_write_id3tag_automatic(lame_global_flags const* gfp);
+
+/***********************************************************************
+*
+*  list of valid bitrates [kbps] & sample frequencies [Hz].
+*  first index: 0: MPEG-2   values  (sample frequencies 16...24 kHz)
+*               1: MPEG-1   values  (sample frequencies 32...48 kHz)
+*               2: MPEG-2.5 values  (sample frequencies  8...12 kHz)
+***********************************************************************/
+extern const int      bitrate_table    [3] [16];
+extern const int      samplerate_table [3] [ 4];
+
+
+
+/* maximum size of albumart image (128KB), which affects LAME_MAXMP3BUFFER
+   as well since lame_encode_buffer() also returns ID3v2 tag data */
+#define LAME_MAXALBUMART    (128 * 1024)
+
+/* maximum size of mp3buffer needed if you encode at most 1152 samples for
+   each call to lame_encode_buffer.  see lame_encode_buffer() below  
+   (LAME_MAXMP3BUFFER is now obsolete)  */
+#define LAME_MAXMP3BUFFER   (16384 + LAME_MAXALBUMART)
+
+
+typedef enum {
+    LAME_OKAY             =   0,
+    LAME_NOERROR          =   0,
+    LAME_GENERICERROR     =  -1,
+    LAME_NOMEM            = -10,
+    LAME_BADBITRATE       = -11,
+    LAME_BADSAMPFREQ      = -12,
+    LAME_INTERNALERROR    = -13,
+
+    FRONTEND_READERROR    = -80,
+    FRONTEND_WRITEERROR   = -81,
+    FRONTEND_FILETOOLARGE = -82
+
+} lame_errorcodes_t;
+
+#if defined(__cplusplus)
+}
+#endif
+#endif /* LAME_LAME_H */
+
--- ffmpeg-2.5/localinc/neaacdec.h.dl_headers~	2014-12-04 22:53:11.253165674 +0100
+++ ffmpeg-2.5/localinc/neaacdec.h	2014-12-04 22:53:11.253165674 +0100
@@ -0,0 +1,258 @@
+/*
+** FAAD2 - Freeware Advanced Audio (AAC) Decoder including SBR decoding
+** Copyright (C) 2003-2005 M. Bakker, Nero AG, http://www.nero.com
+**  
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+** 
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+** 
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software 
+** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+**
+** Any non-GPL usage of this software or parts of this software is strictly
+** forbidden.
+**
+** The "appropriate copyright message" mentioned in section 2c of the GPLv2
+** must read: "Code from FAAD2 is copyright (c) Nero AG, www.nero.com"
+**
+** Commercial non-GPL licensing of this software is possible.
+** For more info contact Nero AG through Mpeg4AAClicense@nero.com.
+**
+** $Id: neaacdec.h,v 1.13 2009/01/26 23:51:15 menno Exp $
+**/
+
+#ifndef __NEAACDEC_H__
+#define __NEAACDEC_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+#if 1
+/* MACROS FOR BACKWARDS COMPATIBILITY */
+/* structs */
+#define faacDecHandle                  NeAACDecHandle
+#define faacDecConfiguration           NeAACDecConfiguration
+#define faacDecConfigurationPtr        NeAACDecConfigurationPtr
+#define faacDecFrameInfo               NeAACDecFrameInfo
+/* functions */
+#define faacDecGetErrorMessage         NeAACDecGetErrorMessage
+#define faacDecSetConfiguration        NeAACDecSetConfiguration
+#define faacDecGetCurrentConfiguration NeAACDecGetCurrentConfiguration
+#define faacDecInit                    NeAACDecInit
+#define faacDecInit2                   NeAACDecInit2
+#define faacDecInitDRM                 NeAACDecInitDRM
+#define faacDecPostSeekReset           NeAACDecPostSeekReset
+#define faacDecOpen                    NeAACDecOpen
+#define faacDecClose                   NeAACDecClose
+#define faacDecDecode                  NeAACDecDecode
+#define AudioSpecificConfig            NeAACDecAudioSpecificConfig
+#endif
+
+
+#ifdef _WIN32
+  #pragma pack(push, 8)
+  #ifndef NEAACDECAPI
+    #define NEAACDECAPI __cdecl
+  #endif
+#else
+  #ifndef NEAACDECAPI
+    #define NEAACDECAPI
+  #endif
+#endif
+
+#define FAAD2_VERSION "2.7"
+
+/* object types for AAC */
+#define MAIN       1
+#define LC         2
+#define SSR        3
+#define LTP        4
+#define HE_AAC     5
+#define ER_LC     17
+#define ER_LTP    19
+#define LD        23
+#define DRM_ER_LC 27 /* special object type for DRM */
+
+/* header types */
+#define RAW        0
+#define ADIF       1
+#define ADTS       2
+#define LATM       3
+
+/* SBR signalling */
+#define NO_SBR           0
+#define SBR_UPSAMPLED    1
+#define SBR_DOWNSAMPLED  2
+#define NO_SBR_UPSAMPLED 3
+
+/* library output formats */
+#define FAAD_FMT_16BIT  1
+#define FAAD_FMT_24BIT  2
+#define FAAD_FMT_32BIT  3
+#define FAAD_FMT_FLOAT  4
+#define FAAD_FMT_FIXED  FAAD_FMT_FLOAT
+#define FAAD_FMT_DOUBLE 5
+
+/* Capabilities */
+#define LC_DEC_CAP           (1<<0) /* Can decode LC */
+#define MAIN_DEC_CAP         (1<<1) /* Can decode MAIN */
+#define LTP_DEC_CAP          (1<<2) /* Can decode LTP */
+#define LD_DEC_CAP           (1<<3) /* Can decode LD */
+#define ERROR_RESILIENCE_CAP (1<<4) /* Can decode ER */
+#define FIXED_POINT_CAP      (1<<5) /* Fixed point */
+
+/* Channel definitions */
+#define FRONT_CHANNEL_CENTER (1)
+#define FRONT_CHANNEL_LEFT   (2)
+#define FRONT_CHANNEL_RIGHT  (3)
+#define SIDE_CHANNEL_LEFT    (4)
+#define SIDE_CHANNEL_RIGHT   (5)
+#define BACK_CHANNEL_LEFT    (6)
+#define BACK_CHANNEL_RIGHT   (7)
+#define BACK_CHANNEL_CENTER  (8)
+#define LFE_CHANNEL          (9)
+#define UNKNOWN_CHANNEL      (0)
+
+/* DRM channel definitions */
+#define DRMCH_MONO          1
+#define DRMCH_STEREO        2
+#define DRMCH_SBR_MONO      3
+#define DRMCH_SBR_STEREO    4
+#define DRMCH_SBR_PS_STEREO 5
+
+
+/* A decode call can eat up to FAAD_MIN_STREAMSIZE bytes per decoded channel,
+   so at least so much bytes per channel should be available in this stream */
+#define FAAD_MIN_STREAMSIZE 768 /* 6144 bits/channel */
+
+
+typedef void *NeAACDecHandle;
+
+typedef struct mp4AudioSpecificConfig
+{
+    /* Audio Specific Info */
+    unsigned char objectTypeIndex;
+    unsigned char samplingFrequencyIndex;
+    unsigned long samplingFrequency;
+    unsigned char channelsConfiguration;
+
+    /* GA Specific Info */
+    unsigned char frameLengthFlag;
+    unsigned char dependsOnCoreCoder;
+    unsigned short coreCoderDelay;
+    unsigned char extensionFlag;
+    unsigned char aacSectionDataResilienceFlag;
+    unsigned char aacScalefactorDataResilienceFlag;
+    unsigned char aacSpectralDataResilienceFlag;
+    unsigned char epConfig;
+
+    char sbr_present_flag;
+    char forceUpSampling;
+    char downSampledSBR;
+} mp4AudioSpecificConfig;
+
+typedef struct NeAACDecConfiguration
+{
+    unsigned char defObjectType;
+    unsigned long defSampleRate;
+    unsigned char outputFormat;
+    unsigned char downMatrix;
+    unsigned char useOldADTSFormat;
+    unsigned char dontUpSampleImplicitSBR;
+} NeAACDecConfiguration, *NeAACDecConfigurationPtr;
+
+typedef struct NeAACDecFrameInfo
+{
+    unsigned long bytesconsumed;
+    unsigned long samples;
+    unsigned char channels;
+    unsigned char error;
+    unsigned long samplerate;
+
+    /* SBR: 0: off, 1: on; upsample, 2: on; downsampled, 3: off; upsampled */
+    unsigned char sbr;
+
+    /* MPEG-4 ObjectType */
+    unsigned char object_type;
+
+    /* AAC header type; MP4 will be signalled as RAW also */
+    unsigned char header_type;
+
+    /* multichannel configuration */
+    unsigned char num_front_channels;
+    unsigned char num_side_channels;
+    unsigned char num_back_channels;
+    unsigned char num_lfe_channels;
+    unsigned char channel_position[64];
+
+    /* PS: 0: off, 1: on */
+    unsigned char ps;
+} NeAACDecFrameInfo;
+
+char* NEAACDECAPI NeAACDecGetErrorMessage(unsigned char errcode);
+
+unsigned long NEAACDECAPI NeAACDecGetCapabilities(void);
+
+NeAACDecHandle NEAACDECAPI NeAACDecOpen(void);
+
+NeAACDecConfigurationPtr NEAACDECAPI NeAACDecGetCurrentConfiguration(NeAACDecHandle hDecoder);
+
+unsigned char NEAACDECAPI NeAACDecSetConfiguration(NeAACDecHandle hDecoder,
+                                                   NeAACDecConfigurationPtr config);
+
+/* Init the library based on info from the AAC file (ADTS/ADIF) */
+long NEAACDECAPI NeAACDecInit(NeAACDecHandle hDecoder,
+                              unsigned char *buffer,
+                              unsigned long buffer_size,
+                              unsigned long *samplerate,
+                              unsigned char *channels);
+
+/* Init the library using a DecoderSpecificInfo */
+char NEAACDECAPI NeAACDecInit2(NeAACDecHandle hDecoder,
+                               unsigned char *pBuffer,
+                               unsigned long SizeOfDecoderSpecificInfo,
+                               unsigned long *samplerate,
+                               unsigned char *channels);
+
+/* Init the library for DRM */
+char NEAACDECAPI NeAACDecInitDRM(NeAACDecHandle *hDecoder, unsigned long samplerate,
+                                 unsigned char channels);
+
+void NEAACDECAPI NeAACDecPostSeekReset(NeAACDecHandle hDecoder, long frame);
+
+void NEAACDECAPI NeAACDecClose(NeAACDecHandle hDecoder);
+
+void* NEAACDECAPI NeAACDecDecode(NeAACDecHandle hDecoder,
+                                 NeAACDecFrameInfo *hInfo,
+                                 unsigned char *buffer,
+                                 unsigned long buffer_size);
+
+void* NEAACDECAPI NeAACDecDecode2(NeAACDecHandle hDecoder,
+                                  NeAACDecFrameInfo *hInfo,
+                                  unsigned char *buffer,
+                                  unsigned long buffer_size,
+                                  void **sample_buffer,
+                                  unsigned long sample_buffer_size);
+
+char NEAACDECAPI NeAACDecAudioSpecificConfig(unsigned char *pBuffer,
+                                             unsigned long buffer_size,
+                                             mp4AudioSpecificConfig *mp4ASC);
+
+#ifdef _WIN32
+  #pragma pack(pop)
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
--- ffmpeg-2.5/localinc/opencore-amrnb/interf_dec.h.dl_headers~	2014-12-04 22:53:11.253165674 +0100
+++ ffmpeg-2.5/localinc/opencore-amrnb/interf_dec.h	2014-12-04 22:53:11.253165674 +0100
@@ -0,0 +1,34 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 2009 Martin Storsjo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+#ifndef OPENCORE_AMRNB_INTERF_DEC_H
+#define OPENCORE_AMRNB_INTERF_DEC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void* Decoder_Interface_init(void);
+void Decoder_Interface_exit(void* state);
+void Decoder_Interface_Decode(void* state, const unsigned char* in, short* out, int bfi);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- ffmpeg-2.5/localinc/opencore-amrnb/interf_enc.h.dl_headers~	2014-12-04 22:53:11.256498996 +0100
+++ ffmpeg-2.5/localinc/opencore-amrnb/interf_enc.h	2014-12-04 22:53:11.256498996 +0100
@@ -0,0 +1,50 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 2009 Martin Storsjo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+#ifndef OPENCORE_AMRNB_INTERF_ENC_H
+#define OPENCORE_AMRNB_INTERF_ENC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef AMRNB_WRAPPER_INTERNAL
+/* Copied from enc/src/gsmamr_enc.h */
+enum Mode {
+	MR475 = 0,/* 4.75 kbps */
+	MR515,    /* 5.15 kbps */
+	MR59,     /* 5.90 kbps */
+	MR67,     /* 6.70 kbps */
+	MR74,     /* 7.40 kbps */
+	MR795,    /* 7.95 kbps */
+	MR102,    /* 10.2 kbps */
+	MR122,    /* 12.2 kbps */
+	MRDTX,    /* DTX       */
+	N_MODES   /* Not Used  */
+};
+#endif
+
+void* Encoder_Interface_init(int dtx);
+void Encoder_Interface_exit(void* state);
+int Encoder_Interface_Encode(void* state, enum Mode mode, const short* speech, unsigned char* out, int forceSpeech);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- ffmpeg-2.5/localinc/opencore-amrwb/dec_if.h.dl_headers~	2014-12-04 22:53:11.256498996 +0100
+++ ffmpeg-2.5/localinc/opencore-amrwb/dec_if.h	2014-12-04 22:53:11.256498996 +0100
@@ -0,0 +1,36 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 2009 Martin Storsjo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+#ifndef OPENCORE_AMRWB_DEC_IF_H
+#define OPENCORE_AMRWB_DEC_IF_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define _good_frame 0
+
+void* D_IF_init(void);
+void D_IF_decode(void* state, const unsigned char* bits, short* synth, int bfi);
+void D_IF_exit(void* state);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- ffmpeg-2.5/localinc/opencore-amrwb/if_rom.h.dl_headers~	2014-12-04 22:53:11.256498996 +0100
+++ ffmpeg-2.5/localinc/opencore-amrwb/if_rom.h	2014-12-04 22:53:11.256498996 +0100
@@ -0,0 +1,33 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 2009 Martin Storsjo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+#ifndef OPENCORE_AMRWB_IF_ROM_H
+#define OPENCORE_AMRWB_IF_ROM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+typedef int16_t Word16;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- ffmpeg-2.5/localinc/x264_config.h.dl_headers~	2014-12-04 22:53:11.256498996 +0100
+++ ffmpeg-2.5/localinc/x264_config.h	2014-12-04 22:54:30.576345593 +0100
@@ -0,0 +1,6 @@
+#define X264_BIT_DEPTH     8
+#define X264_GPL           1
+#define X264_INTERLACED    1
+#define X264_CHROMA_FORMAT 0
+#define X264_VERSION ""
+#define X264_POINTVER "0.142.x"
--- ffmpeg-2.5/localinc/x264.h.dl_headers~	2014-12-04 22:53:11.256498996 +0100
+++ ffmpeg-2.5/localinc/x264.h	2014-12-04 22:54:31.169677729 +0100
@@ -0,0 +1,947 @@
+/*****************************************************************************
+ * x264.h: x264 public header
+ *****************************************************************************
+ * Copyright (C) 2003-2014 x264 project
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *          Loren Merritt <lorenm@u.washington.edu>
+ *          Fiona Glaser <fiona@x264.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111, USA.
+ *
+ * This program is also available under a commercial proprietary license.
+ * For more information, contact us at licensing@x264.com.
+ *****************************************************************************/
+
+#ifndef X264_X264_H
+#define X264_X264_H
+
+#if !defined(_STDINT_H) && !defined(_STDINT_H_) && !defined(_STDINT_H_INCLUDED) &&\
+    !defined(_INTTYPES_H) && !defined(_INTTYPES_H_)
+# ifdef _MSC_VER
+#  pragma message("You must include stdint.h or inttypes.h before x264.h")
+# else
+#  warning You must include stdint.h or inttypes.h before x264.h
+# endif
+#endif
+
+#include <stdarg.h>
+
+#include "x264_config.h"
+
+#define X264_BUILD 142
+
+/* Application developers planning to link against a shared library version of
+ * libx264 from a Microsoft Visual Studio or similar development environment
+ * will need to define X264_API_IMPORTS before including this header.
+ * This clause does not apply to MinGW, similar development environments, or non
+ * Windows platforms. */
+#ifdef X264_API_IMPORTS
+#define X264_API __declspec(dllimport)
+#else
+#define X264_API
+#endif
+
+/* x264_t:
+ *      opaque handler for encoder */
+typedef struct x264_t x264_t;
+
+/****************************************************************************
+ * NAL structure and functions
+ ****************************************************************************/
+
+enum nal_unit_type_e
+{
+    NAL_UNKNOWN     = 0,
+    NAL_SLICE       = 1,
+    NAL_SLICE_DPA   = 2,
+    NAL_SLICE_DPB   = 3,
+    NAL_SLICE_DPC   = 4,
+    NAL_SLICE_IDR   = 5,    /* ref_idc != 0 */
+    NAL_SEI         = 6,    /* ref_idc == 0 */
+    NAL_SPS         = 7,
+    NAL_PPS         = 8,
+    NAL_AUD         = 9,
+    NAL_FILLER      = 12,
+    /* ref_idc == 0 for 6,9,10,11,12 */
+};
+enum nal_priority_e
+{
+    NAL_PRIORITY_DISPOSABLE = 0,
+    NAL_PRIORITY_LOW        = 1,
+    NAL_PRIORITY_HIGH       = 2,
+    NAL_PRIORITY_HIGHEST    = 3,
+};
+
+/* The data within the payload is already NAL-encapsulated; the ref_idc and type
+ * are merely in the struct for easy access by the calling application.
+ * All data returned in an x264_nal_t, including the data in p_payload, is no longer
+ * valid after the next call to x264_encoder_encode.  Thus it must be used or copied
+ * before calling x264_encoder_encode or x264_encoder_headers again. */
+typedef struct
+{
+    int i_ref_idc;  /* nal_priority_e */
+    int i_type;     /* nal_unit_type_e */
+    int b_long_startcode;
+    int i_first_mb; /* If this NAL is a slice, the index of the first MB in the slice. */
+    int i_last_mb;  /* If this NAL is a slice, the index of the last MB in the slice. */
+
+    /* Size of payload (including any padding) in bytes. */
+    int     i_payload;
+    /* If param->b_annexb is set, Annex-B bytestream with startcode.
+     * Otherwise, startcode is replaced with a 4-byte size.
+     * This size is the size used in mp4/similar muxing; it is equal to i_payload-4 */
+    uint8_t *p_payload;
+
+    /* Size of padding in bytes. */
+    int i_padding;
+} x264_nal_t;
+
+/****************************************************************************
+ * Encoder parameters
+ ****************************************************************************/
+/* CPU flags */
+
+/* x86 */
+#define X264_CPU_CMOV            0x0000001
+#define X264_CPU_MMX             0x0000002
+#define X264_CPU_MMX2            0x0000004  /* MMX2 aka MMXEXT aka ISSE */
+#define X264_CPU_MMXEXT          X264_CPU_MMX2
+#define X264_CPU_SSE             0x0000008
+#define X264_CPU_SSE2            0x0000010
+#define X264_CPU_SSE3            0x0000020
+#define X264_CPU_SSSE3           0x0000040
+#define X264_CPU_SSE4            0x0000080  /* SSE4.1 */
+#define X264_CPU_SSE42           0x0000100  /* SSE4.2 */
+#define X264_CPU_LZCNT           0x0000200  /* Phenom support for "leading zero count" instruction. */
+#define X264_CPU_AVX             0x0000400  /* AVX support: requires OS support even if YMM registers aren't used. */
+#define X264_CPU_XOP             0x0000800  /* AMD XOP */
+#define X264_CPU_FMA4            0x0001000  /* AMD FMA4 */
+#define X264_CPU_AVX2            0x0002000  /* AVX2 */
+#define X264_CPU_FMA3            0x0004000  /* Intel FMA3 */
+#define X264_CPU_BMI1            0x0008000  /* BMI1 */
+#define X264_CPU_BMI2            0x0010000  /* BMI2 */
+/* x86 modifiers */
+#define X264_CPU_CACHELINE_32    0x0020000  /* avoid memory loads that span the border between two cachelines */
+#define X264_CPU_CACHELINE_64    0x0040000  /* 32/64 is the size of a cacheline in bytes */
+#define X264_CPU_SSE2_IS_SLOW    0x0080000  /* avoid most SSE2 functions on Athlon64 */
+#define X264_CPU_SSE2_IS_FAST    0x0100000  /* a few functions are only faster on Core2 and Phenom */
+#define X264_CPU_SLOW_SHUFFLE    0x0200000  /* The Conroe has a slow shuffle unit (relative to overall SSE performance) */
+#define X264_CPU_STACK_MOD4      0x0400000  /* if stack is only mod4 and not mod16 */
+#define X264_CPU_SLOW_CTZ        0x0800000  /* BSR/BSF x86 instructions are really slow on some CPUs */
+#define X264_CPU_SLOW_ATOM       0x1000000  /* The Atom is terrible: slow SSE unaligned loads, slow
+                                             * SIMD multiplies, slow SIMD variable shifts, slow pshufb,
+                                             * cacheline split penalties -- gather everything here that
+                                             * isn't shared by other CPUs to avoid making half a dozen
+                                             * new SLOW flags. */
+#define X264_CPU_SLOW_PSHUFB     0x2000000  /* such as on the Intel Atom */
+#define X264_CPU_SLOW_PALIGNR    0x4000000  /* such as on the AMD Bobcat */
+
+/* PowerPC */
+#define X264_CPU_ALTIVEC         0x0000001
+
+/* ARM */
+#define X264_CPU_ARMV6           0x0000001
+#define X264_CPU_NEON            0x0000002  /* ARM NEON */
+#define X264_CPU_FAST_NEON_MRC   0x0000004  /* Transfer from NEON to ARM register is fast (Cortex-A9) */
+
+/* Analyse flags */
+#define X264_ANALYSE_I4x4       0x0001  /* Analyse i4x4 */
+#define X264_ANALYSE_I8x8       0x0002  /* Analyse i8x8 (requires 8x8 transform) */
+#define X264_ANALYSE_PSUB16x16  0x0010  /* Analyse p16x8, p8x16 and p8x8 */
+#define X264_ANALYSE_PSUB8x8    0x0020  /* Analyse p8x4, p4x8, p4x4 */
+#define X264_ANALYSE_BSUB16x16  0x0100  /* Analyse b16x8, b8x16 and b8x8 */
+#define X264_DIRECT_PRED_NONE        0
+#define X264_DIRECT_PRED_SPATIAL     1
+#define X264_DIRECT_PRED_TEMPORAL    2
+#define X264_DIRECT_PRED_AUTO        3
+#define X264_ME_DIA                  0
+#define X264_ME_HEX                  1
+#define X264_ME_UMH                  2
+#define X264_ME_ESA                  3
+#define X264_ME_TESA                 4
+#define X264_CQM_FLAT                0
+#define X264_CQM_JVT                 1
+#define X264_CQM_CUSTOM              2
+#define X264_RC_CQP                  0
+#define X264_RC_CRF                  1
+#define X264_RC_ABR                  2
+#define X264_QP_AUTO                 0
+#define X264_AQ_NONE                 0
+#define X264_AQ_VARIANCE             1
+#define X264_AQ_AUTOVARIANCE         2
+#define X264_B_ADAPT_NONE            0
+#define X264_B_ADAPT_FAST            1
+#define X264_B_ADAPT_TRELLIS         2
+#define X264_WEIGHTP_NONE            0
+#define X264_WEIGHTP_SIMPLE          1
+#define X264_WEIGHTP_SMART           2
+#define X264_B_PYRAMID_NONE          0
+#define X264_B_PYRAMID_STRICT        1
+#define X264_B_PYRAMID_NORMAL        2
+#define X264_KEYINT_MIN_AUTO         0
+#define X264_KEYINT_MAX_INFINITE     (1<<30)
+
+static const char * const x264_direct_pred_names[] = { "none", "spatial", "temporal", "auto", 0 };
+static const char * const x264_motion_est_names[] = { "dia", "hex", "umh", "esa", "tesa", 0 };
+static const char * const x264_b_pyramid_names[] = { "none", "strict", "normal", 0 };
+static const char * const x264_overscan_names[] = { "undef", "show", "crop", 0 };
+static const char * const x264_vidformat_names[] = { "component", "pal", "ntsc", "secam", "mac", "undef", 0 };
+static const char * const x264_fullrange_names[] = { "off", "on", 0 };
+static const char * const x264_colorprim_names[] = { "", "bt709", "undef", "", "bt470m", "bt470bg", "smpte170m", "smpte240m", "film", "bt2020", 0 };
+static const char * const x264_transfer_names[] = { "", "bt709", "undef", "", "bt470m", "bt470bg", "smpte170m", "smpte240m", "linear", "log100", "log316",
+                                                    "iec61966-2-4", "bt1361e", "iec61966-2-1", "bt2020-10", "bt2020-12", 0 };
+static const char * const x264_colmatrix_names[] = { "GBR", "bt709", "undef", "", "fcc", "bt470bg", "smpte170m", "smpte240m", "YCgCo", "bt2020nc", "bt2020c", 0 };
+static const char * const x264_nal_hrd_names[] = { "none", "vbr", "cbr", 0 };
+
+/* Colorspace type */
+#define X264_CSP_MASK           0x00ff  /* */
+#define X264_CSP_NONE           0x0000  /* Invalid mode     */
+#define X264_CSP_I420           0x0001  /* yuv 4:2:0 planar */
+#define X264_CSP_YV12           0x0002  /* yvu 4:2:0 planar */
+#define X264_CSP_NV12           0x0003  /* yuv 4:2:0, with one y plane and one packed u+v */
+#define X264_CSP_I422           0x0004  /* yuv 4:2:2 planar */
+#define X264_CSP_YV16           0x0005  /* yvu 4:2:2 planar */
+#define X264_CSP_NV16           0x0006  /* yuv 4:2:2, with one y plane and one packed u+v */
+#define X264_CSP_V210           0x0007  /* 10-bit yuv 4:2:2 packed in 32 */
+#define X264_CSP_I444           0x0008  /* yuv 4:4:4 planar */
+#define X264_CSP_YV24           0x0009  /* yvu 4:4:4 planar */
+#define X264_CSP_BGR            0x000a  /* packed bgr 24bits   */
+#define X264_CSP_BGRA           0x000b  /* packed bgr 32bits   */
+#define X264_CSP_RGB            0x000c  /* packed rgb 24bits   */
+#define X264_CSP_MAX            0x000d  /* end of list */
+#define X264_CSP_VFLIP          0x1000  /* the csp is vertically flipped */
+#define X264_CSP_HIGH_DEPTH     0x2000  /* the csp has a depth of 16 bits per pixel component */
+
+/* Slice type */
+#define X264_TYPE_AUTO          0x0000  /* Let x264 choose the right type */
+#define X264_TYPE_IDR           0x0001
+#define X264_TYPE_I             0x0002
+#define X264_TYPE_P             0x0003
+#define X264_TYPE_BREF          0x0004  /* Non-disposable B-frame */
+#define X264_TYPE_B             0x0005
+#define X264_TYPE_KEYFRAME      0x0006  /* IDR or I depending on b_open_gop option */
+#define IS_X264_TYPE_I(x) ((x)==X264_TYPE_I || (x)==X264_TYPE_IDR)
+#define IS_X264_TYPE_B(x) ((x)==X264_TYPE_B || (x)==X264_TYPE_BREF)
+
+/* Log level */
+#define X264_LOG_NONE          (-1)
+#define X264_LOG_ERROR          0
+#define X264_LOG_WARNING        1
+#define X264_LOG_INFO           2
+#define X264_LOG_DEBUG          3
+
+/* Threading */
+#define X264_THREADS_AUTO 0 /* Automatically select optimal number of threads */
+#define X264_SYNC_LOOKAHEAD_AUTO (-1) /* Automatically select optimal lookahead thread buffer size */
+
+/* HRD */
+#define X264_NAL_HRD_NONE            0
+#define X264_NAL_HRD_VBR             1
+#define X264_NAL_HRD_CBR             2
+
+/* Zones: override ratecontrol or other options for specific sections of the video.
+ * See x264_encoder_reconfig() for which options can be changed.
+ * If zones overlap, whichever comes later in the list takes precedence. */
+typedef struct
+{
+    int i_start, i_end; /* range of frame numbers */
+    int b_force_qp; /* whether to use qp vs bitrate factor */
+    int i_qp;
+    float f_bitrate_factor;
+    struct x264_param_t *param;
+} x264_zone_t;
+
+typedef struct x264_param_t
+{
+    /* CPU flags */
+    unsigned int cpu;
+    int         i_threads;           /* encode multiple frames in parallel */
+    int         i_lookahead_threads; /* multiple threads for lookahead analysis */
+    int         b_sliced_threads;  /* Whether to use slice-based threading. */
+    int         b_deterministic; /* whether to allow non-deterministic optimizations when threaded */
+    int         b_cpu_independent; /* force canonical behavior rather than cpu-dependent optimal algorithms */
+    int         i_sync_lookahead; /* threaded lookahead buffer */
+
+    /* Video Properties */
+    int         i_width;
+    int         i_height;
+    int         i_csp;         /* CSP of encoded bitstream */
+    int         i_level_idc;
+    int         i_frame_total; /* number of frames to encode if known, else 0 */
+
+    /* NAL HRD
+     * Uses Buffering and Picture Timing SEIs to signal HRD
+     * The HRD in H.264 was not designed with VFR in mind.
+     * It is therefore not recommendeded to use NAL HRD with VFR.
+     * Furthermore, reconfiguring the VBV (via x264_encoder_reconfig)
+     * will currently generate invalid HRD. */
+    int         i_nal_hrd;
+
+    struct
+    {
+        /* they will be reduced to be 0 < x <= 65535 and prime */
+        int         i_sar_height;
+        int         i_sar_width;
+
+        int         i_overscan;    /* 0=undef, 1=no overscan, 2=overscan */
+
+        /* see h264 annex E for the values of the following */
+        int         i_vidformat;
+        int         b_fullrange;
+        int         i_colorprim;
+        int         i_transfer;
+        int         i_colmatrix;
+        int         i_chroma_loc;    /* both top & bottom */
+    } vui;
+
+    /* Bitstream parameters */
+    int         i_frame_reference;  /* Maximum number of reference frames */
+    int         i_dpb_size;         /* Force a DPB size larger than that implied by B-frames and reference frames.
+                                     * Useful in combination with interactive error resilience. */
+    int         i_keyint_max;       /* Force an IDR keyframe at this interval */
+    int         i_keyint_min;       /* Scenecuts closer together than this are coded as I, not IDR. */
+    int         i_scenecut_threshold; /* how aggressively to insert extra I frames */
+    int         b_intra_refresh;    /* Whether or not to use periodic intra refresh instead of IDR frames. */
+
+    int         i_bframe;   /* how many b-frame between 2 references pictures */
+    int         i_bframe_adaptive;
+    int         i_bframe_bias;
+    int         i_bframe_pyramid;   /* Keep some B-frames as references: 0=off, 1=strict hierarchical, 2=normal */
+    int         b_open_gop;
+    int         b_bluray_compat;
+    int         i_avcintra_class;
+
+    int         b_deblocking_filter;
+    int         i_deblocking_filter_alphac0;    /* [-6, 6] -6 light filter, 6 strong */
+    int         i_deblocking_filter_beta;       /* [-6, 6]  idem */
+
+    int         b_cabac;
+    int         i_cabac_init_idc;
+
+    int         b_interlaced;
+    int         b_constrained_intra;
+
+    int         i_cqm_preset;
+    char        *psz_cqm_file;      /* filename (in UTF-8) of CQM file, JM format */
+    uint8_t     cqm_4iy[16];        /* used only if i_cqm_preset == X264_CQM_CUSTOM */
+    uint8_t     cqm_4py[16];
+    uint8_t     cqm_4ic[16];
+    uint8_t     cqm_4pc[16];
+    uint8_t     cqm_8iy[64];
+    uint8_t     cqm_8py[64];
+    uint8_t     cqm_8ic[64];
+    uint8_t     cqm_8pc[64];
+
+    /* Log */
+    void        (*pf_log)( void *, int i_level, const char *psz, va_list );
+    void        *p_log_private;
+    int         i_log_level;
+    int         b_full_recon;   /* fully reconstruct frames, even when not necessary for encoding.  Implied by psz_dump_yuv */
+    char        *psz_dump_yuv;  /* filename (in UTF-8) for reconstructed frames */
+
+    /* Encoder analyser parameters */
+    struct
+    {
+        unsigned int intra;     /* intra partitions */
+        unsigned int inter;     /* inter partitions */
+
+        int          b_transform_8x8;
+        int          i_weighted_pred; /* weighting for P-frames */
+        int          b_weighted_bipred; /* implicit weighting for B-frames */
+        int          i_direct_mv_pred; /* spatial vs temporal mv prediction */
+        int          i_chroma_qp_offset;
+
+        int          i_me_method; /* motion estimation algorithm to use (X264_ME_*) */
+        int          i_me_range; /* integer pixel motion estimation search range (from predicted mv) */
+        int          i_mv_range; /* maximum length of a mv (in pixels). -1 = auto, based on level */
+        int          i_mv_range_thread; /* minimum space between threads. -1 = auto, based on number of threads. */
+        int          i_subpel_refine; /* subpixel motion estimation quality */
+        int          b_chroma_me; /* chroma ME for subpel and mode decision in P-frames */
+        int          b_mixed_references; /* allow each mb partition to have its own reference number */
+        int          i_trellis;  /* trellis RD quantization */
+        int          b_fast_pskip; /* early SKIP detection on P-frames */
+        int          b_dct_decimate; /* transform coefficient thresholding on P-frames */
+        int          i_noise_reduction; /* adaptive pseudo-deadzone */
+        float        f_psy_rd; /* Psy RD strength */
+        float        f_psy_trellis; /* Psy trellis strength */
+        int          b_psy; /* Toggle all psy optimizations */
+
+        int          b_mb_info;            /* Use input mb_info data in x264_picture_t */
+        int          b_mb_info_update; /* Update the values in mb_info according to the results of encoding. */
+
+        /* the deadzone size that will be used in luma quantization */
+        int          i_luma_deadzone[2]; /* {inter, intra} */
+
+        int          b_psnr;    /* compute and print PSNR stats */
+        int          b_ssim;    /* compute and print SSIM stats */
+    } analyse;
+
+    /* Rate control parameters */
+    struct
+    {
+        int         i_rc_method;    /* X264_RC_* */
+
+        int         i_qp_constant;  /* 0 to (51 + 6*(x264_bit_depth-8)). 0=lossless */
+        int         i_qp_min;       /* min allowed QP value */
+        int         i_qp_max;       /* max allowed QP value */
+        int         i_qp_step;      /* max QP step between frames */
+
+        int         i_bitrate;
+        float       f_rf_constant;  /* 1pass VBR, nominal QP */
+        float       f_rf_constant_max;  /* In CRF mode, maximum CRF as caused by VBV */
+        float       f_rate_tolerance;
+        int         i_vbv_max_bitrate;
+        int         i_vbv_buffer_size;
+        float       f_vbv_buffer_init; /* <=1: fraction of buffer_size. >1: kbit */
+        float       f_ip_factor;
+        float       f_pb_factor;
+
+        /* VBV filler: force CBR VBV and use filler bytes to ensure hard-CBR.
+         * Implied by NAL-HRD CBR. */
+        int         b_filler;
+
+        int         i_aq_mode;      /* psy adaptive QP. (X264_AQ_*) */
+        float       f_aq_strength;
+        int         b_mb_tree;      /* Macroblock-tree ratecontrol. */
+        int         i_lookahead;
+
+        /* 2pass */
+        int         b_stat_write;   /* Enable stat writing in psz_stat_out */
+        char        *psz_stat_out;  /* output filename (in UTF-8) of the 2pass stats file */
+        int         b_stat_read;    /* Read stat from psz_stat_in and use it */
+        char        *psz_stat_in;   /* input filename (in UTF-8) of the 2pass stats file */
+
+        /* 2pass params (same as ffmpeg ones) */
+        float       f_qcompress;    /* 0.0 => cbr, 1.0 => constant qp */
+        float       f_qblur;        /* temporally blur quants */
+        float       f_complexity_blur; /* temporally blur complexity */
+        x264_zone_t *zones;         /* ratecontrol overrides */
+        int         i_zones;        /* number of zone_t's */
+        char        *psz_zones;     /* alternate method of specifying zones */
+    } rc;
+
+    /* Cropping Rectangle parameters: added to those implicitly defined by
+       non-mod16 video resolutions. */
+    struct
+    {
+        unsigned int i_left;
+        unsigned int i_top;
+        unsigned int i_right;
+        unsigned int i_bottom;
+    } crop_rect;
+
+    /* frame packing arrangement flag */
+    int i_frame_packing;
+
+    /* Muxing parameters */
+    int b_aud;                  /* generate access unit delimiters */
+    int b_repeat_headers;       /* put SPS/PPS before each keyframe */
+    int b_annexb;               /* if set, place start codes (4 bytes) before NAL units,
+                                 * otherwise place size (4 bytes) before NAL units. */
+    int i_sps_id;               /* SPS and PPS id number */
+    int b_vfr_input;            /* VFR input.  If 1, use timebase and timestamps for ratecontrol purposes.
+                                 * If 0, use fps only. */
+    int b_pulldown;             /* use explicity set timebase for CFR */
+    uint32_t i_fps_num;
+    uint32_t i_fps_den;
+    uint32_t i_timebase_num;    /* Timebase numerator */
+    uint32_t i_timebase_den;    /* Timebase denominator */
+
+    int b_tff;
+
+    /* Pulldown:
+     * The correct pic_struct must be passed with each input frame.
+     * The input timebase should be the timebase corresponding to the output framerate. This should be constant.
+     * e.g. for 3:2 pulldown timebase should be 1001/30000
+     * The PTS passed with each frame must be the PTS of the frame after pulldown is applied.
+     * Frame doubling and tripling require b_vfr_input set to zero (see H.264 Table D-1)
+     *
+     * Pulldown changes are not clearly defined in H.264. Therefore, it is the calling app's responsibility to manage this.
+     */
+
+    int b_pic_struct;
+
+    /* Fake Interlaced.
+     *
+     * Used only when b_interlaced=0. Setting this flag makes it possible to flag the stream as PAFF interlaced yet
+     * encode all frames progessively. It is useful for encoding 25p and 30p Blu-Ray streams.
+     */
+
+    int b_fake_interlaced;
+
+    /* Don't optimize header parameters based on video content, e.g. ensure that splitting an input video, compressing
+     * each part, and stitching them back together will result in identical SPS/PPS. This is necessary for stitching
+     * with container formats that don't allow multiple SPS/PPS. */
+    int b_stitchable;
+
+    int b_opencl;            /* use OpenCL when available */
+    int i_opencl_device;     /* specify count of GPU devices to skip, for CLI users */
+    void *opencl_device_id;  /* pass explicit cl_device_id as void*, for API users */
+    char *psz_clbin_file;    /* filename (in UTF-8) of the compiled OpenCL kernel cache file */
+
+    /* Slicing parameters */
+    int i_slice_max_size;    /* Max size per slice in bytes; includes estimated NAL overhead. */
+    int i_slice_max_mbs;     /* Max number of MBs per slice; overrides i_slice_count. */
+    int i_slice_min_mbs;     /* Min number of MBs per slice */
+    int i_slice_count;       /* Number of slices per frame: forces rectangular slices. */
+    int i_slice_count_max;   /* Absolute cap on slices per frame; stops applying slice-max-size
+                              * and slice-max-mbs if this is reached. */
+
+    /* Optional callback for freeing this x264_param_t when it is done being used.
+     * Only used when the x264_param_t sits in memory for an indefinite period of time,
+     * i.e. when an x264_param_t is passed to x264_t in an x264_picture_t or in zones.
+     * Not used when x264_encoder_reconfig is called directly. */
+    void (*param_free)( void* );
+
+    /* Optional low-level callback for low-latency encoding.  Called for each output NAL unit
+     * immediately after the NAL unit is finished encoding.  This allows the calling application
+     * to begin processing video data (e.g. by sending packets over a network) before the frame
+     * is done encoding.
+     *
+     * This callback MUST do the following in order to work correctly:
+     * 1) Have available an output buffer of at least size nal->i_payload*3/2 + 5 + 64.
+     * 2) Call x264_nal_encode( h, dst, nal ), where dst is the output buffer.
+     * After these steps, the content of nal is valid and can be used in the same way as if
+     * the NAL unit were output by x264_encoder_encode.
+     *
+     * This does not need to be synchronous with the encoding process: the data pointed to
+     * by nal (both before and after x264_nal_encode) will remain valid until the next
+     * x264_encoder_encode call.  The callback must be re-entrant.
+     *
+     * This callback does not work with frame-based threads; threads must be disabled
+     * or sliced-threads enabled.  This callback also does not work as one would expect
+     * with HRD -- since the buffering period SEI cannot be calculated until the frame
+     * is finished encoding, it will not be sent via this callback.
+     *
+     * Note also that the NALs are not necessarily returned in order when sliced threads is
+     * enabled.  Accordingly, the variable i_first_mb and i_last_mb are available in
+     * x264_nal_t to help the calling application reorder the slices if necessary.
+     *
+     * When this callback is enabled, x264_encoder_encode does not return valid NALs;
+     * the calling application is expected to acquire all output NALs through the callback.
+     *
+     * It is generally sensible to combine this callback with a use of slice-max-mbs or
+     * slice-max-size.
+     *
+     * The opaque pointer is the opaque pointer from the input frame associated with this
+     * NAL unit. This helps distinguish between nalu_process calls from different sources,
+     * e.g. if doing multiple encodes in one process.
+     */
+    void (*nalu_process) ( x264_t *h, x264_nal_t *nal, void *opaque );
+} x264_param_t;
+
+void x264_nal_encode( x264_t *h, uint8_t *dst, x264_nal_t *nal );
+
+/****************************************************************************
+ * H.264 level restriction information
+ ****************************************************************************/
+
+typedef struct
+{
+    int level_idc;
+    int mbps;        /* max macroblock processing rate (macroblocks/sec) */
+    int frame_size;  /* max frame size (macroblocks) */
+    int dpb;         /* max decoded picture buffer (mbs) */
+    int bitrate;     /* max bitrate (kbit/sec) */
+    int cpb;         /* max vbv buffer (kbit) */
+    int mv_range;    /* max vertical mv component range (pixels) */
+    int mvs_per_2mb; /* max mvs per 2 consecutive mbs. */
+    int slice_rate;  /* ?? */
+    int mincr;       /* min compression ratio */
+    int bipred8x8;   /* limit bipred to >=8x8 */
+    int direct8x8;   /* limit b_direct to >=8x8 */
+    int frame_only;  /* forbid interlacing */
+} x264_level_t;
+
+/* all of the levels defined in the standard, terminated by .level_idc=0 */
+X264_API extern const x264_level_t x264_levels[];
+
+/****************************************************************************
+ * Basic parameter handling functions
+ ****************************************************************************/
+
+/* x264_param_default:
+ *      fill x264_param_t with default values and do CPU detection */
+void    x264_param_default( x264_param_t * );
+
+/* x264_param_parse:
+ *  set one parameter by name.
+ *  returns 0 on success, or returns one of the following errors.
+ *  note: BAD_VALUE occurs only if it can't even parse the value,
+ *  numerical range is not checked until x264_encoder_open() or
+ *  x264_encoder_reconfig().
+ *  value=NULL means "true" for boolean options, but is a BAD_VALUE for non-booleans. */
+#define X264_PARAM_BAD_NAME  (-1)
+#define X264_PARAM_BAD_VALUE (-2)
+int x264_param_parse( x264_param_t *, const char *name, const char *value );
+
+/****************************************************************************
+ * Advanced parameter handling functions
+ ****************************************************************************/
+
+/* These functions expose the full power of x264's preset-tune-profile system for
+ * easy adjustment of large numbers of internal parameters.
+ *
+ * In order to replicate x264CLI's option handling, these functions MUST be called
+ * in the following order:
+ * 1) x264_param_default_preset
+ * 2) Custom user options (via param_parse or directly assigned variables)
+ * 3) x264_param_apply_fastfirstpass
+ * 4) x264_param_apply_profile
+ *
+ * Additionally, x264CLI does not apply step 3 if the preset chosen is "placebo"
+ * or --slow-firstpass is set. */
+
+/* x264_param_default_preset:
+ *      The same as x264_param_default, but also use the passed preset and tune
+ *      to modify the default settings.
+ *      (either can be NULL, which implies no preset or no tune, respectively)
+ *
+ *      Currently available presets are, ordered from fastest to slowest: */
+static const char * const x264_preset_names[] = { "ultrafast", "superfast", "veryfast", "faster", "fast", "medium", "slow", "slower", "veryslow", "placebo", 0 };
+
+/*      The presets can also be indexed numerically, as in:
+ *      x264_param_default_preset( &param, "3", ... )
+ *      with ultrafast mapping to "0" and placebo mapping to "9".  This mapping may
+ *      of course change if new presets are added in between, but will always be
+ *      ordered from fastest to slowest.
+ *
+ *      Warning: the speed of these presets scales dramatically.  Ultrafast is a full
+ *      100 times faster than placebo!
+ *
+ *      Currently available tunings are: */
+static const char * const x264_tune_names[] = { "film", "animation", "grain", "stillimage", "psnr", "ssim", "fastdecode", "zerolatency", 0 };
+
+/*      Multiple tunings can be used if separated by a delimiter in ",./-+",
+ *      however multiple psy tunings cannot be used.
+ *      film, animation, grain, stillimage, psnr, and ssim are psy tunings.
+ *
+ *      returns 0 on success, negative on failure (e.g. invalid preset/tune name). */
+int     x264_param_default_preset( x264_param_t *, const char *preset, const char *tune );
+
+/* x264_param_apply_fastfirstpass:
+ *      If first-pass mode is set (rc.b_stat_read == 0, rc.b_stat_write == 1),
+ *      modify the encoder settings to disable options generally not useful on
+ *      the first pass. */
+void    x264_param_apply_fastfirstpass( x264_param_t * );
+
+/* x264_param_apply_profile:
+ *      Applies the restrictions of the given profile.
+ *      Currently available profiles are, from most to least restrictive: */
+static const char * const x264_profile_names[] = { "baseline", "main", "high", "high10", "high422", "high444", 0 };
+
+/*      (can be NULL, in which case the function will do nothing)
+ *
+ *      Does NOT guarantee that the given profile will be used: if the restrictions
+ *      of "High" are applied to settings that are already Baseline-compatible, the
+ *      stream will remain baseline.  In short, it does not increase settings, only
+ *      decrease them.
+ *
+ *      returns 0 on success, negative on failure (e.g. invalid profile name). */
+int     x264_param_apply_profile( x264_param_t *, const char *profile );
+
+/****************************************************************************
+ * Picture structures and functions
+ ****************************************************************************/
+
+/* x264_bit_depth:
+ *      Specifies the number of bits per pixel that x264 uses. This is also the
+ *      bit depth that x264 encodes in. If this value is > 8, x264 will read
+ *      two bytes of input data for each pixel sample, and expect the upper
+ *      (16-x264_bit_depth) bits to be zero.
+ *      Note: The flag X264_CSP_HIGH_DEPTH must be used to specify the
+ *      colorspace depth as well. */
+X264_API extern const int x264_bit_depth;
+
+/* x264_chroma_format:
+ *      Specifies the chroma formats that x264 supports encoding. When this
+ *      value is non-zero, then it represents a X264_CSP_* that is the only
+ *      chroma format that x264 supports encoding. If the value is 0 then
+ *      there are no restrictions. */
+X264_API extern const int x264_chroma_format;
+
+enum pic_struct_e
+{
+    PIC_STRUCT_AUTO              = 0, // automatically decide (default)
+    PIC_STRUCT_PROGRESSIVE       = 1, // progressive frame
+    // "TOP" and "BOTTOM" are not supported in x264 (PAFF only)
+    PIC_STRUCT_TOP_BOTTOM        = 4, // top field followed by bottom
+    PIC_STRUCT_BOTTOM_TOP        = 5, // bottom field followed by top
+    PIC_STRUCT_TOP_BOTTOM_TOP    = 6, // top field, bottom field, top field repeated
+    PIC_STRUCT_BOTTOM_TOP_BOTTOM = 7, // bottom field, top field, bottom field repeated
+    PIC_STRUCT_DOUBLE            = 8, // double frame
+    PIC_STRUCT_TRIPLE            = 9, // triple frame
+};
+
+typedef struct
+{
+    double cpb_initial_arrival_time;
+    double cpb_final_arrival_time;
+    double cpb_removal_time;
+
+    double dpb_output_time;
+} x264_hrd_t;
+
+/* Arbitrary user SEI:
+ * Payload size is in bytes and the payload pointer must be valid.
+ * Payload types and syntax can be found in Annex D of the H.264 Specification.
+ * SEI payload alignment bits as described in Annex D must be included at the
+ * end of the payload if needed.
+ * The payload should not be NAL-encapsulated.
+ * Payloads are written first in order of input, apart from in the case when HRD
+ * is enabled where payloads are written after the Buffering Period SEI. */
+
+typedef struct
+{
+    int payload_size;
+    int payload_type;
+    uint8_t *payload;
+} x264_sei_payload_t;
+
+typedef struct
+{
+    int num_payloads;
+    x264_sei_payload_t *payloads;
+    /* In: optional callback to free each payload AND x264_sei_payload_t when used. */
+    void (*sei_free)( void* );
+} x264_sei_t;
+
+typedef struct
+{
+    int     i_csp;       /* Colorspace */
+    int     i_plane;     /* Number of image planes */
+    int     i_stride[4]; /* Strides for each plane */
+    uint8_t *plane[4];   /* Pointers to each plane */
+} x264_image_t;
+
+typedef struct
+{
+    /* All arrays of data here are ordered as follows:
+     * each array contains one offset per macroblock, in raster scan order.  In interlaced
+     * mode, top-field MBs and bottom-field MBs are interleaved at the row level.
+     * Macroblocks are 16x16 blocks of pixels (with respect to the luma plane).  For the
+     * purposes of calculating the number of macroblocks, width and height are rounded up to
+     * the nearest 16.  If in interlaced mode, height is rounded up to the nearest 32 instead. */
+
+    /* In: an array of quantizer offsets to be applied to this image during encoding.
+     *     These are added on top of the decisions made by x264.
+     *     Offsets can be fractional; they are added before QPs are rounded to integer.
+     *     Adaptive quantization must be enabled to use this feature.  Behavior if quant
+     *     offsets differ between encoding passes is undefined. */
+    float *quant_offsets;
+    /* In: optional callback to free quant_offsets when used.
+     *     Useful if one wants to use a different quant_offset array for each frame. */
+    void (*quant_offsets_free)( void* );
+
+    /* In: optional array of flags for each macroblock.
+     *     Allows specifying additional information for the encoder such as which macroblocks
+     *     remain unchanged.  Usable flags are listed below.
+     *     x264_param_t.analyse.b_mb_info must be set to use this, since x264 needs to track
+     *     extra data internally to make full use of this information.
+     *
+     * Out: if b_mb_info_update is set, x264 will update this array as a result of encoding.
+     *
+     *      For "MBINFO_CONSTANT", it will remove this flag on any macroblock whose decoded
+     *      pixels have changed.  This can be useful for e.g. noting which areas of the
+     *      frame need to actually be blitted. Note: this intentionally ignores the effects
+     *      of deblocking for the current frame, which should be fine unless one needs exact
+     *      pixel-perfect accuracy.
+     *
+     *      Results for MBINFO_CONSTANT are currently only set for P-frames, and are not
+     *      guaranteed to enumerate all blocks which haven't changed.  (There may be false
+     *      negatives, but no false positives.)
+     */
+    uint8_t *mb_info;
+    /* In: optional callback to free mb_info when used. */
+    void (*mb_info_free)( void* );
+
+    /* The macroblock is constant and remains unchanged from the previous frame. */
+    #define X264_MBINFO_CONSTANT   (1<<0)
+    /* More flags may be added in the future. */
+
+    /* Out: SSIM of the the frame luma (if x264_param_t.b_ssim is set) */
+    double f_ssim;
+    /* Out: Average PSNR of the frame (if x264_param_t.b_psnr is set) */
+    double f_psnr_avg;
+    /* Out: PSNR of Y, U, and V (if x264_param_t.b_psnr is set) */
+    double f_psnr[3];
+
+    /* Out: Average effective CRF of the encoded frame */
+    double f_crf_avg;
+} x264_image_properties_t;
+
+typedef struct
+{
+    /* In: force picture type (if not auto)
+     *     If x264 encoding parameters are violated in the forcing of picture types,
+     *     x264 will correct the input picture type and log a warning.
+     *     The quality of frametype decisions may suffer if a great deal of fine-grained
+     *     mixing of auto and forced frametypes is done.
+     * Out: type of the picture encoded */
+    int     i_type;
+    /* In: force quantizer for != X264_QP_AUTO */
+    int     i_qpplus1;
+    /* In: pic_struct, for pulldown/doubling/etc...used only if b_pic_struct=1.
+     *     use pic_struct_e for pic_struct inputs
+     * Out: pic_struct element associated with frame */
+    int     i_pic_struct;
+    /* Out: whether this frame is a keyframe.  Important when using modes that result in
+     * SEI recovery points being used instead of IDR frames. */
+    int     b_keyframe;
+    /* In: user pts, Out: pts of encoded picture (user)*/
+    int64_t i_pts;
+    /* Out: frame dts. When the pts of the first frame is close to zero,
+     *      initial frames may have a negative dts which must be dealt with by any muxer */
+    int64_t i_dts;
+    /* In: custom encoding parameters to be set from this frame forwards
+           (in coded order, not display order). If NULL, continue using
+           parameters from the previous frame.  Some parameters, such as
+           aspect ratio, can only be changed per-GOP due to the limitations
+           of H.264 itself; in this case, the caller must force an IDR frame
+           if it needs the changed parameter to apply immediately. */
+    x264_param_t *param;
+    /* In: raw image data */
+    /* Out: reconstructed image data.  x264 may skip part of the reconstruction process,
+            e.g. deblocking, in frames where it isn't necessary.  To force complete
+            reconstruction, at a small speed cost, set b_full_recon. */
+    x264_image_t img;
+    /* In: optional information to modify encoder decisions for this frame
+     * Out: information about the encoded frame */
+    x264_image_properties_t prop;
+    /* Out: HRD timing information. Output only when i_nal_hrd is set. */
+    x264_hrd_t hrd_timing;
+    /* In: arbitrary user SEI (e.g subtitles, AFDs) */
+    x264_sei_t extra_sei;
+    /* private user data. copied from input to output frames. */
+    void *opaque;
+} x264_picture_t;
+
+/* x264_picture_init:
+ *  initialize an x264_picture_t.  Needs to be done if the calling application
+ *  allocates its own x264_picture_t as opposed to using x264_picture_alloc. */
+void x264_picture_init( x264_picture_t *pic );
+
+/* x264_picture_alloc:
+ *  alloc data for a picture. You must call x264_picture_clean on it.
+ *  returns 0 on success, or -1 on malloc failure or invalid colorspace. */
+int x264_picture_alloc( x264_picture_t *pic, int i_csp, int i_width, int i_height );
+
+/* x264_picture_clean:
+ *  free associated resource for a x264_picture_t allocated with
+ *  x264_picture_alloc ONLY */
+void x264_picture_clean( x264_picture_t *pic );
+
+/****************************************************************************
+ * Encoder functions
+ ****************************************************************************/
+
+/* Force a link error in the case of linking against an incompatible API version.
+ * Glue #defines exist to force correct macro expansion; the final output of the macro
+ * is x264_encoder_open_##X264_BUILD (for purposes of dlopen). */
+#define x264_encoder_glue1(x,y) x##y
+#define x264_encoder_glue2(x,y) x264_encoder_glue1(x,y)
+#define x264_encoder_open x264_encoder_glue2(x264_encoder_open_,X264_BUILD)
+
+/* x264_encoder_open:
+ *      create a new encoder handler, all parameters from x264_param_t are copied */
+x264_t *x264_encoder_open( x264_param_t * );
+
+/* x264_encoder_reconfig:
+ *      various parameters from x264_param_t are copied.
+ *      this takes effect immediately, on whichever frame is encoded next;
+ *      due to delay, this may not be the next frame passed to encoder_encode.
+ *      if the change should apply to some particular frame, use x264_picture_t->param instead.
+ *      returns 0 on success, negative on parameter validation error.
+ *      not all parameters can be changed; see the actual function for a detailed breakdown.
+ *
+ *      since not all parameters can be changed, moving from preset to preset may not always
+ *      fully copy all relevant parameters, but should still work usably in practice. however,
+ *      more so than for other presets, many of the speed shortcuts used in ultrafast cannot be
+ *      switched out of; using reconfig to switch between ultrafast and other presets is not
+ *      recommended without a more fine-grained breakdown of parameters to take this into account. */
+int     x264_encoder_reconfig( x264_t *, x264_param_t * );
+/* x264_encoder_parameters:
+ *      copies the current internal set of parameters to the pointer provided
+ *      by the caller.  useful when the calling application needs to know
+ *      how x264_encoder_open has changed the parameters, or the current state
+ *      of the encoder after multiple x264_encoder_reconfig calls.
+ *      note that the data accessible through pointers in the returned param struct
+ *      (e.g. filenames) should not be modified by the calling application. */
+void    x264_encoder_parameters( x264_t *, x264_param_t * );
+/* x264_encoder_headers:
+ *      return the SPS and PPS that will be used for the whole stream.
+ *      *pi_nal is the number of NAL units outputted in pp_nal.
+ *      returns the number of bytes in the returned NALs.
+ *      returns negative on error.
+ *      the payloads of all output NALs are guaranteed to be sequential in memory. */
+int     x264_encoder_headers( x264_t *, x264_nal_t **pp_nal, int *pi_nal );
+/* x264_encoder_encode:
+ *      encode one picture.
+ *      *pi_nal is the number of NAL units outputted in pp_nal.
+ *      returns the number of bytes in the returned NALs.
+ *      returns negative on error and zero if no NAL units returned.
+ *      the payloads of all output NALs are guaranteed to be sequential in memory. */
+int     x264_encoder_encode( x264_t *, x264_nal_t **pp_nal, int *pi_nal, x264_picture_t *pic_in, x264_picture_t *pic_out );
+/* x264_encoder_close:
+ *      close an encoder handler */
+void    x264_encoder_close  ( x264_t * );
+/* x264_encoder_delayed_frames:
+ *      return the number of currently delayed (buffered) frames
+ *      this should be used at the end of the stream, to know when you have all the encoded frames. */
+int     x264_encoder_delayed_frames( x264_t * );
+/* x264_encoder_maximum_delayed_frames( x264_t *h ):
+ *      return the maximum number of delayed (buffered) frames that can occur with the current
+ *      parameters. */
+int     x264_encoder_maximum_delayed_frames( x264_t *h );
+/* x264_encoder_intra_refresh:
+ *      If an intra refresh is not in progress, begin one with the next P-frame.
+ *      If an intra refresh is in progress, begin one as soon as the current one finishes.
+ *      Requires that b_intra_refresh be set.
+ *
+ *      Useful for interactive streaming where the client can tell the server that packet loss has
+ *      occurred.  In this case, keyint can be set to an extremely high value so that intra refreshes
+ *      only occur when calling x264_encoder_intra_refresh.
+ *
+ *      In multi-pass encoding, if x264_encoder_intra_refresh is called differently in each pass,
+ *      behavior is undefined.
+ *
+ *      Should not be called during an x264_encoder_encode. */
+void    x264_encoder_intra_refresh( x264_t * );
+/* x264_encoder_invalidate_reference:
+ *      An interactive error resilience tool, designed for use in a low-latency one-encoder-few-clients
+ *      system.  When the client has packet loss or otherwise incorrectly decodes a frame, the encoder
+ *      can be told with this command to "forget" the frame and all frames that depend on it, referencing
+ *      only frames that occurred before the loss.  This will force a keyframe if no frames are left to
+ *      reference after the aforementioned "forgetting".
+ *
+ *      It is strongly recommended to use a large i_dpb_size in this case, which allows the encoder to
+ *      keep around extra, older frames to fall back on in case more recent frames are all invalidated.
+ *      Unlike increasing i_frame_reference, this does not increase the number of frames used for motion
+ *      estimation and thus has no speed impact.  It is also recommended to set a very large keyframe
+ *      interval, so that keyframes are not used except as necessary for error recovery.
+ *
+ *      x264_encoder_invalidate_reference is not currently compatible with the use of B-frames or intra
+ *      refresh.
+ *
+ *      In multi-pass encoding, if x264_encoder_invalidate_reference is called differently in each pass,
+ *      behavior is undefined.
+ *
+ *      Should not be called during an x264_encoder_encode, but multiple calls can be made simultaneously.
+ *
+ *      Returns 0 on success, negative on failure. */
+int x264_encoder_invalidate_reference( x264_t *, int64_t pts );
+
+#endif
--- ffmpeg-2.5/localinc/x265_config.h.dl_headers~	2014-12-04 22:53:11.256498996 +0100
+++ ffmpeg-2.5/localinc/x265_config.h	2014-12-04 22:53:11.256498996 +0100
@@ -0,0 +1,34 @@
+/*****************************************************************************
+ * Copyright (C) 2013 x265 project
+ *
+ * Authors: Steve Borho <steve@borho.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111, USA.
+ *
+ * This program is also available under a commercial proprietary license.
+ * For more information, contact us at license @ x265.com.
+ *****************************************************************************/
+
+#ifndef X265_CONFIG_H
+#define X265_CONFIG_H
+
+/* Defines generated at build time */
+
+/* Incremented each time public API is changed, X265_BUILD is used as
+ * the shared library SONAME on platforms which support it. It also
+ * prevents linking against a different version of the static lib */
+#define X265_BUILD 35
+
+#endif
--- ffmpeg-2.5/localinc/x265.h.dl_headers~	2014-12-04 22:53:11.256498996 +0100
+++ ffmpeg-2.5/localinc/x265.h	2014-12-04 22:53:11.256498996 +0100
@@ -0,0 +1,1143 @@
+/*****************************************************************************
+ * Copyright (C) 2013 x265 project
+ *
+ * Authors: Steve Borho <steve@borho.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111, USA.
+ *
+ * This program is also available under a commercial proprietary license.
+ * For more information, contact us at license @ x265.com.
+ *****************************************************************************/
+
+#ifndef X265_H
+#define X265_H
+
+#include <stdint.h>
+#include "x265_config.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* x265_encoder:
+ *      opaque handler for encoder */
+typedef struct x265_encoder x265_encoder;
+
+/* Application developers planning to link against a shared library version of
+ * libx265 from a Microsoft Visual Studio or similar development environment
+ * will need to define X265_API_IMPORTS before including this header.
+ * This clause does not apply to MinGW, similar development environments, or non
+ * Windows platforms. */
+#ifdef X265_API_IMPORTS
+#define X265_API __declspec(dllimport)
+#else
+#define X265_API
+#endif
+
+typedef enum
+{
+    NAL_UNIT_CODED_SLICE_TRAIL_N = 0,
+    NAL_UNIT_CODED_SLICE_TRAIL_R,
+    NAL_UNIT_CODED_SLICE_TSA_N,
+    NAL_UNIT_CODED_SLICE_TLA_R,
+    NAL_UNIT_CODED_SLICE_STSA_N,
+    NAL_UNIT_CODED_SLICE_STSA_R,
+    NAL_UNIT_CODED_SLICE_RADL_N,
+    NAL_UNIT_CODED_SLICE_RADL_R,
+    NAL_UNIT_CODED_SLICE_RASL_N,
+    NAL_UNIT_CODED_SLICE_RASL_R,
+    NAL_UNIT_CODED_SLICE_BLA_W_LP = 16,
+    NAL_UNIT_CODED_SLICE_BLA_W_RADL,
+    NAL_UNIT_CODED_SLICE_BLA_N_LP,
+    NAL_UNIT_CODED_SLICE_IDR_W_RADL,
+    NAL_UNIT_CODED_SLICE_IDR_N_LP,
+    NAL_UNIT_CODED_SLICE_CRA,
+    NAL_UNIT_VPS = 32,
+    NAL_UNIT_SPS,
+    NAL_UNIT_PPS,
+    NAL_UNIT_ACCESS_UNIT_DELIMITER,
+    NAL_UNIT_EOS,
+    NAL_UNIT_EOB,
+    NAL_UNIT_FILLER_DATA,
+    NAL_UNIT_PREFIX_SEI,
+    NAL_UNIT_SUFFIX_SEI,
+    NAL_UNIT_INVALID = 64,
+} NalUnitType;
+
+/* The data within the payload is already NAL-encapsulated; the type is merely
+ * in the struct for easy access by the calling application.  All data returned
+ * in an x265_nal, including the data in payload, is no longer valid after the
+ * next call to x265_encoder_encode.  Thus it must be used or copied before
+ * calling x265_encoder_encode again. */
+typedef struct x265_nal
+{
+    uint32_t type;        /* NalUnitType */
+    uint32_t sizeBytes;   /* size in bytes */
+    uint8_t* payload;
+} x265_nal;
+
+/* Stores inter (motion estimation) analysis data for a single frame */
+typedef struct x265_inter_data
+{
+    uint32_t zOrder;
+    int      ref[2];
+    int      costZero[2];
+    int16_t  mvx[2];
+    int16_t  mvy[2];
+    uint32_t depth;
+    int      poc;
+    uint32_t cuAddr;
+} x265_inter_data;
+
+/* Stores intra (motion estimation) analysis data for a single frame */
+typedef struct x265_intra_data
+{
+    uint8_t*  depth;
+    uint8_t*  modes;
+    char*     partSizes;
+    int*      poc;
+    uint32_t* cuAddr;
+} x265_intra_data;
+
+/* Stores all analysis data for a single frame */
+typedef struct x265_analysis_data
+{
+    x265_inter_data* interData;
+    x265_intra_data* intraData;
+    uint32_t         numCUsInFrame;
+    uint32_t         numPartitions;
+} x265_analysis_data;
+
+/* Used to pass pictures into the encoder, and to get picture data back out of
+ * the encoder.  The input and output semantics are different */
+typedef struct x265_picture
+{
+    /* Must be specified on input pictures, the number of planes is determined
+     * by the colorSpace value */
+    void*   planes[3];
+
+    /* Stride is the number of bytes between row starts */
+    int     stride[3];
+
+    /* Must be specified on input pictures. x265_picture_init() will set it to
+     * the encoder's internal bit depth, but this field must describe the depth
+     * of the input pictures. Must be between 8 and 16. Values larger than 8
+     * imply 16bits per input sample. If input bit depth is larger than the
+     * internal bit depth, the encoder will down-shift pixels. Input samples
+     * larger than 8bits will be masked to internal bit depth. On output the
+     * bitDepth will be the internal encoder bit depth */
+    int     bitDepth;
+
+    /* Must be specified on input pictures: X265_TYPE_AUTO or other.
+     * x265_picture_init() sets this to auto, returned on output */
+    int     sliceType;
+
+    /* Ignored on input, set to picture count, returned on output */
+    int     poc;
+
+    /* Must be specified on input pictures: X265_CSP_I420 or other. It must
+     * match the internal color space of the encoder. x265_picture_init() will
+     * initialize this value to the internal color space */
+    int     colorSpace;
+
+    /* presentation time stamp: user-specified, returned on output */
+    int64_t pts;
+
+    /* display time stamp: ignored on input, copied from reordered pts. Returned
+     * on output */
+    int64_t dts;
+
+    /* The value provided on input is returned with the same picture (POC) on
+     * output */
+    void*   userData;
+
+    /* force quantizer for != X265_QP_AUTO */
+    int     forceqp;
+
+    /* If param.analysisMode is X265_ANALYSIS_OFF this field is ignored on input
+     * and output. Else the user must call x265_alloc_analysis_data() to
+     * allocate analysis buffers for every picture passed to the encoder.
+     *
+     * On input when param.analysisMode is X265_ANALYSIS_LOAD and analysisData
+     * member pointers are valid, the encoder will use the data stored here to
+     * reduce encoder work.
+     *
+     * On output when param.analysisMode is X265_ANALYSIS_SAVE and analysisData
+     * member pointers are valid, the encoder will write output analysis into
+     * this data structure */
+    x265_analysis_data analysisData;
+
+    /* new data members to this structure must be added to the end so that
+     * users of x265_picture_alloc/free() can be assured of future safety */
+} x265_picture;
+
+typedef enum
+{
+    X265_DIA_SEARCH,
+    X265_HEX_SEARCH,
+    X265_UMH_SEARCH,
+    X265_STAR_SEARCH,
+    X265_FULL_SEARCH
+} X265_ME_METHODS;
+
+/* CPU flags */
+
+/* x86 */
+#define X265_CPU_CMOV            0x0000001
+#define X265_CPU_MMX             0x0000002
+#define X265_CPU_MMX2            0x0000004  /* MMX2 aka MMXEXT aka ISSE */
+#define X265_CPU_MMXEXT          X265_CPU_MMX2
+#define X265_CPU_SSE             0x0000008
+#define X265_CPU_SSE2            0x0000010
+#define X265_CPU_SSE3            0x0000020
+#define X265_CPU_SSSE3           0x0000040
+#define X265_CPU_SSE4            0x0000080  /* SSE4.1 */
+#define X265_CPU_SSE42           0x0000100  /* SSE4.2 */
+#define X265_CPU_LZCNT           0x0000200  /* Phenom support for "leading zero count" instruction. */
+#define X265_CPU_AVX             0x0000400  /* AVX support: requires OS support even if YMM registers aren't used. */
+#define X265_CPU_XOP             0x0000800  /* AMD XOP */
+#define X265_CPU_FMA4            0x0001000  /* AMD FMA4 */
+#define X265_CPU_AVX2            0x0002000  /* AVX2 */
+#define X265_CPU_FMA3            0x0004000  /* Intel FMA3 */
+#define X265_CPU_BMI1            0x0008000  /* BMI1 */
+#define X265_CPU_BMI2            0x0010000  /* BMI2 */
+/* x86 modifiers */
+#define X265_CPU_CACHELINE_32    0x0020000  /* avoid memory loads that span the border between two cachelines */
+#define X265_CPU_CACHELINE_64    0x0040000  /* 32/64 is the size of a cacheline in bytes */
+#define X265_CPU_SSE2_IS_SLOW    0x0080000  /* avoid most SSE2 functions on Athlon64 */
+#define X265_CPU_SSE2_IS_FAST    0x0100000  /* a few functions are only faster on Core2 and Phenom */
+#define X265_CPU_SLOW_SHUFFLE    0x0200000  /* The Conroe has a slow shuffle unit (relative to overall SSE performance) */
+#define X265_CPU_STACK_MOD4      0x0400000  /* if stack is only mod4 and not mod16 */
+#define X265_CPU_SLOW_CTZ        0x0800000  /* BSR/BSF x86 instructions are really slow on some CPUs */
+#define X265_CPU_SLOW_ATOM       0x1000000  /* The Atom is terrible: slow SSE unaligned loads, slow
+                                             * SIMD multiplies, slow SIMD variable shifts, slow pshufb,
+                                             * cacheline split penalties -- gather everything here that
+                                             * isn't shared by other CPUs to avoid making half a dozen
+                                             * new SLOW flags. */
+#define X265_CPU_SLOW_PSHUFB     0x2000000  /* such as on the Intel Atom */
+#define X265_CPU_SLOW_PALIGNR    0x4000000  /* such as on the AMD Bobcat */
+
+/* ARM */
+#define X265_CPU_ARMV6           0x0000001
+#define X265_CPU_NEON            0x0000002  /* ARM NEON */
+#define X265_CPU_FAST_NEON_MRC   0x0000004  /* Transfer from NEON to ARM register is fast (Cortex-A9) */
+
+#define X265_MAX_SUBPEL_LEVEL   7
+
+/* Log level */
+#define X265_LOG_NONE          (-1)
+#define X265_LOG_ERROR          0
+#define X265_LOG_WARNING        1
+#define X265_LOG_INFO           2
+#define X265_LOG_DEBUG          3
+#define X265_LOG_FULL           4
+
+#define X265_B_ADAPT_NONE       0
+#define X265_B_ADAPT_FAST       1
+#define X265_B_ADAPT_TRELLIS    2
+
+#define X265_BFRAME_MAX         16
+
+#define X265_TYPE_AUTO          0x0000  /* Let x265 choose the right type */
+#define X265_TYPE_IDR           0x0001
+#define X265_TYPE_I             0x0002
+#define X265_TYPE_P             0x0003
+#define X265_TYPE_BREF          0x0004  /* Non-disposable B-frame */
+#define X265_TYPE_B             0x0005
+#define X265_QP_AUTO                 0
+
+#define X265_AQ_NONE                 0
+#define X265_AQ_VARIANCE             1
+#define X265_AQ_AUTO_VARIANCE        2
+#define IS_X265_TYPE_I(x) ((x) == X265_TYPE_I || (x) == X265_TYPE_IDR)
+#define IS_X265_TYPE_B(x) ((x) == X265_TYPE_B || (x) == X265_TYPE_BREF)
+
+/* NOTE! For this release only X265_CSP_I420 and X265_CSP_I444 are supported */
+
+/* Supported internal color space types (according to semantics of chroma_format_idc) */
+#define X265_CSP_I400           0  /* yuv 4:0:0 planar */
+#define X265_CSP_I420           1  /* yuv 4:2:0 planar */
+#define X265_CSP_I422           2  /* yuv 4:2:2 planar */
+#define X265_CSP_I444           3  /* yuv 4:4:4 planar */
+#define X265_CSP_COUNT          4  /* Number of supported internal color spaces */
+
+/* These color spaces will eventually be supported as input pictures. The pictures will
+ * be converted to the appropriate planar color spaces at ingest */
+#define X265_CSP_NV12           4  /* yuv 4:2:0, with one y plane and one packed u+v */
+#define X265_CSP_NV16           5  /* yuv 4:2:2, with one y plane and one packed u+v */
+
+/* Interleaved color-spaces may eventually be supported as input pictures */
+#define X265_CSP_BGR            6  /* packed bgr 24bits   */
+#define X265_CSP_BGRA           7  /* packed bgr 32bits   */
+#define X265_CSP_RGB            8  /* packed rgb 24bits   */
+#define X265_CSP_MAX            9  /* end of list */
+
+#define X265_EXTENDED_SAR       255 /* aspect ratio explicitly specified as width:height */
+
+/* Analysis options */
+#define X265_ANALYSIS_OFF  0
+#define X265_ANALYSIS_SAVE 1
+#define X265_ANALYSIS_LOAD 2
+
+typedef struct
+{
+    int planes;
+    int width[3];
+    int height[3];
+} x265_cli_csp;
+
+static const x265_cli_csp x265_cli_csps[] =
+{
+    { 1, { 0, 0, 0 }, { 0, 0, 0 } }, /* i400 */
+    { 3, { 0, 1, 1 }, { 0, 1, 1 } }, /* i420 */
+    { 3, { 0, 1, 1 }, { 0, 0, 0 } }, /* i422 */
+    { 3, { 0, 0, 0 }, { 0, 0, 0 } }, /* i444 */
+    { 2, { 0, 0 },    { 0, 1 } },    /* nv12 */
+    { 2, { 0, 0 },    { 0, 0 } },    /* nv16 */
+};
+
+/* rate tolerance method */
+typedef enum
+{
+    X265_RC_ABR,
+    X265_RC_CQP,
+    X265_RC_CRF
+} X265_RC_METHODS;
+
+/* Output statistics from encoder */
+typedef struct x265_stats
+{
+    double    globalPsnrY;
+    double    globalPsnrU;
+    double    globalPsnrV;
+    double    globalPsnr;
+    double    globalSsim;
+    double    elapsedEncodeTime;    /* wall time since encoder was opened */
+    double    elapsedVideoTime;     /* encoded picture count / frame rate */
+    double    bitrate;              /* accBits / elapsed video time */
+    uint32_t  encodedPictureCount;  /* number of output pictures thus far */
+    uint32_t  totalWPFrames;        /* number of uni-directional weighted frames used */
+    uint64_t  accBits;              /* total bits output thus far */
+
+    /* new statistic member variables must be added below this line */
+} x265_stats;
+
+/* String values accepted by x265_param_parse() (and CLI) for various parameters */
+static const char * const x265_motion_est_names[] = { "dia", "hex", "umh", "star", "full", 0 };
+static const char * const x265_source_csp_names[] = { "i400", "i420", "i422", "i444", "nv12", "nv16", 0 };
+static const char * const x265_video_format_names[] = { "component", "pal", "ntsc", "secam", "mac", "undef", 0 };
+static const char * const x265_fullrange_names[] = { "limited", "full", 0 };
+static const char * const x265_colorprim_names[] = { "", "bt709", "undef", "", "bt470m", "bt470bg", "smpte170m", "smpte240m", "film", "bt2020", 0 };
+static const char * const x265_transfer_names[] = { "", "bt709", "undef", "", "bt470m", "bt470bg", "smpte170m", "smpte240m", "linear", "log100",
+                                                    "log316", "iec61966-2-4", "bt1361e", "iec61966-2-1", "bt2020-10", "bt2020-12", 0 };
+static const char * const x265_colmatrix_names[] = { "GBR", "bt709", "undef", "", "fcc", "bt470bg", "smpte170m", "smpte240m",
+                                                     "YCgCo", "bt2020nc", "bt2020c", 0 };
+static const char * const x265_sar_names[] = { "undef", "1:1", "12:11", "10:11", "16:11", "40:33", "24:11", "20:11",
+                                               "32:11", "80:33", "18:11", "15:11", "64:33", "160:99", "4:3", "3:2", "2:1", 0 };
+static const char * const x265_interlace_names[] = { "prog", "tff", "bff", 0 };
+static const char * const x265_analysis_names[] = { "off", "save", "load", 0 };
+
+/* x265 input parameters
+ *
+ * For version safety you may use x265_param_alloc/free() to manage the
+ * allocation of x265_param instances, and x265_param_parse() to assign values
+ * by name.  By never dereferencing param fields in your own code you can treat
+ * x265_param as an opaque data structure */
+typedef struct x265_param
+{
+    /*== Encoder Environment ==*/
+
+    /* x265_param_default() will auto-detect this cpu capability bitmap.  it is
+     * recommended to not change this value unless you know the cpu detection is
+     * somehow flawed on your target hardware. The asm function tables are
+     * process global, the first encoder configures them for all encoders */
+    int       cpuid;
+
+    /* Enable wavefront parallel processing, greatly increases parallelism for
+     * less than 1% compression efficiency loss */
+    int       bEnableWavefront;
+
+    /* Number of threads to allocate for the process global thread pool, if no
+     * thread pool has yet been created. 0 implies auto-detection. By default
+     * x265 will try to allocate one worker thread per CPU core */
+    int       poolNumThreads;
+
+    /* Number of concurrently encoded frames, 0 implies auto-detection. By
+     * default x265 will use a number of frame threads emperically determined to
+     * be optimal for your CPU core count, between 2 and 6.  Using more than one
+     * frame thread causes motion search in the down direction to be clamped but
+     * otherwise encode behavior is unaffected. With CQP rate control the output
+     * bitstream is deterministic for all values of frameNumThreads greater than
+     * 1.  All other forms of rate-control can be negatively impacted by
+     * increases to the number of frame threads because the extra concurrency
+     * adds uncertainty to the bitrate estimations.  There is no limit to the
+     * number of frame threads you use for each encoder, but frame parallelism
+     * is generally limited by the the number of CU rows */
+    int       frameNumThreads;
+
+    /* Use multiple threads to measure CU mode costs. Recommended for many core
+     * CPUs */
+    int       bDistributeModeAnalysis;
+
+    /* Use multiple threads to perform motion estimation to (ME to one reference
+     * per thread). Recommended for many core CPUs */
+    int       bDistributeMotionEstimation;
+
+    /* The level of logging detail emitted by the encoder. X265_LOG_NONE to
+     * X265_LOG_FULL, default is X265_LOG_INFO */
+    int       logLevel;
+
+    /* Enable analysis and logging distribution of Cus encoded across various
+     * modes during mode decision. Default disabled */
+    int       bLogCuStats;
+
+    /* Enable the measurement and reporting of PSNR. Default is enabled */
+    int       bEnablePsnr;
+
+    /* Enable the measurement and reporting of SSIM. Default is disabled */
+    int       bEnableSsim;
+
+    /* filename of CSV log. If logLevel is X265_LOG_DEBUG, the encoder will emit
+     * per-slice statistics to this log file in encode order. Otherwise the
+     * encoder will emit per-stream statistics into the log file when
+     * x265_encoder_log is called (presumably at the end of the encode) */
+    const char *csvfn;
+
+    /* Enable the generation of SEI messages for each encoded frame containing
+     * the hashes of the three reconstructed picture planes. Most decoders will
+     * validate those hashes against the reconstructed images it generates and
+     * report any mismatches. This is essentially a debugging feature.  Hash
+     * types are MD5(1), CRC(2), Checksum(3).  Default is 0, none */
+    int       decodedPictureHashSEI;
+
+    /*== Internal Picture Specification ==*/
+
+    /* Internal encoder bit depth. If x265 was compiled to use 8bit pixels
+     * (HIGH_BIT_DEPTH=0), this field must be 8, else this field must be 10.
+     * Future builds may support 12bit pixels. */
+    int       internalBitDepth;
+
+    /* Color space of internal pictures. Only X265_CSP_I420 and X265_CSP_I444
+     * are supported.  Eventually, i422 will also be supported as an internal
+     * color space and other packed formats will be supported in
+     * x265_picture.colorSpace */
+    int       internalCsp;
+
+    /* Numerator and denominator of frame rate */
+    uint32_t  fpsNum;
+    uint32_t  fpsDenom;
+
+    /* Width (in pixels) of the source pictures. If this width is not an even
+     * multiple of 4, the encoder will pad the pictures internally to meet this
+     * minimum requirement. All valid HEVC widths are supported */
+    int       sourceWidth;
+
+    /* Height (in pixels) of the source pictures. If this height is not an even
+     * multiple of 4, the encoder will pad the pictures internally to meet this
+     * minimum requirement. All valid HEVC heights are supported */
+    int       sourceHeight;
+
+    /* Minimum decoder requirement level. Defaults to 0, which implies auto-
+     * detection by the encoder. If specified, the encoder will attempt to bring
+     * the encode specifications within that specified level. If the encoder is
+     * unable to reach the level it issues a warning and emits the actual
+     * decoder requirement. If the requested requirement level is higher than
+     * the actual level, the actual requirement level is signaled. The value is
+     * an specified as an integer with the level times 10, for example level
+     * "5.1" is specified as 51, and level "5.0" is specified as 50. */
+    int       levelIdc;
+
+    /* if levelIdc is specified (non-zero) this flag will differentiate between
+     * Main (0) and High (1) tier. Default is Main tier (0) */
+    int       bHighTier;
+
+    /* Interlace type of source pictures. 0 - progressive pictures (default).
+     * 1 - top field first, 2 - bottom field first. HEVC encodes interlaced
+     * content as fields, they must be provided to the encoder in the correct
+     * temporal order. EXPERIMENTAL */
+    int       interlaceMode;
+
+    /* Flag indicating whether VPS, SPS and PPS headers should be output with
+     * each keyframe. Default false */
+    int       bRepeatHeaders;
+
+    /* Flag indicating whether the encoder should emit an Access Unit Delimiter
+     * NAL at the start of every access unit. Default false */
+    int       bEnableAccessUnitDelimiters;
+
+    /* Enables the buffering period SEI and picture timing SEI to signal the HRD
+     * parameteres. Default is disabled */
+    int       bEmitHRDSEI;
+
+    /* Enables the emission of a user data SEI with the stream headers which
+     * describes the encoder version, build info, and parameters. This is
+     * very helpful for debugging, but may interfere with regression tests. 
+     * Default enabled */
+    int       bEmitInfoSEI;
+
+    /*== Coding Unit (CU) definitions ==*/
+
+    /* Maxiumum CU width and height in pixels.  The size must be 64, 32, or 16.
+     * The higher the size, the more efficiently x265 can encode areas of low
+     * complexity, greatly improving compression efficiency at large
+     * resolutions.  The smaller the size, the more effective wavefront and
+     * frame parallelism will become because of the increase in rows. default 64 */
+    uint32_t  maxCUSize;
+
+    /* The additional depth the residual quadtree is allowed to recurse beyond
+     * the coding quadtree, for inter coded blocks. This must be between 1 and
+     * 3. The higher the value the more efficiently the residual can be
+     * compressed by the DCT transforms, at the expense of much more compute */
+    uint32_t  tuQTMaxInterDepth;
+
+    /* The additional depth the residual quadtree is allowed to recurse beyond
+     * the coding quadtree, for intra coded blocks. This must be between 1 and
+     * 3. The higher the value the more efficiently the residual can be
+     * compressed by the DCT transforms, at the expense of much more compute */
+    uint32_t  tuQTMaxIntraDepth;
+
+    /*== GOP Structure and Lokoahead ==*/
+
+    /* Enable open GOP - meaning I slices are not necessariy IDR and thus frames
+     * encoded after an I slice may reference frames encoded prior to the I
+     * frame which have remained in the decoded picture buffer.  Open GOP
+     * generally has better compression efficiency and negligable encoder
+     * performance impact, but the use case may preclude it.  Default true */
+    int       bOpenGOP;
+
+    /* Scenecuts closer together than this are coded as I, not IDR. */
+    int       keyframeMin;
+
+    /* Maximum keyframe distance or intra period in number of frames. If 0 or 1,
+     * all frames are I frames. A negative value is casted to MAX_INT internally
+     * which effectively makes frame 0 the only I frame. Default is 250 */
+    int       keyframeMax;
+
+    /* The maximum number of L0 references a P or B slice may use. This
+     * influences the size of the decoded picture buffer. The higher this
+     * number, the more reference frames there will be available for motion
+     * search, improving compression efficiency of most video at a cost of
+     * performance. Value must be between 1 and 16, default is 3 */
+    int       maxNumReferences;
+
+    /* Sets the operating mode of the lookahead.  With b-adapt 0, the GOP
+     * structure is fixed based on the values of keyframeMax and bframes.
+     * With b-adapt 1 a light lookahead is used to chose B frame placement.
+     * With b-adapt 2 (trellis) a viterbi B path selection is performed */
+    int       bFrameAdaptive;
+
+    /* Maximum consecutive B frames that can be emitted by the lookehead. When
+     * b-adapt is 0 and keyframMax is greater than bframes, the lookahead emits
+     * a fixed pattern of `bframes` B frames between each P.  With b-adapt 1 the
+     * lookahead ignores the value of bframes for the most part.  With b-adapt 2
+     * the value of bframes determines the search (POC) distance performeed in
+     * both directions, quadradically increasing the compute load of the
+     * lookahead.  The higher the value, the more B frames the lookahead may
+     * possibly use consecutively, usually improving compression. Default is 3,
+     * maximum is 16 */
+    int       bframes;
+
+    /* Total Number of frames to be encoded, caclulated from the user input
+     * (--frames) and (--seek). In case, the input is read from a pipe, this can
+     * remain as 0. It is later used in 2 pass RateControl, hence storing the
+     * value in param */
+    int       totalFrames;
+
+    /* When enabled, the encoder will use the B frame in the middle of each
+     * mini-GOP larger than 2 B frames as a motion reference for the surrounding
+     * B frames.  This improves compression efficiency for a small performance
+     * penalty.  Referenced B frames are treated somewhere between a B and a P
+     * frame by rate control.  Default is enabled. */
+    int       bBPyramid;
+
+    /* The number of frames that must be queued in the lookahead before it may
+     * make slice decisions. Increasing this value directly increases the encode
+     * latency. The longer the queue the more optimally the lookahead may make
+     * slice decisions, particularly with b-adapt 2. When mb-tree is enabled,
+     * the length of the queue linearly increases the effectiveness of the
+     * mb-tree analysis. Default is 40 frames, maximum is 250 */
+    int       lookaheadDepth;
+
+    /* A value which is added to the cost estimate of B frames in the lookahead.
+     * It may be a positive value (making B frames appear more expensive, which
+     * causes the lookahead to chose more P frames) or negative, which makes the
+     * lookahead chose more B frames. Default is 0, there are no limits */
+    int       bFrameBias;
+
+    /* An arbitrary threshold which determines how agressively the lookahead
+     * should detect scene cuts. The default (40) is recommended. */
+    int       scenecutThreshold;
+
+    /*== Intra Coding Tools ==*/
+
+    /* Enable constrained intra prediction. This causes intra prediction to
+     * input samples that were inter predicted. For some use cases this is
+     * believed to me more robust to stream errors, but it has a compression
+     * penalty on P and (particularly) B slices. Defaults to diabled */
+    int       bEnableConstrainedIntra;
+
+    /* Enable strong intra smoothing for 32x32 blocks where the reference
+     * samples are flat. It may or may not improve compression efficiency,
+     * depending on your source material. Defaults to disabled */
+    int       bEnableStrongIntraSmoothing;
+
+    /* Use a faster search method to find the best intra mode. Default is 0 */
+    int       bEnableFastIntra;
+
+    /*== Inter Coding Tools ==*/
+
+    /* ME search method (DIA, HEX, UMH, STAR, FULL). The search patterns
+     * (methods) are sorted in increasing complexity, with diamond being the
+     * simplest and fastest and full being the slowest.  DIA, HEX, and UMH were
+     * adapted from x264 directly. STAR is an adaption of the HEVC reference
+     * encoder's three step search, while full is a naive exhaustive search. The
+     * default is the star search, it has a good balance of performance and
+     * compression efficiecy */
+    int       searchMethod;
+
+    /* A value between 0 and X265_MAX_SUBPEL_LEVEL which adjusts the amount of
+     * effort performed during subpel refine. Default is 5 */
+    int       subpelRefine;
+
+    /* The maximum distance from the motion prediction that the full pel motion
+     * search is allowed to progress before terminating. This value can have an
+     * effect on frame parallelism, as referenced frames must be at least this
+     * many rows of reconstructed pixels ahead of the referencee at all times.
+     * (When considering reference lag, the motion prediction must be ignored
+     * because it cannot be known ahead of time).  Default is 60, which is the
+     * default max CU size (64) minus the luma HPEL half-filter length (4). If a
+     * smaller CU size is used, the search range should be similarly reduced */
+    int       searchRange;
+
+    /* The maximum number of merge candidates that are considered during inter
+     * analysis.  This number (between 1 and 5) is signaled in the stream
+     * headers and determines the number of bits required to signal a merge so
+     * it can have significant trade-offs. The smaller this number the higher
+     * the performance but the less compression efficiency. Default is 3 */
+    uint32_t  maxNumMergeCand;
+
+    /* Disable availability of temporal motion vector for AMVP */
+    int       bEnableTemporalMvp;
+
+    /* Enable weighted prediction in P slices.  This enables weighting analysis
+     * in the lookahead, which influences slice decisions, and enables weighting
+     * analysis in the main encoder which allows P reference samples to have a
+     * weight function applied to them prior to using them for motion
+     * compensation.  In video which has lighting changes, it can give a large
+     * improvement in compression efficiency. Default is enabled */
+    int       bEnableWeightedPred;
+
+    /* Enable weighted prediction in B slices. Default is disabled */
+    int       bEnableWeightedBiPred;
+
+    /*== Analysis tools ==*/
+
+    /* Enable asymmetrical motion predictions.  At CU depths 64, 32, and 16, it
+     * is possible to use 25%/75% split partitions in the up, down, right, left
+     * directions. For some material this can improve compression efficiency at
+     * the cost of extra analysis. bEnableRectInter must be enabled for this
+     * feature to be used. Default enabled */
+    int       bEnableAMP;
+
+    /* Enable rectangular motion prediction partitions (vertical and
+     * horizontal), available at all CU depths from 64x64 to 8x8. Default is
+     * enabled */
+    int       bEnableRectInter;
+
+    /* Enable the use of `coded block flags` (flags set to true when a residual
+     * has been coded for a given block) to avoid intra analysis in likely skip
+     * blocks. Default is disabled */
+    int       bEnableCbfFastMode;
+
+    /* Enable early skip decisions to avoid intra and inter analysis in likely
+     * skip blocks. Default is disabled */
+    int       bEnableEarlySkip;
+
+    /* Apply an optional penalty to the estimated cost of 32x32 intra blocks in
+     * non-intra slices. 0 is disabled, 1 enables a small penalty, and 2 enables
+     * a full penalty. This favors inter-coding and its low bitrate over
+     * potential increases in distortion, but usually improves performance.
+     * Default is 0 */
+    int       rdPenalty;
+
+    /* A value betwen X265_NO_RDO_NO_RDOQ and X265_RDO_LEVEL which determines
+     * the level of rate distortion optimizations to perform during mode
+     * decisions and quantization. The more RDO the better the compression
+     * efficiency at a major cost of performance. Default is no RDO (0) */
+    int       rdLevel;
+
+    /* Psycho-visual rate-distortion strength. Only has an effect in presets
+     * which use RDO. It makes mode decision favor options which preserve the
+     * energy of the source, at the cost of lost compression. Default 0.0 */
+    double    psyRd;
+
+    /* Quantization scaling lists. HEVC supports 6 quantization scaling lists to
+     * be defined; one each for Y, Cb, Cr for intra prediction and one each for
+     * inter prediction.
+     *
+     * - NULL and "off" will disable quant scaling (default)
+     * - "default" will enable the HEVC default scaling lists, which
+     *   do not need to be signaled since they are specified
+     * - all other strings indicate a filename containing custom scaling lists
+     *   in the HM format. The encode will fail if the file is not parsed
+     *   correctly. Custom lists must be signaled in the SPS. */
+    const char *scalingLists;
+
+    /* Strength of psycho-visual optimizations in quantization. Only has an
+     * effect in presets which use RDOQ (rd-levels 4 and 5). Default 0.0 */
+    double    psyRdoq;
+
+    /* If X265_ANALYSIS_SAVE, write per-frame analysis information into analysis
+     * buffers.  if X265_ANALYSIS_LOAD, read analysis information into analysis
+     * buffer and use this analysis information to reduce the amount of work
+     * the encoder must perform. Default X265_ANALYSIS_OFF */
+    int       analysisMode;
+
+    /*== Coding tools ==*/
+
+    /* Enable the implicit signaling of the sign bit of the last coefficient of
+     * each transform unit. This saves one bit per TU at the expense of figuring
+     * out which coefficient can be toggled with the least distortion.
+     * Default is enabled */
+    int       bEnableSignHiding;
+
+    /* Allow intra coded blocks to be encoded directly as residual without the
+     * DCT transform, when this improves efficiency. Checking whether the block
+     * will benefit from this option incurs a performance penalty. Default is
+     * enabled */
+    int       bEnableTransformSkip;
+
+    /* Enable a faster determination of whether skippig the DCT transform will
+     * be beneficial. Slight performance gain for some compression loss. Default
+     * is enabled */
+    int       bEnableTSkipFast;
+
+    /* Enable the deblocking loop filter, which improves visual quality by
+     * reducing blocking effects at block edges, particularly at lower bitrates
+     * or higher QP. When enabled it adds another CU row of reference lag,
+     * reducing frame parallelism effectiveness.  Default is enabled */
+    int       bEnableLoopFilter;
+
+    /* Enable the Sample Adaptive Offset loop filter, which reduces distortion
+     * effects by adjusting reconstructed sample values based on histogram
+     * analysis to better approximate the original samples. When enabled it adds
+     * a CU row of reference lag, reducing frame parallelism effectiveness.
+     * Default is enabled */
+    int       bEnableSAO;
+
+    /* Note: when deblocking and SAO are both enabled, the loop filter CU lag is
+     * only one row, as they operate in series on the same row. */
+
+    /* Select the method in which SAO deals with deblocking boundary pixels.  If
+     * disabled the right and bottom boundary areas are skipped. If enabled,
+     * non-deblocked pixels are used entirely. Default is disabled */
+    int       bSaoNonDeblocked;
+
+    /* Generally a small signed integer which offsets the QP used to quantize
+     * the Cb chroma residual (delta from luma QP specified by rate-control).
+     * Default is 0, which is recommended */
+    int       cbQpOffset;
+
+    /* Generally a small signed integer which offsets the QP used to quantize
+     * the Cr chroma residual (delta from luma QP specified by rate-control).
+     * Default is 0, which is recommended */
+    int       crQpOffset;
+
+    /* Specify whether to attempt to encode intra modes in B frames. By default
+     * enabled, but only applicable for the presets which use rdLevel 5 or 6
+     * (veryslow and placebo). All other presets will not try intra in B frames
+     * regardless of this setting. */
+    int       bIntraInBFrames;
+
+    /* An integer value in range of 100 to 1000, which denotes strength of noise
+     * reduction */
+    int       noiseReduction;
+
+    /* The lossless flag enables true lossless coding, by bypassing scaling,
+     * transform, quantization and in-loop filter processes. This is used for
+     * ultra-high bitrates with zero loss of quality. */
+    int       bLossless;
+
+    /* The CU Lossless flag, when enabled, compares the rate-distortion costs
+     * for normal and lossless encoding, and chooses the best mode for each CU.
+     * If lossless mode is chosen, the cu-transquant-bypass flag is set for that
+     * CU. */
+    int       bCULossless;
+
+    /*== Rate Control ==*/
+
+    struct
+    {
+        /* Explicit mode of rate-control, necessary for API users. It must
+         * be one of the X265_RC_METHODS enum values. */
+        int       rateControlMode;
+
+        /* Base QP to use for Constant QP rate control. Adaptive QP may alter
+         * the QP used for each block. If a QP is specified on the command line
+         * CQP rate control is implied. Default: 32 */
+        int       qp;
+
+        /* target bitrate for Average BitRate (ABR) rate control. If a non- zero
+         * bitrate is specified on the command line, ABR is implied. Default 0 */
+        int       bitrate;
+
+        /* The degree of rate fluctuation that x265 tolerates. Rate tolerance is used
+         * alongwith overflow (difference between actual and target bitrate), to adjust
+         * qp. Default is 1.0 */
+        double    rateTolerance;
+
+        /* qComp sets the quantizer curve compression factor. It weights the frame
+         * quantizer based on the complexity of residual (measured by lookahead).
+         * Default value is 0.6. Increasing it to 1 will effectively generate CQP */
+        double    qCompress;
+
+        /* QP offset between I/P and P/B frames. Default ipfactor: 1.4
+         * Default pbFactor: 1.3 */
+        double    ipFactor;
+        double    pbFactor;
+
+        /* Max QP difference between frames. Default: 4 */
+        int       qpStep;
+
+        /* Ratefactor constant: targets a certain constant "quality".
+         * Acceptable values between 0 and 51. Default value: 28 */
+        double    rfConstant;
+
+        /* Enable adaptive quantization. This mode distributes available bits between all
+         * macroblocks of a frame, assigning more bits to low complexity areas. Turning
+         * this ON will usually affect PSNR negatively, however SSIM and visual quality
+         * generally improves. Default: X265_AQ_AUTO_VARIANCE */
+        int       aqMode;
+
+        /* Sets the strength of AQ bias towards low detail macroblocks. Valid only if
+         * AQ is enabled. Default value: 1.0. Acceptable values between 0.0 and 3.0 */
+        double    aqStrength;
+
+        /* Sets the maximum rate the VBV buffer should be assumed to refill at
+         * Default is zero */
+        int       vbvMaxBitrate;
+
+        /* Sets the size of the VBV buffer in kilobits. Default is zero */
+        int       vbvBufferSize;
+
+        /* Sets how full the VBV buffer must be before playback starts. If it is less than
+         * 1, then the initial fill is vbv-init * vbvBufferSize. Otherwise, it is
+         * interpreted as the initial fill in kbits. Default is 0.9 */
+        double    vbvBufferInit;
+
+        /* Enable CUTree ratecontrol. This keeps track of the CUs that propagate temporally
+         * across frames and assigns more bits to these CUs. Improves encode efficiency.
+         * Default: enabled */
+        int       cuTree;
+
+        /* In CRF mode, maximum CRF as caused by VBV. 0 implies no limit */
+        double    rfConstantMax;
+
+        /* In CRF mode, minimum CRF as caused by VBV */
+        double    rfConstantMin;
+
+        /* Two pass (INCOMPLETE) */
+        /* Enable writing the stats in a multipass encode to the stat output file */
+        int       bStatWrite;
+
+        /* Enable loading data from the stat input file in a multi pass encode */
+        int       bStatRead;
+
+        /* Filename of the 2pass output/input stats file */
+        char*     statFileName;
+
+        /* temporally blur quants */
+        double    qblur;
+
+        /* temporally blur complexity */
+        double    complexityBlur;
+
+        /* Enable slow and a more detailed first pass encode in multi pass rate control */
+        int       bEnableSlowFirstPass;
+
+        /* specify a text file which contains MAX_MAX_QP + 1 floating point
+         * values to be copied into x265_lambda_tab and a second set of
+         * MAX_MAX_QP + 1 floating point values for x265_lambda2_tab. All values
+         * are separated by comma, space or newline. Text after a hash (#) is
+         * ignored. The lambda tables are process-global, so these new lambda
+         * values will affect all encoders in the same process */
+        const char* lambdaFileName;
+    } rc;
+
+    /*== Video Usability Information ==*/
+    struct
+    {
+        /* Aspect ratio idc to be added to the VUI.  The default is 0 indicating
+         * the apsect ratio is unspecified. If set to X265_EXTENDED_SAR then
+         * sarWidth and sarHeight must also be set */
+        int aspectRatioIdc;
+
+        /* Sample Aspect Ratio width in arbitrary units to be added to the VUI
+         * only if aspectRatioIdc is set to X265_EXTENDED_SAR.  This is the width
+         * of an individual pixel. If this is set then sarHeight must also be set */
+        int sarWidth;
+
+        /* Sample Aspect Ratio height in arbitrary units to be added to the VUI.
+         * only if aspectRatioIdc is set to X265_EXTENDED_SAR.  This is the width
+         * of an individual pixel. If this is set then sarWidth must also be set */
+        int sarHeight;
+
+        /* Enable overscan info present flag in the VUI.  If this is set then
+         * bEnabledOverscanAppropriateFlag will be added to the VUI. The default
+         * is false */
+        int bEnableOverscanInfoPresentFlag;
+
+        /* Enable overscan appropriate flag.  The status of this flag is added
+         * to the VUI only if bEnableOverscanInfoPresentFlag is set. If this
+         * flag is set then cropped decoded pictures may be output for display.
+         * The default is false */
+        int bEnableOverscanAppropriateFlag;
+
+        /* Video signal type present flag of the VUI.  If this is set then
+         * videoFormat, bEnableVideoFullRangeFlag and
+         * bEnableColorDescriptionPresentFlag will be added to the VUI. The
+         * default is false */
+        int bEnableVideoSignalTypePresentFlag;
+
+        /* Video format of the source video.  0 = component, 1 = PAL, 2 = NTSC,
+         * 3 = SECAM, 4 = MAC, 5 = unspecified video format is the default */
+        int videoFormat;
+
+        /* Video full range flag indicates the black level and range of the luma
+         * and chroma signals as derived from Eâ²Y, Eâ²PB, and Eâ²PR or Eâ²R, Eâ²G,
+         * and Eâ²B real-valued component signals. The default is false */
+        int bEnableVideoFullRangeFlag;
+
+        /* Color description present flag in the VUI. If this is set then
+         * color_primaries, transfer_characteristics and matrix_coeffs are to be
+         * added to the VUI. The default is false */
+        int bEnableColorDescriptionPresentFlag;
+
+        /* Color primaries holds the chromacity coordinates of the source
+         * primaries. The default is 2 */
+        int colorPrimaries;
+
+        /* Transfer characteristics indicates the opto-electronic transfer
+         * characteristic of the source picture. The default is 2 */
+        int transferCharacteristics;
+
+        /* Matrix coefficients used to derive the luma and chroma signals from
+         * the red, blue and green primaries. The default is 2 */
+        int matrixCoeffs;
+
+        /* Chroma location info present flag adds chroma_sample_loc_type_top_field and
+         * chroma_sample_loc_type_bottom_field to the VUI. The default is false */
+        int bEnableChromaLocInfoPresentFlag;
+
+        /* Chroma sample location type top field holds the chroma location in
+         * the top field. The default is 0 */
+        int chromaSampleLocTypeTopField;
+
+        /* Chroma sample location type bottom field holds the chroma location in
+         * the bottom field. The default is 0 */
+        int chromaSampleLocTypeBottomField;
+
+        /* Default display window flag adds def_disp_win_left_offset,
+         * def_disp_win_right_offset, def_disp_win_top_offset and
+         * def_disp_win_bottom_offset to the VUI. The default is false */
+        int bEnableDefaultDisplayWindowFlag;
+
+        /* Default display window left offset holds the left offset with the
+         * conformance cropping window to further crop the displayed window */
+        int defDispWinLeftOffset;
+
+        /* Default display window right offset holds the right offset with the
+         * conformance cropping window to further crop the displayed window */
+        int defDispWinRightOffset;
+
+        /* Default display window top offset holds the top offset with the
+         * conformance cropping window to further crop the displayed window */
+        int defDispWinTopOffset;
+
+        /* Default display window bottom offset holds the bottom offset with the
+         * conformance cropping window to further crop the displayed window */
+        int defDispWinBottomOffset;
+    } vui;
+} x265_param;
+
+/***
+ * If not called, first encoder allocated will auto-detect the CPU and
+ * initialize performance primitives, which are process global.
+ * DEPRECATED: use x265_param.cpuid to specify CPU */
+void x265_setup_primitives(x265_param *param, int cpu);
+
+/* x265_param_alloc:
+ *  Allocates an x265_param instance. The returned param structure is not
+ *  special in any way, but using this method together with x265_param_free()
+ *  and x265_param_parse() to set values by name allows the application to treat
+ *  x265_param as an opaque data struct for version safety */
+x265_param *x265_param_alloc();
+
+/* x265_param_free:
+ *  Use x265_param_free() to release storage for an x265_param instance
+ *  allocated by x265_param_alloc() */
+void x265_param_free(x265_param *);
+
+/***
+ * Initialize an x265_param structure to default values
+ */
+void x265_param_default(x265_param *param);
+
+/* x265_param_parse:
+ *  set one parameter by name.
+ *  returns 0 on success, or returns one of the following errors.
+ *  note: BAD_VALUE occurs only if it can't even parse the value,
+ *  numerical range is not checked until x265_encoder_open().
+ *  value=NULL means "true" for boolean options, but is a BAD_VALUE for non-booleans. */
+#define X265_PARAM_BAD_NAME  (-1)
+#define X265_PARAM_BAD_VALUE (-2)
+int x265_param_parse(x265_param *p, const char *name, const char *value);
+
+/* x265_param_apply_profile:
+ *      Applies the restrictions of the given profile. (one of below) */
+static const char * const x265_profile_names[] = { "main", "main10", "mainstillpicture", 0 };
+
+/*      (can be NULL, in which case the function will do nothing)
+ *      returns 0 on success, negative on failure (e.g. invalid profile name). */
+int x265_param_apply_profile(x265_param *, const char *profile);
+
+/* x265_param_default_preset:
+ *      The same as x265_param_default, but also use the passed preset and tune
+ *      to modify the default settings.
+ *      (either can be NULL, which implies no preset or no tune, respectively)
+ *
+ *      Currently available presets are, ordered from fastest to slowest: */
+static const char * const x265_preset_names[] = { "ultrafast", "superfast", "veryfast", "faster", "fast", "medium", "slow", "slower", "veryslow", "placebo", 0 };
+
+/*      The presets can also be indexed numerically, as in:
+ *      x265_param_default_preset( &param, "3", ... )
+ *      with ultrafast mapping to "0" and placebo mapping to "9".  This mapping may
+ *      of course change if new presets are added in between, but will always be
+ *      ordered from fastest to slowest.
+ *
+ *      Warning: the speed of these presets scales dramatically.  Ultrafast is a full
+ *      100 times faster than placebo!
+ *
+ *      Currently available tunings are: */
+static const char * const x265_tune_names[] = { "psnr", "ssim", "zerolatency", "fastdecode", 0 };
+
+/*      returns 0 on success, negative on failure (e.g. invalid preset/tune name). */
+int x265_param_default_preset(x265_param *, const char *preset, const char *tune);
+
+/* x265_picture_alloc:
+ *  Allocates an x265_picture instance. The returned picture structure is not
+ *  special in any way, but using this method together with x265_picture_free()
+ *  and x265_picture_init() allows some version safety. New picture fields will
+ *  always be added to the end of x265_picture */
+x265_picture *x265_picture_alloc();
+
+/* x265_picture_free:
+ *  Use x265_picture_free() to release storage for an x265_picture instance
+ *  allocated by x265_picture_alloc() */
+void x265_picture_free(x265_picture *);
+
+/* x265_alloc_analysis_data:
+ *  Allocate memory to hold analysis data, returns 0 on success else negative */
+int x265_alloc_analysis_data(x265_picture*);
+
+/* x265_free_analysis_data:
+ *  Use x265_free_analysis_data to release storage of members allocated by
+ *  x265_alloc_analysis_data */
+void x265_free_analysis_data(x265_picture*);
+
+/***
+ * Initialize an x265_picture structure to default values. It sets the pixel
+ * depth and color space to the encoder's internal values and sets the slice
+ * type to auto - so the lookahead will determine slice type.
+ */
+void x265_picture_init(x265_param *param, x265_picture *pic);
+
+/* x265_max_bit_depth:
+ *      Specifies the maximum number of bits per pixel that x265 can input. This
+ *      is also the max bit depth that x265 encodes in.  When x265_max_bit_depth
+ *      is 8, the internal and input bit depths must be 8.  When
+ *      x265_max_bit_depth is 12, the internal and input bit depths can be
+ *      either 8, 10, or 12. Note that the internal bit depth must be the same
+ *      for all encoders allocated in the same process. */
+X265_API extern const int x265_max_bit_depth;
+
+/* x265_version_str:
+ *      A static string containing the version of this compiled x265 library */
+X265_API extern const char *x265_version_str;
+
+/* x265_build_info:
+ *      A static string describing the compiler and target architecture */
+X265_API extern const char *x265_build_info_str;
+
+/* Force a link error in the case of linking against an incompatible API version.
+ * Glue #defines exist to force correct macro expansion; the final output of the macro
+ * is x265_encoder_open_##X265_BUILD (for purposes of dlopen). */
+#define x265_encoder_glue1(x, y) x ## y
+#define x265_encoder_glue2(x, y) x265_encoder_glue1(x, y)
+#define x265_encoder_open x265_encoder_glue2(x265_encoder_open_, X265_BUILD)
+
+/* x265_encoder_open:
+ *      create a new encoder handler, all parameters from x265_param are copied */
+x265_encoder* x265_encoder_open(x265_param *);
+
+/* x265_encoder_parameters:
+ *      copies the current internal set of parameters to the pointer provided
+ *      by the caller.  useful when the calling application needs to know
+ *      how x265_encoder_open has changed the parameters.
+ *      note that the data accessible through pointers in the returned param struct
+ *      (e.g. filenames) should not be modified by the calling application. */
+void x265_encoder_parameters(x265_encoder *, x265_param *);
+
+/* x265_encoder_headers:
+ *      return the SPS and PPS that will be used for the whole stream.
+ *      *pi_nal is the number of NAL units outputted in pp_nal.
+ *      returns negative on error, total byte size of payload data on success
+ *      the payloads of all output NALs are guaranteed to be sequential in memory. */
+int x265_encoder_headers(x265_encoder *, x265_nal **pp_nal, uint32_t *pi_nal);
+
+/* x265_encoder_encode:
+ *      encode one picture.
+ *      *pi_nal is the number of NAL units outputted in pp_nal.
+ *      returns negative on error, 1 if a picture and access unit were output,
+ *      or zero if the encoder pipeline is still filling or is empty after flushing.
+ *      the payloads of all output NALs are guaranteed to be sequential in memory.
+ *      To flush the encoder and retrieve delayed output pictures, pass pic_in as NULL.
+ *      Once flushing has begun, all subsequent calls must pass pic_in as NULL. */
+int x265_encoder_encode(x265_encoder *encoder, x265_nal **pp_nal, uint32_t *pi_nal, x265_picture *pic_in, x265_picture *pic_out);
+
+/* x265_encoder_get_stats:
+ *       returns encoder statistics */
+void x265_encoder_get_stats(x265_encoder *encoder, x265_stats *, uint32_t statsSizeBytes);
+
+/* x265_encoder_log:
+ *       write a line to the configured CSV file.  If a CSV filename was not
+ *       configured, or file open failed, or the log level indicated frame level
+ *       logging, this function will perform no write. */
+void x265_encoder_log(x265_encoder *encoder, int argc, char **argv);
+
+/* x265_encoder_close:
+ *      close an encoder handler */
+void x265_encoder_close(x265_encoder *);
+
+/***
+ * Release library static allocations
+ */
+void x265_cleanup(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // X265_H
--- ffmpeg-2.5/localinc/xvid.h.dl_headers~	2014-12-04 22:53:11.256498996 +0100
+++ ffmpeg-2.5/localinc/xvid.h	2014-12-04 22:53:11.256498996 +0100
@@ -0,0 +1,830 @@
+/*****************************************************************************
+ *
+ * XVID MPEG-4 VIDEO CODEC
+ * - Xvid Main header file -
+ *
+ *  Copyright(C) 2001-2011 Peter Ross <pross@xvid.org>
+ *
+ *  This program is free software ; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation ; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY ; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program ; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * $Id: xvid.h 1985 2011-05-18 09:02:35Z Isibaar $
+ *
+ ****************************************************************************/
+
+#ifndef _XVID_H_
+#define _XVID_H_
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*****************************************************************************
+ * versioning
+ ****************************************************************************/
+
+/* versioning
+	version takes the form "$major.$minor.$patch"
+	$patch is incremented when there is no api change
+	$minor is incremented when the api is changed, but remains backwards compatible
+	$major is incremented when the api is changed significantly
+
+	when initialising an xvid structure, you must always zero it, and set the version field.
+		memset(&struct,0,sizeof(struct));
+		struct.version = XVID_VERSION;
+
+	XVID_UNSTABLE is defined only during development.
+	*/
+
+#define XVID_MAKE_VERSION(a,b,c) ((((a)&0xff)<<16) | (((b)&0xff)<<8) | ((c)&0xff))
+#define XVID_VERSION_MAJOR(a)    ((char)(((a)>>16) & 0xff))
+#define XVID_VERSION_MINOR(a)    ((char)(((a)>> 8) & 0xff))
+#define XVID_VERSION_PATCH(a)    ((char)(((a)>> 0) & 0xff))
+
+#define XVID_MAKE_API(a,b)       ((((a)&0xff)<<16) | (((b)&0xff)<<0))
+#define XVID_API_MAJOR(a)        (((a)>>16) & 0xff)
+#define XVID_API_MINOR(a)        (((a)>> 0) & 0xff)
+
+#define XVID_VERSION             XVID_MAKE_VERSION(1,3,2)
+#define XVID_API                 XVID_MAKE_API(4, 3)
+
+/* Bitstream Version
+ * this will be writen into the bitstream to allow easy detection of xvid
+ * encoder bugs in the decoder, without this it might not possible to
+ * automatically distinquish between a file which has been encoded with an
+ * old & buggy XVID from a file which has been encoded with a bugfree version
+ * see the infamous interlacing bug ...
+ *
+ * this MUST be increased if an encoder bug is fixed, increasing it too often
+ * doesnt hurt but not increasing it could cause difficulty for decoders in the
+ * future
+ */
+#define XVID_BS_VERSION 64 
+
+/*****************************************************************************
+ * error codes
+ ****************************************************************************/
+
+	/*	all functions return values <0 indicate error */
+
+#define XVID_ERR_FAIL		-1		/* general fault */
+#define XVID_ERR_MEMORY		-2		/* memory allocation error */
+#define XVID_ERR_FORMAT		-3		/* file format error */
+#define XVID_ERR_VERSION	-4		/* structure version not supported */
+#define XVID_ERR_END		-5		/* encoder only; end of stream reached */
+
+
+
+/*****************************************************************************
+ * xvid_image_t
+ ****************************************************************************/
+
+/* colorspace values */
+
+#define XVID_CSP_PLANAR   (1<< 0) /* 4:2:0 planar (==I420, except for pointers/strides) */
+#define XVID_CSP_USER	  XVID_CSP_PLANAR
+#define XVID_CSP_I420     (1<< 1) /* 4:2:0 planar */
+#define XVID_CSP_YV12     (1<< 2) /* 4:2:0 planar */
+#define XVID_CSP_YUY2     (1<< 3) /* 4:2:2 packed */
+#define XVID_CSP_UYVY     (1<< 4) /* 4:2:2 packed */
+#define XVID_CSP_YVYU     (1<< 5) /* 4:2:2 packed */
+#define XVID_CSP_RGB      (1<<16) /* 24-bit rgb packed */
+#define XVID_CSP_BGRA     (1<< 6) /* 32-bit bgra packed */
+#define XVID_CSP_ABGR     (1<< 7) /* 32-bit abgr packed */
+#define XVID_CSP_RGBA     (1<< 8) /* 32-bit rgba packed */
+#define XVID_CSP_ARGB     (1<<15) /* 32-bit argb packed */
+#define XVID_CSP_BGR      (1<< 9) /* 24-bit bgr packed */
+#define XVID_CSP_RGB555   (1<<10) /* 16-bit rgb555 packed */
+#define XVID_CSP_RGB565   (1<<11) /* 16-bit rgb565 packed */
+#define XVID_CSP_SLICE    (1<<12) /* decoder only: 4:2:0 planar, per slice rendering */
+#define XVID_CSP_INTERNAL (1<<13) /* decoder only: 4:2:0 planar, returns ptrs to internal buffers */
+#define XVID_CSP_NULL     (1<<14) /* decoder only: dont output anything */
+#define XVID_CSP_VFLIP    (1<<31) /* vertical flip mask */
+
+/* xvid_image_t
+	for non-planar colorspaces use only plane[0] and stride[0]
+	four plane reserved for alpha*/
+typedef struct {
+	int csp;				/* [in] colorspace; or with XVID_CSP_VFLIP to perform vertical flip */
+	void * plane[4];		/* [in] image plane ptrs */
+	int stride[4];			/* [in] image stride; "bytes per row"*/
+} xvid_image_t;
+
+/* video-object-sequence profiles */
+#define XVID_PROFILE_S_L0    0x08 /* simple */
+#define XVID_PROFILE_S_L1    0x01
+#define XVID_PROFILE_S_L2    0x02
+#define XVID_PROFILE_S_L3    0x03
+#define XVID_PROFILE_S_L4a   0x04
+#define XVID_PROFILE_S_L5    0x05
+#define XVID_PROFILE_S_L6    0x06
+#define XVID_PROFILE_ARTS_L1 0x91 /* advanced realtime simple */
+#define XVID_PROFILE_ARTS_L2 0x92
+#define XVID_PROFILE_ARTS_L3 0x93
+#define XVID_PROFILE_ARTS_L4 0x94
+#define XVID_PROFILE_AS_L0   0xf0 /* advanced simple */
+#define XVID_PROFILE_AS_L1   0xf1
+#define XVID_PROFILE_AS_L2   0xf2
+#define XVID_PROFILE_AS_L3   0xf3
+#define XVID_PROFILE_AS_L4   0xf4
+
+/* aspect ratios */
+#define XVID_PAR_11_VGA    1 /* 1:1 vga (square), default if supplied PAR is not a valid value */
+#define XVID_PAR_43_PAL    2 /* 4:3 pal (12:11 625-line) */
+#define XVID_PAR_43_NTSC   3 /* 4:3 ntsc (10:11 525-line) */
+#define XVID_PAR_169_PAL   4 /* 16:9 pal (16:11 625-line) */
+#define XVID_PAR_169_NTSC  5 /* 16:9 ntsc (40:33 525-line) */
+#define XVID_PAR_EXT      15 /* extended par; use par_width, par_height */
+
+/* frame type flags */
+#define XVID_TYPE_VOL     -1 /* decoder only: vol was decoded */
+#define XVID_TYPE_NOTHING  0 /* decoder only (encoder stats): nothing was decoded/encoded */
+#define XVID_TYPE_AUTO     0 /* encoder: automatically determine coding type */
+#define XVID_TYPE_IVOP     1 /* intra frame */
+#define XVID_TYPE_PVOP     2 /* predicted frame */
+#define XVID_TYPE_BVOP     3 /* bidirectionally encoded */
+#define XVID_TYPE_SVOP     4 /* predicted+sprite frame */
+
+
+/*****************************************************************************
+ * xvid_global()
+ ****************************************************************************/
+
+/* cpu_flags definitions (make sure to sync this with cpuid.asm for ia32) */
+
+#define XVID_CPU_FORCE    (1<<31) /* force passed cpu flags */
+#define XVID_CPU_ASM      (1<< 7) /* native assembly */
+/* ARCH_IS_IA32 */
+#define XVID_CPU_MMX      (1<< 0) /*       mmx : pentiumMMX,k6 */
+#define XVID_CPU_MMXEXT   (1<< 1) /*   mmx-ext : pentium2, athlon */
+#define XVID_CPU_SSE      (1<< 2) /*       sse : pentium3, athlonXP */
+#define XVID_CPU_SSE2     (1<< 3) /*      sse2 : pentium4, athlon64 */
+#define XVID_CPU_SSE3     (1<< 8) /*      sse3 : pentium4, athlon64 */
+#define XVID_CPU_SSE41    (1<< 9) /*      sse41: penryn */
+#define XVID_CPU_3DNOW    (1<< 4) /*     3dnow : k6-2 */
+#define XVID_CPU_3DNOWEXT (1<< 5) /* 3dnow-ext : athlon */
+#define XVID_CPU_TSC      (1<< 6) /*       tsc : Pentium */
+/* ARCH_IS_PPC */
+#define XVID_CPU_ALTIVEC  (1<< 0) /* altivec */
+
+
+#define XVID_DEBUG_ERROR     (1<< 0)
+#define XVID_DEBUG_STARTCODE (1<< 1)
+#define XVID_DEBUG_HEADER    (1<< 2)
+#define XVID_DEBUG_TIMECODE  (1<< 3)
+#define XVID_DEBUG_MB        (1<< 4)
+#define XVID_DEBUG_COEFF     (1<< 5)
+#define XVID_DEBUG_MV        (1<< 6)
+#define XVID_DEBUG_RC        (1<< 7)
+#define XVID_DEBUG_DEBUG     (1<<31)
+
+/* XVID_GBL_INIT param1 */
+typedef struct {
+	int version;
+	unsigned int cpu_flags; /* [in:opt] zero = autodetect cpu; XVID_CPU_FORCE|{cpu features} = force cpu features */
+	int debug;     /* [in:opt] debug level */
+} xvid_gbl_init_t;
+
+
+/* XVID_GBL_INFO param1 */
+typedef struct {
+	int version;
+	int actual_version; /* [out] returns the actual xvidcore version */
+	const char * build; /* [out] if !null, points to description of this xvid core build */
+	unsigned int cpu_flags;      /* [out] detected cpu features */
+	int num_threads;    /* [out] detected number of cpus/threads */
+} xvid_gbl_info_t;
+
+
+/* XVID_GBL_CONVERT param1 */
+typedef struct {
+	int version;
+	xvid_image_t input;  /* [in] input image & colorspace */
+	xvid_image_t output; /* [in] output image & colorspace */
+	int width;           /* [in] width */
+	int height;          /* [in] height */
+	int interlacing;     /* [in] interlacing */
+} xvid_gbl_convert_t;
+
+
+#define XVID_GBL_INIT    0 /* initialize xvidcore; must be called before using xvid_decore, or xvid_encore) */
+#define XVID_GBL_INFO    1 /* return some info about xvidcore, and the host computer */
+#define XVID_GBL_CONVERT 2 /* colorspace conversion utility */
+
+extern int xvid_global(void *handle, int opt, void *param1, void *param2);
+
+
+/*****************************************************************************
+ * xvid_decore()
+ ****************************************************************************/
+
+#define XVID_DEC_CREATE  0 /* create decore instance; return 0 on success */
+#define XVID_DEC_DESTROY 1 /* destroy decore instance: return 0 on success */
+#define XVID_DEC_DECODE  2 /* decode a frame: returns number of bytes consumed >= 0 */
+
+extern int xvid_decore(void *handle, int opt, void *param1, void *param2);
+
+/* XVID_DEC_CREATE param 1
+	image width & height as well as FourCC code may be specified 
+	here when known in advance (e.g. being read from container) */
+typedef struct {
+	int version;
+	int width;      /* [in:opt] image width */
+	int height;     /* [in:opt] image width */
+	void * handle;  /* [out]    decore context handle */
+/* ------- v1.3.x ------- */
+	int fourcc;     /* [in:opt] fourcc of the input video */
+	int num_threads;/* [in:opt] number of threads to use in decoder */
+} xvid_dec_create_t;
+
+
+/* XVID_DEC_DECODE param1 */
+/* general flags */
+#define XVID_LOWDELAY      (1<<0) /* lowdelay mode  */
+#define XVID_DISCONTINUITY (1<<1) /* indicates break in stream */
+#define XVID_DEBLOCKY      (1<<2) /* perform luma deblocking */
+#define XVID_DEBLOCKUV     (1<<3) /* perform chroma deblocking */
+#define XVID_FILMEFFECT    (1<<4) /* adds film grain */
+#define XVID_DERINGUV      (1<<5) /* perform chroma deringing, requires deblocking to work */
+#define XVID_DERINGY       (1<<6) /* perform luma deringing, requires deblocking to work */
+
+#define XVID_DEC_FAST      (1<<29) /* disable postprocessing to decrease cpu usage *todo* */
+#define XVID_DEC_DROP      (1<<30) /* drop bframes to decrease cpu usage *todo* */
+#define XVID_DEC_PREROLL   (1<<31) /* decode as fast as you can, don't even show output *todo* */
+
+typedef struct {
+	int version;
+	int general;         /* [in:opt] general flags */
+	void *bitstream;     /* [in]     bitstream (read from)*/
+	int length;          /* [in]     bitstream length */
+	xvid_image_t output; /* [in]     output image (written to) */
+/* ------- v1.1.x ------- */
+	int brightness;		 /* [in]	 brightness offset (0=none) */
+} xvid_dec_frame_t;
+
+
+/* XVID_DEC_DECODE param2 :: optional */
+typedef struct
+{
+	int version;
+
+	int type;                   /* [out] output data type */
+	union {
+		struct { /* type>0 {XVID_TYPE_IVOP,XVID_TYPE_PVOP,XVID_TYPE_BVOP,XVID_TYPE_SVOP} */
+			int general;        /* [out] flags */
+			int time_base;      /* [out] time base */
+			int time_increment; /* [out] time increment */
+
+			/* XXX: external deblocking stuff */
+			int * qscale;	    /* [out] pointer to quantizer table */
+			int qscale_stride;  /* [out] quantizer scale stride */
+
+		} vop;
+		struct {	/* XVID_TYPE_VOL */
+			int general;        /* [out] flags */
+			int width;          /* [out] width */
+			int height;         /* [out] height */
+			int par;            /* [out] pixel aspect ratio (refer to XVID_PAR_xxx above) */
+			int par_width;      /* [out] aspect ratio width  [1..255] */
+			int par_height;     /* [out] aspect ratio height [1..255] */
+		} vol;
+	} data;
+} xvid_dec_stats_t;
+
+#define XVID_ZONE_QUANT  (1<<0)
+#define XVID_ZONE_WEIGHT (1<<1)
+
+typedef struct
+{
+	int frame;
+	int mode;
+	int increment;
+	int base;
+} xvid_enc_zone_t;
+
+
+/*----------------------------------------------------------------------------
+ * xvid_enc_stats_t structure
+ *
+ * Used in:
+ *  - xvid_plg_data_t structure
+ *  - optional parameter in xvid_encore() function
+ *
+ * .coding_type = XVID_TYPE_NOTHING if the stats are not given
+ *--------------------------------------------------------------------------*/
+
+typedef struct {
+	int version;
+
+	/* encoding parameters */
+	int type;      /* [out] coding type */
+	int quant;     /* [out] frame quantizer */
+	int vol_flags; /* [out] vol flags (see above) */
+	int vop_flags; /* [out] vop flags (see above) */
+
+	/* bitrate */
+	int length;    /* [out] frame length */
+
+	int hlength;   /* [out] header length (bytes) */
+	int kblks;     /* [out] number of blocks compressed as Intra */
+	int mblks;     /* [out] number of blocks compressed as Inter */
+	int ublks;     /* [out] number of blocks marked as not_coded */
+
+	int sse_y;     /* [out] Y plane's sse */
+	int sse_u;     /* [out] U plane's sse */
+	int sse_v;     /* [out] V plane's sse */
+} xvid_enc_stats_t;
+
+/*****************************************************************************
+  xvid plugin system -- internals
+
+  xvidcore will call XVID_PLG_INFO and XVID_PLG_CREATE during XVID_ENC_CREATE
+  before encoding each frame xvidcore will call XVID_PLG_BEFORE
+  after encoding each frame xvidcore will call XVID_PLG_AFTER
+  xvidcore will call XVID_PLG_DESTROY during XVID_ENC_DESTROY
+ ****************************************************************************/
+
+
+#define XVID_PLG_CREATE  (1<<0)
+#define XVID_PLG_DESTROY (1<<1)
+#define XVID_PLG_INFO    (1<<2)
+#define XVID_PLG_BEFORE  (1<<3)
+#define XVID_PLG_FRAME   (1<<4)
+#define XVID_PLG_AFTER   (1<<5)
+
+/* xvid_plg_info_t.flags */
+#define XVID_REQORIGINAL (1<<0) /* plugin requires a copy of the original (uncompressed) image */
+#define XVID_REQPSNR     (1<<1) /* plugin requires psnr between the uncompressed and compressed image*/
+#define XVID_REQDQUANTS  (1<<2) /* plugin requires access to the dquant table */
+#define XVID_REQLAMBDA   (1<<3) /* plugin requires access to the lambda table */
+
+typedef struct
+{
+	int version;
+	int flags;   /* [in:opt] plugin flags */
+} xvid_plg_info_t;
+
+
+typedef struct
+{
+	int version;
+
+	int num_zones;           /* [out] */
+	xvid_enc_zone_t * zones; /* [out] */
+
+	int width;               /* [out] */
+	int height;              /* [out] */
+	int mb_width;            /* [out] */
+	int mb_height;           /* [out] */
+	int fincr;               /* [out] */
+	int fbase;               /* [out] */
+
+	void * param;            /* [out] */
+} xvid_plg_create_t;
+
+
+typedef struct
+{
+	int version;
+
+	int num_frames; /* [out] total frame encoded */
+} xvid_plg_destroy_t;
+
+typedef struct
+{
+	int version;
+
+	xvid_enc_zone_t * zone; /* [out] current zone */
+
+	int width;              /* [out] */
+	int height;             /* [out] */
+	int mb_width;           /* [out] */
+	int mb_height;          /* [out] */
+	int fincr;              /* [out] */
+	int fbase;              /* [out] */
+
+	int min_quant[3];       /* [out] */
+	int max_quant[3];       /* [out] */
+
+	xvid_image_t reference; /* [out] -> [out] */
+	xvid_image_t current;   /* [out] -> [in,out] */
+	xvid_image_t original;  /* [out] after: points the original (uncompressed) copy of the current frame */
+	int frame_num;          /* [out] frame number */
+
+	int type;               /* [in,out] */
+	int quant;              /* [in,out] */
+
+	int * dquant;           /* [in,out]	pointer to diff quantizer table */
+	int dquant_stride;      /* [in,out]	diff quantizer stride */
+
+	int vop_flags;          /* [in,out] */
+	int vol_flags;          /* [in,out] */
+	int motion_flags;       /* [in,out] */
+
+	/* Lambda table for HVSPlugins */
+	float * lambda;         /* [in,out] six floats for each macroblock. read, multiply, write back */
+
+/* Deprecated, use the stats field instead.
+ * Will disapear before 1.0 */
+	int length;             /* [out] after: length of encoded frame */
+	int kblks;              /* [out] number of blocks compressed as Intra */
+	int mblks;              /* [out] number of blocks compressed as Inter */
+	int ublks;              /* [out] number of blocks marked not_coded */
+	int sse_y;              /* [out] Y plane's sse */
+	int sse_u;              /* [out] U plane's sse */
+	int sse_v;              /* [out] V plane's sse */
+/* End of duplicated data, kept only for binary compatibility */
+
+	int bquant_ratio;       /* [in] */
+	int bquant_offset;      /* [in] */
+
+	xvid_enc_stats_t stats; /* [out] frame statistics */
+} xvid_plg_data_t;
+
+/*****************************************************************************
+  xvid plugin system -- external
+
+  the application passes xvid an array of "xvid_plugin_t" at XVID_ENC_CREATE. the array
+  indicates the plugin function pointer and plugin-specific data.
+  xvidcore handles the rest. example:
+
+  xvid_enc_create_t create;
+  xvid_enc_plugin_t plugins[2];
+
+  plugins[0].func = xvid_psnr_func;
+  plugins[0].param = NULL;
+  plugins[1].func = xvid_cbr_func;
+  plugins[1].param = &cbr_data;
+
+  create.num_plugins = 2;
+  create.plugins = plugins;
+
+ ****************************************************************************/
+
+typedef int (xvid_plugin_func)(void * handle, int opt, void * param1, void * param2);
+
+typedef struct
+{
+	xvid_plugin_func * func;
+	void * param;
+} xvid_enc_plugin_t;
+
+
+extern xvid_plugin_func xvid_plugin_single;   /* single-pass rate control */
+extern xvid_plugin_func xvid_plugin_2pass1;   /* two-pass rate control: first pass */
+extern xvid_plugin_func xvid_plugin_2pass2;   /* two-pass rate control: second pass */
+
+extern xvid_plugin_func xvid_plugin_lumimasking;  /* lumimasking */
+
+extern xvid_plugin_func xvid_plugin_psnr;	/* write psnr values to stdout */
+extern xvid_plugin_func xvid_plugin_dump;	/* dump before and after yuvpgms */
+
+extern xvid_plugin_func xvid_plugin_ssim;	    /*write ssim values to stdout*/
+extern xvid_plugin_func xvid_plugin_psnrhvsm;	/*write psnrhvsm values to stdout*/
+
+
+/* single pass rate control
+ * CBR and Constant quantizer modes */
+typedef struct
+{
+	int version;
+
+	int bitrate;               /* [in] bits per second */
+	int reaction_delay_factor; /* [in] */
+	int averaging_period;      /* [in] */
+	int buffer;                /* [in] */
+} xvid_plugin_single_t;
+
+
+typedef struct {
+	int version;
+
+	char * filename;
+} xvid_plugin_2pass1_t;
+
+
+#define XVID_PAYBACK_BIAS 0 /* payback with bias */
+#define XVID_PAYBACK_PROP 1 /* payback proportionally */
+
+typedef struct {
+	int version;
+
+	int bitrate;                  /* [in] target bitrate (bits per second) */
+	char * filename;              /* [in] first pass stats filename */
+
+	int keyframe_boost;           /* [in] keyframe boost percentage: [0..100] */
+	int curve_compression_high;   /* [in] percentage of compression performed on the high part of the curve (above average) */
+	int curve_compression_low;    /* [in] percentage of compression performed on the low  part of the curve (below average) */
+	int overflow_control_strength;/* [in] Payback delay expressed in number of frames */
+	int max_overflow_improvement; /* [in] percentage of allowed range for a frame that gets bigger because of overflow bonus */
+	int max_overflow_degradation; /* [in] percentage of allowed range for a frame that gets smaller because of overflow penalty */
+
+	int kfreduction;              /* [in] maximum bitrate reduction applied to an iframe under the kfthreshold distance limit */
+	int kfthreshold;              /* [in] if an iframe is closer to the next iframe than this distance, a quantity of bits
+								   *      is substracted from its bit allocation. The reduction is computed as multiples of
+								   *      kfreduction/kthreshold. It reaches kfreduction when the distance == kfthreshold,
+								   *      0 for 1<distance<kfthreshold */
+
+	int container_frame_overhead; /* [in] How many bytes the controller has to compensate per frame due to container format overhead */
+
+/* ------- v1.1.x ------- */
+	int vbv_size;                 /* [in] buffer size (bits) If this is zero, VBV check is disabled.*/
+	int vbv_initial;              /* [in] initial buffer occupancy (bits) */
+	int vbv_maxrate;              /* [in] max processing bitrate (bits per second) */
+	int vbv_peakrate;             /* [in:opt] max average bitrate over 1 second (bits per second).
+								   *          This is used for diagnostics only and won't affect the actual peak bitrate.
+								   *          This is not a problem as long as vbv_peakrate > vbv_size + vbv_maxrate which
+								   *          guarantees that vbv_peakrate won't be exceeded. */
+}xvid_plugin_2pass2_t;
+
+
+typedef struct{
+	/*stat output*/
+	int b_printstat;
+	char* stat_path;
+	
+	/*visualize*/
+	int b_visualize;
+
+	/*accuracy 0 very accurate 4 very fast*/
+	int acc; 
+
+    int cpu_flags; /* XVID_CPU_XXX flags */
+
+} xvid_plugin_ssim_t;
+
+typedef struct {
+        int version;
+
+        int method;      /* [in] masking method to apply. 0 for luminance masking, 1 for variance masking */
+} xvid_plugin_lumimasking_t;
+
+/*****************************************************************************
+ *                             ENCODER API
+ ****************************************************************************/
+
+/*----------------------------------------------------------------------------
+ * Encoder operations
+ *--------------------------------------------------------------------------*/
+
+#define XVID_ENC_CREATE  0 /* create encoder instance; returns 0 on success */
+#define XVID_ENC_DESTROY 1 /* destroy encoder instance; returns 0 on success */
+#define XVID_ENC_ENCODE  2 /* encode a frame: returns number of ouput bytes
+                            * 0 means this frame should not be written (ie. encoder lag) */
+
+
+/*----------------------------------------------------------------------------
+ * Encoder entry point
+ *--------------------------------------------------------------------------*/
+
+extern int xvid_encore(void *handle, int opt, void *param1, void *param2);
+
+/* Quick API reference
+ *
+ * XVID_ENC_CREATE operation
+ *  - handle: ignored
+ *  - opt: XVID_ENC_CREATE
+ *  - param1: address of a xvid_enc_create_t structure
+ *  - param2: ignored
+ *
+ * XVID_ENC_ENCODE operation
+ *  - handle: an instance returned by a CREATE op
+ *  - opt: XVID_ENC_ENCODE
+ *  - param1: address of a xvid_enc_frame_t structure
+ *  - param2: address of a xvid_enc_stats_t structure (optional)
+ *            its return value is asynchronous to what is written to the buffer
+ *            depending on the delay introduced by bvop use. It's display
+ *            ordered.
+ *
+ * XVID_ENC_DESTROY operation
+ *  - handle: an instance returned by a CREATE op
+ *  - opt: XVID_ENC_DESTROY
+ *  - param1: ignored
+ *  - param2: ignored
+ */
+
+
+/*----------------------------------------------------------------------------
+ * "Global" flags
+ *
+ * These flags are used for xvid_enc_create_t->global field during instance
+ * creation (operation XVID_ENC_CREATE)
+ *--------------------------------------------------------------------------*/
+
+#define XVID_GLOBAL_PACKED            (1<<0) /* packed bitstream */
+#define XVID_GLOBAL_CLOSED_GOP        (1<<1) /* closed_gop:	was DX50BVOP dx50 bvop compatibility */
+#define XVID_GLOBAL_EXTRASTATS_ENABLE (1<<2)
+#if 0
+#define XVID_GLOBAL_VOL_AT_IVOP       (1<<3) /* write vol at every ivop: WIN32/divx compatibility */
+#define XVID_GLOBAL_FORCE_VOL         (1<<4) /* when vol-based parameters are changed, insert an ivop NOT recommended */
+#endif
+#define XVID_GLOBAL_DIVX5_USERDATA    (1<<5) /* write divx5 userdata string 
+                                                this is implied if XVID_GLOBAL_PACKED is set */
+
+/*----------------------------------------------------------------------------
+ * "VOL" flags
+ *
+ * These flags are used for xvid_enc_frame_t->vol_flags field during frame
+ * encoding (operation XVID_ENC_ENCODE)
+ *--------------------------------------------------------------------------*/
+
+#define XVID_VOL_MPEGQUANT      (1<<0) /* enable MPEG type quantization */
+#define XVID_VOL_EXTRASTATS     (1<<1) /* enable plane sse stats */
+#define XVID_VOL_QUARTERPEL     (1<<2) /* enable quarterpel: frames will encoded as quarterpel */
+#define XVID_VOL_GMC            (1<<3) /* enable GMC; frames will be checked for gmc suitability */
+#define XVID_VOL_REDUCED_ENABLE (1<<4) /* enable reduced resolution vops: frames will be checked for rrv suitability */
+									   /* NOTE:  the reduced resolution feature is not supported anymore. This flag will have no effect! */
+#define XVID_VOL_INTERLACING    (1<<5) /* enable interlaced encoding */
+
+
+/*----------------------------------------------------------------------------
+ * "VOP" flags
+ *
+ * These flags are used for xvid_enc_frame_t->vop_flags field during frame
+ * encoding (operation XVID_ENC_ENCODE)
+ *--------------------------------------------------------------------------*/
+
+/* Always valid */
+#define XVID_VOP_DEBUG                (1<< 0) /* print debug messages in frames */
+#define XVID_VOP_HALFPEL              (1<< 1) /* use halfpel interpolation */
+#define XVID_VOP_INTER4V              (1<< 2) /* use 4 motion vectors per MB */
+#define XVID_VOP_TRELLISQUANT         (1<< 3) /* use trellis based R-D "optimal" quantization */
+#define XVID_VOP_CHROMAOPT            (1<< 4) /* enable chroma optimization pre-filter */
+#define XVID_VOP_CARTOON              (1<< 5) /* use 'cartoon mode' */
+#define XVID_VOP_GREYSCALE            (1<< 6) /* enable greyscale only mode (even for  color input material chroma is ignored) */
+#define XVID_VOP_HQACPRED             (1<< 7) /* high quality ac prediction */
+#define XVID_VOP_MODEDECISION_RD      (1<< 8) /* enable DCT-ME and use it for mode decision */
+#define XVID_VOP_FAST_MODEDECISION_RD (1<<12) /* use simplified R-D mode decision */
+#define XVID_VOP_RD_BVOP              (1<<13) /* enable rate-distortion mode decision in b-frames */
+#define XVID_VOP_RD_PSNRHVSM          (1<<14) /* use PSNR-HVS-M as metric for rate-distortion optimizations */
+
+/* Only valid for vol_flags|=XVID_VOL_INTERLACING */
+#define XVID_VOP_TOPFIELDFIRST        (1<< 9) /* set top-field-first flag  */
+#define XVID_VOP_ALTERNATESCAN        (1<<10) /* set alternate vertical scan flag */
+
+/* only valid for vol_flags|=XVID_VOL_REDUCED_ENABLED */
+#define XVID_VOP_REDUCED              (1<<11) /* reduced resolution vop */
+											  /* NOTE: reduced resolution feature is not supported anymore. This flag will have no effect! */
+
+/*----------------------------------------------------------------------------
+ * "Motion" flags
+ *
+ * These flags are used for xvid_enc_frame_t->motion field during frame
+ * encoding (operation XVID_ENC_ENCODE)
+ *--------------------------------------------------------------------------*/
+
+/* Motion Estimation Search Patterns */
+#define XVID_ME_ADVANCEDDIAMOND16     (1<< 0) /* use advdiamonds instead of diamonds as search pattern */
+#define XVID_ME_ADVANCEDDIAMOND8      (1<< 1) /* use advdiamond for XVID_ME_EXTSEARCH8 */
+#define XVID_ME_USESQUARES16          (1<< 2) /* use squares instead of diamonds as search pattern */
+#define XVID_ME_USESQUARES8           (1<< 3) /* use square for XVID_ME_EXTSEARCH8 */
+
+/* SAD operator based flags */
+#define XVID_ME_HALFPELREFINE16       (1<< 4)
+#define XVID_ME_HALFPELREFINE8        (1<< 6)
+#define XVID_ME_QUARTERPELREFINE16    (1<< 7)
+#define XVID_ME_QUARTERPELREFINE8     (1<< 8)
+#define XVID_ME_GME_REFINE            (1<< 9)
+#define XVID_ME_EXTSEARCH16           (1<<10) /* extend PMV by more searches */
+#define XVID_ME_EXTSEARCH8            (1<<11) /* use diamond/square for extended 8x8 search */
+#define XVID_ME_CHROMA_PVOP           (1<<12) /* also use chroma for P_VOP/S_VOP ME */
+#define XVID_ME_CHROMA_BVOP           (1<<13) /* also use chroma for B_VOP ME */
+#define XVID_ME_FASTREFINE16          (1<<25) /* use low-complexity refinement functions */
+#define XVID_ME_FASTREFINE8           (1<<29) /* low-complexity 8x8 sub-block refinement */
+
+/* Rate Distortion based flags
+ * Valid when XVID_VOP_MODEDECISION_RD is enabled */
+#define XVID_ME_HALFPELREFINE16_RD    (1<<14) /* perform RD-based halfpel refinement */
+#define XVID_ME_HALFPELREFINE8_RD     (1<<15) /* perform RD-based halfpel refinement for 8x8 mode */
+#define XVID_ME_QUARTERPELREFINE16_RD (1<<16) /* perform RD-based qpel refinement */
+#define XVID_ME_QUARTERPELREFINE8_RD  (1<<17) /* perform RD-based qpel refinement for 8x8 mode */
+#define XVID_ME_EXTSEARCH_RD          (1<<18) /* perform RD-based search using square pattern enable XVID_ME_EXTSEARCH8 to do this in 8x8 search as well */
+#define XVID_ME_CHECKPREDICTION_RD    (1<<19) /* always check vector equal to prediction */
+
+/* Other */
+#define XVID_ME_DETECT_STATIC_MOTION  (1<<24) /* speed-up ME by detecting stationary scenes */
+#define XVID_ME_SKIP_DELTASEARCH      (1<<26) /* speed-up by skipping b-frame delta search */
+#define XVID_ME_FAST_MODEINTERPOLATE  (1<<27) /* speed-up by partly skipping interpolate mode */
+#define XVID_ME_BFRAME_EARLYSTOP      (1<<28) /* speed-up by early exiting b-search */
+
+/* Unused */
+#define XVID_ME_UNRESTRICTED16        (1<<20) /* unrestricted ME, not implemented */
+#define XVID_ME_OVERLAPPING16         (1<<21) /* overlapping ME, not implemented */
+#define XVID_ME_UNRESTRICTED8         (1<<22) /* unrestricted ME, not implemented */
+#define XVID_ME_OVERLAPPING8          (1<<23) /* overlapping ME, not implemented */
+
+
+/*----------------------------------------------------------------------------
+ * xvid_enc_create_t structure definition
+ *
+ * This structure is passed as param1 during an instance creation (operation
+ * XVID_ENC_CREATE)
+ *--------------------------------------------------------------------------*/
+
+typedef struct {
+	int version;
+
+	int profile;                 /* [in] profile@level; refer to XVID_PROFILE_xxx */
+	int width;                   /* [in] frame dimensions; width, pixel units */
+	int height;                  /* [in] frame dimensions; height, pixel units */
+
+	int num_zones;               /* [in:opt] number of bitrate zones */
+	xvid_enc_zone_t * zones;     /*          ^^ zone array */
+
+	int num_plugins;             /* [in:opt] number of plugins */
+	xvid_enc_plugin_t * plugins; /*          ^^ plugin array */
+
+	int num_threads;             /* [in:opt] number of threads to use in encoder */
+	int max_bframes;             /* [in:opt] max sequential bframes (0=disable bframes) */
+
+	int global;                  /* [in:opt] global flags; controls encoding behavior */
+
+	/* --- vol-based stuff; included here for convenience */
+	int fincr;                   /* [in:opt] framerate increment; set to zero for variable framerate */
+	int fbase;                   /* [in] framerate base frame_duration = fincr/fbase seconds*/
+    /* ---------------------------------------------- */
+
+	/* --- vop-based; included here for convenience */
+	int max_key_interval;        /* [in:opt] the maximum interval between key frames */
+
+	int frame_drop_ratio;        /* [in:opt] frame dropping: 0=drop none... 100=drop all */
+
+	int bquant_ratio;            /* [in:opt] bframe quantizer multipier/offeset; used to decide bframes quant when bquant==-1 */
+	int bquant_offset;           /* bquant = (avg(past_ref_quant,future_ref_quant)*bquant_ratio + bquant_offset) / 100 */
+
+	int min_quant[3];            /* [in:opt] */
+	int max_quant[3];            /* [in:opt] */
+	/* ---------------------------------------------- */
+
+	void *handle;                /* [out] encoder instance handle */
+
+	/* ------- v1.3.x ------- */
+	int start_frame_num;         /* [in:opt] frame number of start frame relative to zones definitions. allows to encode sub-sequences */
+	int num_slices;              /* [in:opt] number of slices to code for each frame */
+} xvid_enc_create_t;
+
+
+/*----------------------------------------------------------------------------
+ * xvid_enc_frame_t structure definition
+ *
+ * This structure is passed as param1 during a frame encoding (operation
+ * XVID_ENC_ENCODE)
+ *--------------------------------------------------------------------------*/
+
+/* out value for the frame structure->type field
+ * unlike stats output in param2, this field is not asynchronous and tells
+ * the client app, if the frame written into the stream buffer is an ivop
+ * usually used for indexing purpose in the container */
+#define XVID_KEYFRAME (1<<1)
+
+/* The structure */
+typedef struct {
+	int version;
+
+	/* VOL related stuff
+	 * unless XVID_FORCEVOL is set, the encoder will not react to any changes
+	 * here until the next VOL (keyframe). */
+
+	int vol_flags;                     /* [in] vol flags */
+	unsigned char *quant_intra_matrix; /* [in:opt] custom intra qmatrix */
+	unsigned char *quant_inter_matrix; /* [in:opt] custom inter qmatrix */
+
+	int par;                           /* [in:opt] pixel aspect ratio (refer to XVID_PAR_xxx above) */
+	int par_width;                     /* [in:opt] aspect ratio width */
+	int par_height;                    /* [in:opt] aspect ratio height */
+
+	/* Other fields that can change on a frame base */
+
+	int fincr;                         /* [in:opt] framerate increment, for variable framerate only */
+	int vop_flags;                     /* [in] (general)vop-based flags */
+	int motion;                        /* [in] ME options */
+
+	xvid_image_t input;                /* [in] input image (read from) */
+
+	int type;                          /* [in:opt] coding type */
+	int quant;                         /* [in] frame quantizer; if <=0, automatic (ratecontrol) */
+	int bframe_threshold;
+
+	void *bitstream;                   /* [in:opt] bitstream ptr (written to)*/
+	int length;                        /* [in:opt] bitstream length (bytes) */
+
+	int out_flags;                     /* [out] bitstream output flags */
+} xvid_enc_frame_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
